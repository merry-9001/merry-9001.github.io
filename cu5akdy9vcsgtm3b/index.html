
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>设计模式 | 后知后觉的个人主页</title>
        <meta name="author" content="知乐" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>后知后觉的个人主页</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;首页</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;文档中心</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;后知后觉的个人主页</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenuItems">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">首页</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">文档中心</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

            <transition name="into">
            <div id="main" v-show="!loading">
                <div class="article">
    <div>
        <h1>设计模式</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/2/5
        </span>
        
        
    </div>

    <div class="content" v-pre>
        <h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><p>设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。<br>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。</p>
<h3 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h3><ul>
<li><strong>S – Single Responsibility Principle 单一职责原则</strong><ul>
<li>一个程序只做好一件事</li>
<li>如果功能过于复杂就拆分开，每个部分保持独立</li>
</ul>
</li>
<li><strong>O – OpenClosed Principle 开放/封闭原则</strong><ul>
<li>对扩展开放，对修改封闭</li>
<li>增加需求时，扩展新代码，而非修改已有代码</li>
</ul>
</li>
<li>L – Liskov Substitution Principle 里氏替换原则<ul>
<li>子类能覆盖父类</li>
<li>父类能出现的地方子类就能出现</li>
</ul>
</li>
<li>I – Interface Segregation Principle 接口隔离原则<ul>
<li>保持接口的单一独立</li>
<li>类似单一职责原则，这里更关注接口</li>
</ul>
</li>
<li>D – Dependency Inversion Principle 依赖倒转原则<ul>
<li>面向接口编程，依赖于抽象而不依赖于具体</li>
<li>使用方只关注接口而不关注具体类的实现</li>
</ul>
</li>
</ul>
<h2 id="设计模式分类（23-种设计模式）"><a href="#设计模式分类（23-种设计模式）" class="headerlink" title="设计模式分类（23 种设计模式）"></a>设计模式分类（23 种设计模式）</h2><ul>
<li>创建型<ul>
<li>单例模式</li>
<li>原型模式</li>
<li>工厂模式</li>
<li>抽象工厂模式</li>
<li>建造者模式</li>
</ul>
</li>
<li>结构型<ul>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
</li>
<li>行为型<ul>
<li>观察者模式</li>
<li>迭代器模式</li>
<li>策略模式</li>
<li>模板方法模式</li>
<li>职责链模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>中介者模式</li>
<li>解释器模式</li>
</ul>
</li>
</ul>
<h3 id="工厂模式（-）"><a href="#工厂模式（-）" class="headerlink" title="工厂模式（*）"></a>工厂模式（*）</h3><pre><code>class Product &#123;
    constructor(name) &#123;
        this.name = name
    &#125;
    init() &#123;
        console.log(&#39;init&#39;)
    &#125;
    fun() &#123;
        console.log(&#39;fun&#39;)
    &#125;
&#125;

class Factory &#123;
    create(name) &#123;
        return new Product(name)
    &#125;
&#125;

// use
let factory = new Factory()
let p = factory.create(&#39;p1&#39;)
p.init()
p.fun()
</code></pre>
<p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</li>
<li>将 new 操作简单封装，遇到 new 的时候就应该考虑是否用工厂模式；</li>
<li>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li>
</ul>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>创建对象的过程可能很复杂，但我们只需要关心创建结果。</li>
<li>构造函数和创建者分离, 符合“开闭原则”</li>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。</li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度</li>
<li>考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度</li>
</ul>
<h5 id="什么时候不用"><a href="#什么时候不用" class="headerlink" title="什么时候不用"></a>什么时候不用</h5><p>当被应用到错误的问题类型上时,这一模式会给应用程序引入大量不必要的复杂性.除非为创建对象提供一个接口是我们编写的库或者框架的一个设计上目标,否则我会建议使用明确的构造器,以避免不必要的开销。<br>由于对象的创建过程被高效的抽象在一个接口后面的事实,这也会给依赖于这个过程可能会有多复杂的单元测试带来问题。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><ul>
<li>曾经我们熟悉的 JQuery 的$()就是一个工厂函数，它根据传入参数的不同创建元素或者去寻找上下文中的元素，创建成相应的 jQuery 对象</li>
</ul>
<pre><code>class jQuery &#123;
    constructor(selector) &#123;
        super(selector)
    &#125;
    add() &#123;

    &#125;
  // 此处省略若干API
&#125;

window.$ = function(selector) &#123;
    return new jQuery(selector)
&#125;
</code></pre>
<ul>
<li>vue 的异步组件</li>
</ul>
<p>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：</p>
<pre><code>Vue.component(&#39;async-example&#39;, function (resolve, reject) &#123;
  setTimeout(function () &#123;
    // 向 `resolve` 回调传递组件定义
    resolve(&#123;
      template: &#39;&lt;div&gt;I am async!&lt;/div&gt;&#39;
    &#125;)
  &#125;, 1000)
&#125;)
</code></pre>
<h3 id="单例模式（-）"><a href="#单例模式（-）" class="headerlink" title="单例模式（*）"></a>单例模式（*）</h3><p>一个类只有一个实例，并提供一个访问它的全局访问点。</p>
<pre><code> class LoginForm &#123;
    constructor() &#123;
        this.state = &#39;hide&#39;
    &#125;
    show() &#123;
        if (this.state === &#39;show&#39;) &#123;
            alert(&#39;已经显示&#39;)
            return
        &#125;
        this.state = &#39;show&#39;
        console.log(&#39;登录框显示成功&#39;)
    &#125;
    hide() &#123;
        if (this.state === &#39;hide&#39;) &#123;
            alert(&#39;已经隐藏&#39;)
            return
        &#125;
        this.state = &#39;hide&#39;
        console.log(&#39;登录框隐藏成功&#39;)
    &#125;
 &#125;
 LoginForm.getInstance = (function () &#123;
     let instance
     return function () &#123;
        if (!instance) &#123;
            instance = new LoginForm()
        &#125;
        return instance
     &#125;
 &#125;)()

let obj1 = LoginForm.getInstance()
obj1.show()

let obj2 = LoginForm.getInstance()
obj2.hide()

console.log(obj1 === obj2)
</code></pre>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>划分命名空间，减少全局变量</li>
<li>增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护</li>
<li>且只会实例化一次。简化了代码的调试和维护</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合 从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试。</li>
</ul>
<h4 id="场景例子"><a href="#场景例子" class="headerlink" title="场景例子"></a>场景例子</h4><ul>
<li>定义命名空间和实现分支型方法</li>
<li>登录框</li>
<li>vuex 和 redux 中的 store</li>
</ul>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口转化为另外一个接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决。</p>
<pre><code>class Plug &#123;
  getName() &#123;
    return &#39;iphone充电头&#39;;
  &#125;
&#125;

class Target &#123;
  constructor() &#123;
    this.plug = new Plug();
  &#125;
  getName() &#123;
    return this.plug.getName() + &#39; 适配器Type-c充电头&#39;;
  &#125;
&#125;

let target = new Target();
target.getName(); // iphone充电头 适配器转Type-c充电头
</code></pre>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>可以让任何两个没有关联的类一起运行。</li>
<li>提高了类的复用。</li>
<li>适配对象，适配库，适配数据</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>额外对象的创建，非直接调用，存在一定的开销（且不像代理模式在某些功能点上可实现性能优化)</li>
<li>如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，尽量把文档完善</li>
</ul>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ul>
<li>整合第三方 SDK</li>
<li>封装旧接口</li>
</ul>
<pre><code>// 自己封装的ajax， 使用方式如下
ajax(&#123;
    url: &#39;/getData&#39;,
    type: &#39;Post&#39;,
    dataType: &#39;json&#39;,
    data: &#123;
        test: 111
    &#125;
&#125;).done(function() &#123;&#125;)
// 因为历史原因，代码中全都是：
// $.ajax(&#123;....&#125;)

// 做一层适配器
var $ = &#123;
    ajax: function (options) &#123;
        return ajax(options)
    &#125;
&#125;
</code></pre>
<h4 id="适配器与代理模式"><a href="#适配器与代理模式" class="headerlink" title="适配器与代理模式"></a>适配器与代理模式</h4><p>适配器与代理模式相似</p>
<ul>
<li>适配器模式： 提供一个不同的接口（如不同版本的插头）</li>
<li>代理模式： 提供一模一样的接口</li>
</ul>
<h3 id="装饰者模式（-）"><a href="#装饰者模式（-）" class="headerlink" title="装饰者模式（*）"></a>装饰者模式（*）</h3><ul>
<li>动态地给某个对象添加一些额外的职责，，是一种实现继承的替代方案</li>
<li>在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会影响从这个类中派生的其他对象</li>
</ul>
<pre><code>class Cellphone &#123;
    create() &#123;
        console.log(&#39;生成一个手机&#39;)
    &#125;
&#125;
class Decorator &#123;
    constructor(cellphone) &#123;
        this.cellphone = cellphone
    &#125;
    create() &#123;
        this.cellphone.create()
        this.createShell(cellphone)
    &#125;
    createShell() &#123;
        console.log(&#39;生成手机壳&#39;)
    &#125;
&#125;
// 测试代码
let cellphone = new Cellphone()
cellphone.create()

console.log(&#39;------------&#39;)
let dec = new Decorator(cellphone)
dec.create()
</code></pre>
<h4 id="场景例子-1"><a href="#场景例子-1" class="headerlink" title="场景例子"></a>场景例子</h4><ul>
<li>比如现在有 4 种型号的自行车，我们为每种自行车都定义了一个单 独的类。现在要给每种自行车都装上前灯、尾 灯和铃铛这 3 种配件。如果使用继承的方式来给 每种自行车创建子类，则需要 4×3 = 12 个子类。 但是如果把前灯、尾灯、铃铛这些对象动态组 合到自行车上面，则只需要额外增加 3 个类</li>
<li>ES7 Decorator <a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/decorator">阮一峰</a></li>
<li>core-decorators</li>
</ul>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul>
<li>装饰类和被装饰类都只关心自身的核心业务，实现了解耦。</li>
<li>方便动态的扩展功能，且提供了比继承更多的灵活性。</li>
</ul>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>多层装饰比较复杂。</li>
<li>常常会引入许多小对象，看起来比较相似，实际功能大相径庭，从而使得我们的应用程序架构变得复杂起来</li>
</ul>
<h3 id="观察者模式（-）"><a href="#观察者模式（-）" class="headerlink" title="观察者模式（*）"></a>观察者模式（*）</h3><p>定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。</p>
<ul>
<li>发布 &amp; 订阅</li>
<li>一对多</li>
</ul>
<pre><code>// 主题 保存状态，状态变化之后触发所有观察者对象
class Subject &#123;
  constructor() &#123;
    this.state = 0
    this.observers = []
  &#125;
  getState() &#123;
    return this.state
  &#125;
  setState(state) &#123;
    this.state = state
    this.notifyAllObservers()
  &#125;
  notifyAllObservers() &#123;
    this.observers.forEach(observer =&gt; &#123;
      observer.update()
    &#125;)
  &#125;
  attach(observer) &#123;
    this.observers.push(observer)
  &#125;
&#125;

// 观察者
class Observer &#123;
  constructor(name, subject) &#123;
    this.name = name
    this.subject = subject
    this.subject.attach(this)
  &#125;
  update() &#123;
    console.log(`$&#123;this.name&#125; update, state: $&#123;this.subject.getState()&#125;`)
  &#125;
&#125;

// 测试
let s = new Subject()
let o1 = new Observer(&#39;o1&#39;, s)
let o2 = new Observer(&#39;02&#39;, s)

s.setState(12)
</code></pre>
<h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><ul>
<li>DOM 事件</li>
</ul>
<pre><code>document.body.addEventListener(&#39;click&#39;, function() &#123;
    console.log(&#39;hello world!&#39;);
&#125;);
document.body.click()
</code></pre>
<h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul>
<li>支持简单的广播通信，自动通知所有已经订阅过的对象</li>
<li>目标对象与观察者之间的抽象耦合关系能单独扩展以及重用</li>
<li>增加了灵活性</li>
<li>观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</li>
</ul>
<h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><p>过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>是为一个对象提供一个代用品或占位符，以便控制对它的访问<br>假设当 A 在心情好的时候收到花，小明表白成功的几率有 60%，而当 A 在心情差的时候收到花，小明表白的成功率无限趋近于 0。 小明跟 A 刚刚认识两天，还无法辨别 A 什么时候心情好。如果不合时宜地把花送给 A，花 被直接扔掉的可能性很大，这束花可是小明吃了 7 天泡面换来的。 但是 A 的朋友 B 却很了解 A，所以小明只管把花交给 B，B 会监听 A 的心情变化，然后选 择 A 心情好的时候把花转交给 A，代码如下：</p>
<pre><code>let Flower = function() &#123;&#125;
let xiaoming = &#123;
  sendFlower: function(target) &#123;
    let flower = new Flower()
    target.receiveFlower(flower)
  &#125;
&#125;
let B = &#123;
  receiveFlower: function(flower) &#123;
    A.listenGoodMood(function() &#123;
      A.receiveFlower(flower)
    &#125;)
  &#125;
&#125;
let A = &#123;
  receiveFlower: function(flower) &#123;
    console.log(&#39;收到花&#39;+ flower)
  &#125;,
  listenGoodMood: function(fn) &#123;
    setTimeout(function() &#123;
      fn()
    &#125;, 1000)
  &#125;
&#125;
xiaoming.sendFlower(B)
</code></pre>
<h4 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h4><ul>
<li>HTML 元 素事件代理</li>
</ul>
<pre><code>&lt;ul id=&quot;ul&quot;&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
  &lt;li&gt;3&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  let ul = document.querySelector(&#39;#ul&#39;);
  ul.addEventListener(&#39;click&#39;, event =&gt; &#123;
    console.log(event.target);
  &#125;);
&lt;/script&gt;
</code></pre>
<h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><ul>
<li>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用</li>
<li>代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；</li>
</ul>
<h4 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h4><p>处理请求速度可能有差别，非直接访问存在开销</p>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>装饰者模式实现上和代理模式类似</p>
<ul>
<li>装饰者模式： 扩展功能，原有功能不变且可直接使用</li>
<li>代理模式： 显示原有功能，但是经过限制之后的</li>
</ul>

    </div>
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 后知后觉的个人主页
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;知乐
        </div>
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src='/js/main.js'></script>
    </body>
</html>
