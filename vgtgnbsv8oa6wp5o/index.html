
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>webpack快速入门 | 后知后觉的个人主页</title>
        <meta name="author" content="知乐" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>后知后觉的个人主页</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;首页</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;文档中心</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;后知后觉的个人主页</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenuItems">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">首页</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">文档中心</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

            <transition name="into">
            <div id="main" v-show="!loading">
                <div class="article">
    <div>
        <h1>webpack快速入门</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/8/27
        </span>
        
        
    </div>

    <div class="content" v-pre>
        <p><img src="20210508151156.png"></p>
<blockquote>
<p><strong>工程化，为复杂应用而生</strong></p>
<p>本文为保持简单，牺牲了某些语言的准确性</p>
</blockquote>
<h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><p><strong>webpack 是用来搭建前端工程的</strong></p>
<p>它运行在 node 环境中，它所做的事情，简单来说，就是<strong>打包</strong></p>
<p><img src="1724738096433-8b5f8cee-5590-41fa-aeef-8ff9824cdf4b.png"></p>
<p>具体来说，就是以某个模块作为入口，根据入口分析出所有模块的依赖关系，然后对各种模块进行合并、压缩，形成最终的打包结果</p>
<p><strong>在 webpack 的世界中，一切皆是模块</strong></p>
<h1 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h1><blockquote>
<p>按照习惯，所有的模块均放置在<code>src</code>目录中</p>
</blockquote>
<ol>
<li>安装依赖</li>
<li>编写多个模块随意编写一些模块，可以是 js、图片、音视频，以入口模块为起点，形成依赖关系</li>
<li>运行<code>npm run build</code>命令，进行打包</li>
<li>查看打包结果打包结果放置在 dist 目录中</li>
</ol>
<p>通过上面的体验，可以发现，webpack 给我们带来了至少以下好处：</p>
<ul>
<li>可以大胆的使用任意模块化标准无须担心兼容性问题，因为 webpack 完成打包后，已经没有了任何模块化语句</li>
<li>可以将一些非 JS 代码也视为模块这样可以对 css、图片等资源进行更加细粒度的划分</li>
<li>在前端开发中，使用 npm webpack 打包的过程中不会运行你的源代码；其中无论是你自己写的模块，还是通过 npm 安装的模块，webpack 一视同仁，统统视为依赖，最终合并到打包结果中</li>
<li>非常适合开发单页应用单页应用是前端用户体验最好的 web 应用所谓单页应用，是指只有一个 html 页面，页面中没有任何内容，所有的内容均靠 js 生成要优雅的实现单页应用，最好依托于前端框架，比如 vue、react</li>
</ul>
<h1 id="页面模板"><a href="#页面模板" class="headerlink" title="页面模板"></a>页面模板</h1><p>对于单页应用而言，只有一个空白的页面，所有内容都靠 JS 代码创建</p>
<p>webpack 会自动生成一个页面，并且在页面中会自动加入对 js 和 css 的引用</p>
<p>它生成页面时，参考的是<code>public/index.html</code>，其称之为页面模板</p>
<h1 id="public-目录"><a href="#public-目录" class="headerlink" title="public 目录"></a>public 目录</h1><p>webpack 会非常暴力的将 public 目录中的所有文件（除页面模板外），复制到打包结果中</p>
<h1 id="开发服务器"><a href="#开发服务器" class="headerlink" title="开发服务器"></a>开发服务器</h1><p>如果每次修改完代码，都要经过<code>打包-&gt;运行</code>，未免太过麻烦</p>
<p>在开发阶段，我们可以运行<code>npm run serve</code>命令获得更好的打包体验</p>
<p>该命令会让<code>webpack</code>启动一个<strong>开发服务器</strong>。</p>
<p>在这个阶段，webpack 并不会形成打包结果文件，而是把打包的内容放到内存中，当我们请求服务器时，服务器从内存中给予我们打包结果</p>
<p>与此同时，当源码发生变动时，webpack 会自动重新打包，同时刷新页面以访问到最新的打包结果</p>
<p><img src="20210508194443.png"></p>
<h1 id="文件缓存"><a href="#文件缓存" class="headerlink" title="文件缓存"></a>文件缓存</h1><p>可以看到，除了页面外，其他的资源在打包完成后，文件名多了一些奇奇怪怪的字符</p>
<p>例如：<code>js/app-9ea93.js</code></p>
<p>其中，<code>9ea93</code>这样的字符称之为<code>hash</code>，它会随着模块内容的变化而变化</p>
<p><strong>源码内容不变，hash 不变；源码内容变化，hash 变化</strong></p>
<p>之所以这样做，是因为生产环境中，浏览器会对除页面外的静态资源进行缓存</p>
<p>如果不设置 hash 值，一旦代码更新，浏览器还会使用之前缓存的结果，无法使用最新的代码</p>
<p><img src="1724738096567-f00022a9-fde3-4959-8a92-069e989d3463.png"></p>
<p>有了 hash 值之后，即可解决此问题</p>
<p><img src="20210508183454.png"></p>
<p>webpack 会在打包时自动处理 hash 值，并不会对我们写代码造成任何影响，但作为一个前端开发者，有必要了解这一点</p>
<h1 id="资源路径"><a href="#资源路径" class="headerlink" title="资源路径"></a>资源路径</h1><p><strong>除代码和样式模块外，其他模块被视为资源模块</strong></p>
<p>值得特别注意的是，<strong>资源模块在源代码中的路径和打包后的路径是不一样的</strong>，这就导致我们在编写代码的时候，根本无法知晓最终的路径</p>
<p>最常见的例子，就是在 css 中使用背景图片</p>
<pre><code class="css">.container &#123;
  /* 背景图使用了源码中的路径 */
  backgroud: url(&quot;../assets/1.png&quot;);
&#125;
</code></pre>
<p>它能正常工作吗？</p>
<p>它能！</p>
<p>因为 webpack 非常智能的发现了这一点，对于 css 中的路径，webpack 在打包时，会将其自动转换为打包结果的路径，比如，上面的代码在打包完成后，可能被转换为下面的格式</p>
<pre><code class="css">.container &#123;
  /* css中的资源路径会被自动替换，我们无须关心 */
  background: url(/img/1492ea.png);
&#125;
</code></pre>
<p>但如果我们要通过 js 动态的使用路径，webpack 是无法识别的</p>
<pre><code class="javascript">// 打包前
const url = &quot;./assets/1.png&quot;; // 该路径无法被转换
img.src = url;

// 打包后
const url = &quot;./assets/1.png&quot;; // ❌
img.src = url;
</code></pre>
<p>正确的做法是，通过模块化的方式导入资源，并获取资源路径</p>
<pre><code class="javascript">// 打包前
import url from &quot;./assets/1.png&quot;; // 打包后，url得到的将是真实的路径
img.src = url;

// 打包后
const url = &quot;/img/1492ea.png&quot;; // ✅
img.src = url;
</code></pre>
<h1 id="缺省的文件和后缀名"><a href="#缺省的文件和后缀名" class="headerlink" title="缺省的文件和后缀名"></a>缺省的文件和后缀名</h1><p>导入模块时，所有 js 模块均可省略<code>.js</code>，若导入的模块文件名为<code>index.js</code>，可省略文件名</p>
<pre><code class="javascript">import &quot;./home&quot;; // 若存在home.js，可省略js
import &quot;./movie&quot;; // 若movie是一个目录，此次导入的是 ./movie/index.js
</code></pre>
<h1 id="路径别名"><a href="#路径别名" class="headerlink" title="路径别名"></a>路径别名</h1><p>随着体量的增长，不可避免的，会形成层级极深的目录</p>
<pre><code class="shell">root
    |- src
        |- a
                |- a1
                        |- a2
                             |- index.js
        |- b
                |- b1
                        |- index.js
</code></pre>
<p>如果需要在<code>./src/a/a1/a2/index.js</code>中导入<code>./src/b/b1/index.js</code>，则可能产生下面特别恶心的代码</p>
<pre><code class="javascript">import &quot;../../../b/b1/index.js&quot;;
</code></pre>
<p>webpack 提供了别名供我们快速定位到<code>./src</code>目录，通常，该别名为<code>@</code></p>
<p>上面的导入代码可简化为</p>
<pre><code class="javascript">import &quot;@/b/b1&quot;; // @表示src目录，同时省略了index.js
</code></pre>
<h1 id="js-兼容性"><a href="#js-兼容性" class="headerlink" title="js 兼容性"></a>js 兼容性</h1><p>当 webpack 读取到 js 代码时，会自动对其进行兼容性处理</p>
<p>具体的处理方案涉及到两个配置文件：</p>
<ul>
<li><code>babel.config.js</code>：通过配置该文件，可以设置对哪些 js 代码进行降级处理</li>
<li><code>.browserslistrc</code>：通过配置该文件，可以设置在降级时，要兼容哪些浏览器，兼容的范围越光，降级产生的代码就越多，自然，打包后的体积就越大</li>
</ul>
<h1 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h1><p>webpack 在打包时，会对所有 js 和 css 代码进行压缩</p>
<p>对于 js，除了压缩之外，还会对其中的各种名称进行混淆</p>
<pre><code class="javascript">(self.webpackChunkmovie_list=self.webpackChunkmovie_list||[]).push([[587],&#123;3587:(r,t,n)=&gt;&#123;&quot;use strict&quot;;n.r(t),n(5666),n(1539),n(8674),n(9600),n(1249),n(2222);var e=n(9755),a=n.n(e);var o;function i(r)&#123;o.html(r.map((function(r)&#123;return&#39;&lt;li&gt;\n  &lt;a href=&quot;&#39;.concat(r.url,&#39;&quot; target=&quot;_blank&quot;&gt;\n    &lt;img src=&quot;&#39;).concat(r.cover,&#39;&quot; title=&quot;&#39;).concat(r.title,&#39;&quot;&gt;\n  &lt;/a&gt;\n  &lt;a href=&quot;&#39;).concat(r.url,&#39;&quot; target=&quot;_blank&quot; class=&quot;&#39;).concat(&quot;qmUYQv1xlJhGMQKz-kfAp&quot;,&#39;&quot;&gt;&#39;).concat(r.title,&#39;&lt;/a&gt;\n  &lt;p class=&quot;&#39;).concat(&quot;_3yV5wC-URYTUP0sPvaE0ZR&quot;,&#39;&quot;&gt;&#39;).concat(r.rate,&quot;&lt;/p&gt;\n  &lt;/li&gt;&quot;)&#125;)).join(&quot;&quot;))&#125;o=a()(&quot;&lt;ul&gt;&quot;).addClass(&quot;_1fsrc5VinfYHBXCF1s58qS&quot;).appendTo(&quot;#app&quot;);var c=n(8138);const u=
</code></pre>
<p>混淆的作用一方面是为了进一步压缩包体积，另一方面是为了让我们的代码更难被其他人理解利用</p>
<h1 id="源码地图-source-map"><a href="#源码地图-source-map" class="headerlink" title="源码地图 source map"></a>源码地图 source map</h1><p>我们运行的是 webpack 打包后的结果，而打包后的结果是很难阅读的</p>
<p>但这样一来会带来新的问题，如果代码报错，我们就难以知道到底是那一行代码写的有问题</p>
<p>此时源码地图就发挥了作用</p>
<p>可以发现，js 代码打包后都会跟上一个同名的、后缀为<code>.map</code>的文件，该文件就保存了原始代码的内容</p>
<p>请放心，这个内容人类是看不懂的，但浏览器可以看懂</p>
<p>当代码报错时，浏览器会定位到源码地图中的对应代码，而不是把真实报错的代码展示给我们</p>
<p>你无须关心这一点，但可以自然的从其中获得巨大的便利</p>
<h1 id="css-工程化"><a href="#css-工程化" class="headerlink" title="css 工程化"></a>css 工程化</h1><p>webpack 能够识别<strong>所有</strong>的样式代码，包括<code>css</code>、<code>less</code>、<code>sass</code>、<code>stylus</code></p>
<p>在打包时，会将它们转换成纯正的<code>css</code></p>
<p>除此之外，它还具备以下的神奇能力</p>
<h2 id="自动厂商前缀"><a href="#自动厂商前缀" class="headerlink" title="自动厂商前缀"></a>自动厂商前缀</h2><p>css 有很多兼容性问题，解决这些兼容性问题的最常见办法，就是加上厂商前缀。</p>
<p>比如：</p>
<pre><code class="css">/* 兼容性不好的代码 */
.container &#123;
  display: flex;
  transition: 1s;
&#125;

/* 兼容性好的代码 */
.container &#123;
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  -webkit-transition: 1s;
  transition: 1s;
&#125;
</code></pre>
<p>webpack 会根据<code>.browserlistrc</code>中指定的浏览器范围，<strong>按需、自动</strong>加上厂商前缀</p>
<p>我们开发无须关心</p>
<h2 id="css-module"><a href="#css-module" class="headerlink" title="css module"></a>css module</h2><p>css 文件多了后，你怎么保证它们里面没有冲突的类样式？</p>
<p>靠层级选择器？就不担心效率？</p>
<p>靠命名规范？就不担心脑袋爆炸？</p>
<p>要靠就靠 css module</p>
<p>当样式文件以<code>xxx.mdoule.xxx</code>的方式命名时，webpack 会将该文件当成一个开启了<code>css module</code>的文件</p>
<p>比如：<code>index.module.less</code>、<code>movie.module.css</code>，都是开启了<code>css module</code>的文件</p>
<p><strong>文件中的所有类名都会被 hash 化</strong></p>
<pre><code class="less">// 源码
.container &#123;
&#125;
.list &#123;
&#125;
.item &#123;
&#125;

// 打包结果，绝无可能重名
._2GFVidHvoHtfgtrdifua24 &#123;
&#125;
._1fsrc5VinfYHBXCF1s58qS &#123;
&#125;
.urPUKUukdS_UTSuWRI5-5 &#123;
&#125;
</code></pre>
<p>现在就一个问题，我们在使用类名时，如何知道它打包结果的类名呢？</p>
<pre><code class="javascript">import &quot;./index.module.less&quot;;
dom.classList.add(&quot;container&quot;); // ❌ 最终的类名可不是这个
</code></pre>
<p>正确的方式如下：</p>
<pre><code class="javascript">// styles 是一个对象，里面映射了源码类名和打包类名的关系
import styles from &quot;./index.module.less&quot;;
dom.classList.add(styles.container); // ✅ 属性container中记录的就是container转换后的类名
</code></pre>
<h1 id="真正的-webpack-没有那么神奇"><a href="#真正的-webpack-没有那么神奇" class="headerlink" title="真正的 webpack 没有那么神奇"></a>真正的 webpack 没有那么神奇</h1><p>实际上，webpack 没有做这么多事，我们不能把功劳（怨念）全归结于它</p>
<p>它只是站在巨人（其他流氓）肩膀上而已</p>
<p>下图可以看个热闹</p>
<p><img src="20210508203658.png"></p>
<p>webpack 通过插件（plugin）和加载器（loader）将这些技术整合在一起</p>
<p><code>上图的技术 + 乱七八糟一大堆其他技术 + 老师的配置 = 呈现给你的工程</code></p>
<p>目前，你无须理解这一些，保持敬畏即可</p>
<p>最后，说明一下工程中看不懂的文件：</p>
<ul>
<li><code>.browserslistrc</code>，表达适配的浏览器范围，会被工程化中的其他技术所使用</li>
<li><code>babel.config.js</code>，<code>babel</code>的配置文件，做 js 降级处理</li>
<li><code>postcss.config.js</code>，<code>postcss</code>的配置文件，做 css 代码转换</li>
<li><code>webpack.config.js</code>，<code>webpack</code>的配置文件，整合其他工程化技术，以及配置打包细节、开发服务器、路径别名等等</li>
</ul>
<h1 id="对我们开发的影响"><a href="#对我们开发的影响" class="headerlink" title="对我们开发的影响"></a>对我们开发的影响</h1><ol>
<li>学会访问开发服务器查看效果</li>
<li>学会动态获取资源文件路径</li>
</ol>
<pre><code class="javascript">import url from &quot;./assets/1.png&quot;;
img.src = url;
</code></pre>
<ol start="3">
<li>学会省略文件和后缀名</li>
</ol>
<pre><code class="javascript">import &quot;./home&quot;; // 若存在home.js，可省略js
import &quot;./movie&quot;; // 若movie是一个目录，此次导入的是 ./movie/index.js
</code></pre>
<ol start="4">
<li>学会使用别名简化导入代码</li>
</ol>
<pre><code class="javascript">import &quot;@/b/b1&quot;; // 实际导入： src/b/b1/index.js  (若b1是目录)
</code></pre>
<ol start="5">
<li>学会使用 css module</li>
</ol>
<pre><code class="javascript">// styles 是一个对象，里面映射了源码类名和打包类名的关系
import styles from &quot;./index.module.less&quot;;
dom.classList.add(styles.container);
</code></pre>

    </div>
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 后知后觉的个人主页
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;知乐
        </div>
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src='/js/main.js'></script>
    </body>
</html>
