
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>vue | 后知后觉的个人主页</title>
        <meta name="author" content="知乐" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>后知后觉的个人主页</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;首页</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;文档中心</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;后知后觉的个人主页</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenuItems">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">首页</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">文档中心</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

            <transition name="into">
            <div id="main" v-show="!loading">
                <div class="article">
    <div>
        <h1>vue</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/11
        </span>
        
        
    </div>

    <div class="content" v-pre>
        <h2 id="vue2-与-vue3-的对比"><a href="#vue2-与-vue3-的对比" class="headerlink" title="vue2 与 vue3 的对比"></a>vue2 与 vue3 的对比</h2><h3 id="vue2-和-vue3-的区别"><a href="#vue2-和-vue3-的区别" class="headerlink" title="vue2 和 vue3 的区别"></a>vue2 和 vue3 的区别</h3><p>核心区别：</p>
<p>1.构造方式不同，vue2 是都挂载在构造函数上，vue3 都变成了普通函数导出(有利于 tree shaking)</p>
<p>2.数据响应式(Object.defineProperty 和 proxy)</p>
<p>3.增加了 hook 和 Composition Api,更加靠近函数式编程，使代码逻辑能复用</p>
<p>4.效率提升（节点）,diff 算法</p>
<p>5.源码组织方式变化：使用 TS 重写</p>
<p>其他区别：</p>
<p>1.vue3 可以有多个根组件</p>
<p>2.vue3 里面 v-if 的优先级高于 v-for</p>
<p>3.生命周期函数 beforeDestroy 改成了 beforeUnmount，使用 setup 代替了之前的 beforeCreate 和 created</p>
<p>4.vue2 中用 this 访问的 route,store,prop，在 vue3 中都使用了函数的形式</p>
<h3 id="说一下-vue3-0-是如何变得更快的？"><a href="#说一下-vue3-0-是如何变得更快的？" class="headerlink" title="说一下 vue3.0 是如何变得更快的？"></a><strong>说一下 vue3.0 是如何变得更快的？</strong></h3><p><strong>优化算法</strong></p>
<ol>
<li>静态提升：编译器找到静态节点，把他提升。因为一个节点如果是纯静态的话，没必要在渲染函数中去定义，因为渲染函数会反复运行，于是 vue3 会把静态节点放到渲染函数之外。</li>
</ol>
<pre><code class="typescript">// vue2 的静态节点
render()&#123;
  createVNode(&quot;h1&quot;, null, &quot;Hello World&quot;)
  // ...
&#125;

// vue3 的静态节点
const hoisted = createVNode(&quot;h1&quot;, null, &quot;Hello World&quot;)
function render()&#123;
  // 直接使用 hoisted 即可
&#125;
</code></pre>
<blockquote>
<p>如果一个节点是动态，属性是静态的(class)，也可以将属性部分静态提升</p>
</blockquote>
<ol start="2">
<li>预字符串化：当编译器遇到大量连续的静态内容，会直接将其编译为一个普通字符串节点</li>
</ol>
<pre><code class="typescript">const _hoisted_2 = _createStaticVNode(
  &#39;&lt;div class=&quot;logo&quot;&gt;&lt;h1&gt;logo&lt;/h1&gt;&lt;/div&gt;&lt;ul class=&quot;nav&quot;&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;menu&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;menu&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;menu&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;menu&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;menu&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&#39;
);
</code></pre>
<ol start="3">
<li>缓存事件处理函数：对事件处理函数进行缓存</li>
</ol>
<pre><code class="typescript">// vue2
render(ctx)&#123;
  return createVNode(&quot;button&quot;, &#123;
    onClick: function($event)&#123;
      ctx.count++;
    &#125;
  &#125;)
&#125;

// vue3
render(ctx, _cache)&#123;
  return createVNode(&quot;button&quot;, &#123;
    onClick: cache[0] || (cache[0] = ($event) =&gt; (ctx.count++))
  &#125;)
&#125;
</code></pre>
<ol start="4">
<li>Block Tree：提升两棵树（新旧）的对比效率</li>
</ol>
<p>vue3 的编译器能够标记每一节点是静态节点还是动态节点，这使得 vue3 在进行树的对比时候只会对比动态节点（静态节点永远不会改变）（vue3 更新是组件级别的，所以会从根节点开始进行动态节点对比）</p>
<ol start="5">
<li>PatchFlag：vue3 对单个节点的对比只会去比较那些动态的节点。</li>
</ol>
<p><strong>体积变小</strong></p>
<ol>
<li>重写后的 Vue 支持了 tree-shaking，像 keep-alive、transition 甚至 v-for 等功能都可以按需引入。</li>
<li>优化了打包方法，使得打包后的 bundle 的体积也更小。</li>
</ol>
<h3 id="vue2-更新到-vue3-的方法"><a href="#vue2-更新到-vue3-的方法" class="headerlink" title="vue2 更新到 vue3 的方法"></a>vue2 更新到 vue3 的方法</h3><p>1.package.json 去掉 vue2.x 改为 vue3.x，然后安装@vue/compat</p>
<p>2.package.json 去掉 vue-template-compiler 改为@vue/compiler-sfc</p>
<p>3.在 webpack 或者 vue-cli 中打开兼容模式</p>
<pre><code class="css">module.exports = &#123;
  resolve: &#123;
    alias: &#123;
      vue: &#39;@vue/compat&#39;
    &#125;
  &#125;,
  module: &#123;
    rules: [
      &#123;
        test: /\.vue$/,
        loader: &#39;vue-loader&#39;,
        options: &#123;
          compilerOptions: &#123;
            compatConfig: &#123;
              MODE: 2
            &#125;
          &#125;
        &#125;
      &#125;
    ]
  &#125;
&#125;
</code></pre>
<p>4.修改入口的构造函数为导出函数</p>
<p>5.升级 vuex 和 router</p>
<p>6.就是语法层面，有些 vue.set(),生命周期钩子会改名</p>
<h2 id="vue-概念题"><a href="#vue-概念题" class="headerlink" title="vue 概念题"></a>vue 概念题</h2><h3 id="谈一谈对-MVVM-的理解"><a href="#谈一谈对-MVVM-的理解" class="headerlink" title="谈一谈对 MVVM 的理解"></a><strong>谈一谈对 MVVM 的理解</strong></h3><p>MVVM 是 Model-View-ViewModel 的缩写。MVVM 是一种设计思想</p>
<ul>
<li>Model 层代表数据模型，可以在 Model 中定义数据修改和操作的业务逻辑</li>
<li>View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来</li>
<li>ViewModel 是一个同步 View 和 Model 的对象</li>
</ul>
<p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互， Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上</p>
<p>对 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理</p>
<h3 id="说一下-Vue-的优点，特点"><a href="#说一下-Vue-的优点，特点" class="headerlink" title="说一下 Vue 的优点，特点"></a><strong>说一下 Vue 的优点，特点</strong></h3><ol>
<li>数据响应式</li>
</ol>
<p>只需要关注数据的变化，而不用关注页面的变化） 数据变化 -&gt; 重新渲染</p>
<p>数据决定界面，解决了界面展示与数据展示不一致</p>
<ol start="2">
<li><p>虚拟 dom</p>
</li>
<li><p>单向数据流</p>
</li>
</ol>
<p>谁的数据谁负责，其他人动不了</p>
<ol start="4">
<li>预编译</li>
</ol>
<p>5.组件化开发</p>
<p>Vue 通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（component）中，我们只要先在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性），然后再分别写好各种组件的实现（填坑），然后整个应用就算做完了。</p>
<p>组件化开发的优点：提高开发效率、方便重复使用、简化调试步骤、提升整个项目的可维护性、便于协同开发。</p>
<h3 id="讲讲虚拟-dom"><a href="#讲讲虚拟-dom" class="headerlink" title="讲讲虚拟 dom"></a>讲讲虚拟 dom</h3><p>是什么：<br>虚拟 dom 本质上就是一个普通的 JS 对象，用于描述视图的界面结构</p>
<p>vue 依靠虚拟 dom 树生成真实的 dom（他的优势在于修改时）</p>
<p>每个组件都有一个 render 函数，每个 render 函数都会返回一个虚拟 dom 树，这也就意味着每个组件都对应一棵虚拟 DOM 树</p>
<p>动机：</p>
<p>框架设计导致的，由于 vue 是数据驱动的，就是数据发生变化，界面要跟着变，vue 一个组件可能牵扯到 100 个 dom 元素，改动了某一个数据，vue 不知道去修改哪个 dom 元素(因为是以组件为单位),所以只能重新运行 render 函数重新渲染，由于每次都要重新渲染效率太低，于是出了虚拟 dom 这个折中办法，然后进行对比，把变的东西操作 dom；还有一个原因是虚拟 dom 不与上层使用绑定，使得 vue 也可以在小程序，移动端，桌面端去使用，因为虚拟 dom 只是一个 js 对象</p>
<blockquote>
<p>svelte 没有虚拟 dom，但他的效率更高；svelte 在编译期间就能做到哪个数据对应那个真正 dom，所以他不需要虚拟 dom，所以他效率更高</p>
</blockquote>
<p>js 的计算效率要比创建和销毁 dom 的效率高很多，由于真实 DOM 的创建、更新、插入等操作会带来大量的性能损耗，从而就会极大的降低渲染效率。所以 vue 增加了虚拟 dom，当页面结构发生变化的时候，先比较两棵树的虚拟 dom，利用 diff 算法去计算出要更新的节点，然后再更新必要的节点。这样方式的效果高。</p>
<p>使用 diff 计算出更新的节点（JS 层面）</p>
<p>更新必要的 DOM 节点（DOM 层面）</p>
<p>虚拟 dom 的好处：</p>
<p>1.最小量的去更新真实 dom</p>
<p>2.将页面抽象成为了对象，可移植，解耦页面，也为 keep-alive 保存页面提供了方式</p>
<blockquote>
<p>虚拟 dom 多平台渲染的抽象能力(因为中间夹了一层，那么这层就是可移植的)</p>
</blockquote>
<p>虚拟 dom 的属性：</p>
<p>key：标识节点唯一性</p>
<p>el：对应的实际元素</p>
<p>prop：属性信息(id,class,href);<font style="color:rgba(0, 0, 0, 0.85);">对于自定义组件，这里会包含传递给组件的所有 props（属性）值。</font></p>
<p>type：类型</p>
<p>children：子节点</p>
<p>component：子组件</p>
<h3 id="讲讲模板编译（预编译）"><a href="#讲讲模板编译（预编译）" class="headerlink" title="讲讲模板编译（预编译）"></a>讲讲模板编译（预编译）</h3><p>vue 的源码中有一个 compile 模块，它主要负责将模板（本质是一个字符串）转换为 render 函数</p>
<p>模板编译器在对模板字符串进行编译的时候，是一点一点转换而来的，整个过程：</p>
<p><img src="1732868874691-dff8b280-730c-47df-8457-b6567d75e6cf.png"></p>
<ul>
<li>解析器：负责将模板字符串解析为对应的模板 AST</li>
<li>转换器：负责将模板 AST 转换为 JS AST</li>
<li>生成器：将 JS AST 生成最终的渲染函数（h 函数）</li>
</ul>
<blockquote>
<p>当中肯定会标记响应式的动态内容和静态属性（区分）</p>
</blockquote>
<p>如果使用传统的引入方式，则编译时间发生在组件第一次加载时，这称之为运行时编译。</p>
<p>如果是在 vue-cli 或者 vite 的默认配置下，编译发生在打包时，这称之为模板预编译。</p>
<p>模板预编译(template)</p>
<p>当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。</p>
<p>预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。</p>
<p>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。</p>
<p>简单来说，当 vue 进行打包时，会直接把组件中的模板转换为 render 函数，这叫做模板预编译</p>
<p><strong>模板预编译只会发生在单文件组件(SFC)，并且把模板代码写在 template 里面的时候</strong></p>
<pre><code class="javascript">export default &#123;
  //这样不会发生预编译
  template() &#123;&#125;,
&#125;;
</code></pre>
<blockquote>
<p>在单文件组件(SFC)中，同时拥有 template 和 render 函数的时候，率先运行 template，而在普通方式引入的时候会率先读取 render 函数</p>
</blockquote>
<p><strong>这样做的好处在于：</strong></p>
<p>运行时就不再需要编译模板了，提高了运行效率，打包结果中不再需要 vue 的编译代码，减少了打包体积</p>
<p>打包完成的时候，还没有运行的时候，模板已经变成了一个 render 函数，这样就省略了打包结果中还需要再进行编译模板的代码，减少打包体积（这一步是打包的时候做的）</p>
<p>编译是一个极其耗费性能的操作，预编译可以有效的提高运行时的性能，而且，由于运行的时候已不需要编译，vue-cli 在打包时会排除掉 vue 中的 compile 模块，以减少打包体积</p>
<p>模板的存在，仅仅是为了让开发人员更加方便的书写界面代码</p>
<p><strong>vue 最终运行的时候，最终需要的是 render 函数，而不是模板，因此，模板中的各种语法，在虚拟 dom 中都是不存在的，它们都会变成虚拟 dom 的配置</strong></p>
<h2 id="vue-原理题"><a href="#vue-原理题" class="headerlink" title="vue 原理题"></a>vue 原理题</h2><h3 id="解释一下对-Vue-生命周期的理解"><a href="#解释一下对-Vue-生命周期的理解" class="headerlink" title="解释一下对 Vue 生命周期的理解"></a><strong>解释一下对 Vue 生命周期的理解</strong></h3><ul>
<li>什么是 vue 生命周期</li>
<li>vue 生命周期的作用是什么</li>
<li>vue 生命周期有几个阶段</li>
<li>第一次页面加载会触发哪几个钩子</li>
<li>DOM 渲染在哪个周期就已经完成</li>
<li>多组件（父子组件）中生命周期的调用顺序说一下</li>
</ul>
<p>组件实例创建前：setup、beforeCreate</p>
<p>组件实例创建后：created</p>
<p><strong>什么是 **<strong>vue*</strong>* 生命周期</strong></p>
<p>生命周期就是一个 <strong>vue 组件实例</strong>从创建到销毁的过程。</p>
<p><strong>vue**</strong> 生命周期的作用是什么**</p>
<p>在生命周期的过程中会运行着一些叫做生命周期的函数，给予了开发者在不同的生命周期阶段添加业务代码的能力。</p>
<p>其实和回调是一个概念，当系统执行到某处时，检查是否有 hook(钩子)，有的话就会执行回调。</p>
<p>通俗的说，hook 就是在程序运行中，在某个特定的位置，框架的开发者设计好了一个钩子来告诉我们当前程序已经运行到特定的位置了，会触发一个回调函数，并提供给我们，让我们可以在生命周期的特定阶段进行相关业务代码的编写。</p>
<p><strong>vue**</strong> 生命周期有几个阶段**</p>
<p>它可以总共分为 8 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。</p>
<ul>
<li>beforeCreate：是 new Vue( ) 之后触发的第一个钩子，在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。</li>
<li>created：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。可以做一些初始数据的获取，在当前阶段无法与 DOM 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 DOM 。</li>
<li>beforeMount：发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段虚拟 DOM 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 updated。</li>
<li>mounted：在挂载完成后发生，在当前阶段，真实的 DOM 挂载完毕，数据完成双向绑定，可以访问到 DOM 节点，使用 refs 属性对 DOM 进行操作。</li>
<li>beforeUpdate：发生在更新之前，也就是响应式数据发生更新，虚拟 DOM 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</li>
<li>updated：发生在更新完成之后，当前阶段组件 DOM 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</li>
<li>beforeDestroy（beforeUnmount）：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</li>
<li>destroyed（unmounted）：发生在实例销毁之后，这个时候只剩下了 DOM 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</li>
</ul>
<p><strong>第一次页面加载会触发哪几个钩子</strong></p>
<p>会触发 4 个钩子，分别是：beforeCreate、created、beforeMount、mounted</p>
<p><strong>DOM**</strong> 渲染在哪个周期就已经完成**</p>
<p>DOM 渲染是在 mounted 阶段完成，此阶段真实的 DOM 挂载完毕，数据完成双向绑定，可以访问到 DOM 节点。</p>
<p><strong>多组件（父子组件）中生命周期的调用顺序说一下</strong></p>
<p>组件的调用顺序都是先父后子，渲染完成的顺序是先子后父。组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</p>
<ul>
<li>加载渲染过程：父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount- &gt;子 mounted-&gt;父 mounted</li>
<li>子组件更新过程：父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</li>
<li>父组件更新过程：父 beforeUpdate -&gt; 父 updated</li>
<li>销毁过程：父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</li>
</ul>
<h3 id="Vue-实现双向数据绑定原理是什么？（Vue2）"><a href="#Vue-实现双向数据绑定原理是什么？（Vue2）" class="headerlink" title="Vue 实现双向数据绑定原理是什么？（Vue2）"></a><strong>Vue 实现双向数据绑定原理是什么？（Vue2）</strong></h3><p>采用<strong>数据劫持</strong>结合<strong>发布订阅模式</strong>（PubSub 模式）的方式，通过 Object.defineProperty 来劫持各个属性的 setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
<p>Vue 的数据双向绑定整合了 监听器 Observer，解析器 Compile 和订阅者 Watcher 三者</p>
<p>通过 Observer 来监听自己的 model 的数据变化</p>
<p>通过 Compile 来解析编译模板指令</p>
<p>最后利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化-&gt;视图更新，视图交互变化（例如 input 操作）-&gt;数据 model 变更的双向绑定效果。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/22718987/1713354407381-b7edb1ec-c64e-4d06-b0b4-5565f9aadac8.jpeg"></p>
<h3 id="Vue3-响应式数据"><a href="#Vue3-响应式数据" class="headerlink" title="Vue3 响应式数据"></a><strong>Vue3 响应式数据</strong></h3><p><strong>响应式本质</strong></p>
<p>是被监控的函数和<strong>函数中用到</strong>的<strong>响应式数据</strong>的关联</p>
<p>函数：被监控的函数</p>
<p>render</p>
<p>watchEffect</p>
<p>watch</p>
<p>computed 函数</p>
<p>effect(源码内部的底层实现)</p>
<blockquote>
<p>注意:如果在函数的运行期间存在异步代码，那么异步的代码统统不看了（不产生关联）</p>
</blockquote>
<p><strong>函数中用到</strong>的<strong>响应式数据（一定要是获取对象的某个属性，并且这个对象是响应式的）</strong></p>
<p>props</p>
<p>ref</p>
<p>reactive</p>
<p>computed 返回的数据</p>
<p>数据和函数关联起来以后，将来有一天数据发生变化，函数重新运行</p>
<p>函数在运行期间，出现了读取响应式数据被拦截的情况，我们就称之为两者之间产生了依赖，这个依赖（也就是一个对应关系）是会被收集的，方便响应式数据发生变化时重新执行对应的函数。</p>
<p>被监控的函数，在它的<strong>同步</strong>代码运行期间，读取或者操作被拦截的响应式数据会建立依赖关系（依赖收集）</p>
<p>建立了依赖关系之后，响应式数据发生变化，对应的函数才会重新执行（派发更新）。</p>
<p>所谓响应式，背后其实就是函数和数据的一组映射，当数据发生变化，会将该数据对应的所有函数全部执行一遍。当然这里的数据和函数都是有要求的。数据是响应式数据，函数是被监控的函数。</p>
<blockquote>
<p>收集数据和函数的映射关系在 Vue 中被称之为依赖收集</p>
<p>数据变化通知映射的函数重新执行被称之为派发更新</p>
<p>依赖收集：所谓依赖收集，其实就是收集的一些函数。因为当数据发生变化的时候，需要重新执行这些函数，因此需要提前收集起来。</p>
<p>派发更新：所谓派发更新，就是通知被收集了的函数，现在数据已经更新了，你们需要重新执行一遍。</p>
</blockquote>
<p><strong>Vue3.x**</strong> 响应式数据原理是什么？**</p>
<p>在 Vue 2 中，响应式原理就是使用的 Object.defineProperty 来实现的。但是在 Vue 3.0 中采用了 Proxy，抛弃了 Object.defineProperty 方法。</p>
<p>究其原因，主要是以下几点：</p>
<ul>
<li>Object.defineProperty 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应</li>
<li>Object.defineProperty 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy 可以劫持整个对象，并返回一个新的对象。</li>
<li>Object.definedProperty 不支持数组(可以监听数组,不过数组方法无法监听自己重写)，更准确的说是不支持数组的各种 API(所以 Vue 重写了数组方法。</li>
<li>Proxy 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li>
<li>Proxy 有多达 13 种拦截方法</li>
<li>Proxy 是直接代理劫持整个对象。</li>
</ul>
<p><strong>Proxy**</strong> 只会代理对象的第一层，那么 *<strong>*Vue3**</strong> 又是怎样处理这个问题的呢？**</p>
<p>判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法做代理， 这样就实现了深度观测。</p>
<p><strong>监测数组的时候可能触发多次 **<strong>get/set*</strong>*，那么如何防止触发多次呢？</strong></p>
<p>我们可以判断 key 是否为当前被代理对象 target 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 trigger。</p>
<h3 id="v-model-双向绑定的原理是什么？"><a href="#v-model-双向绑定的原理是什么？" class="headerlink" title="v-model 双向绑定的原理是什么？"></a><strong>v-model 双向绑定的原理是什么？</strong></h3><p>v-model 本质就是传入一个属性和一个方法</p>
<ul>
<li>一个名为 <code>modelValue</code> 的 prop，本地 ref 的值与其同步；</li>
<li>一个名为 <code>update:modelValue</code> 的事件，当本地 ref 的值发生变更时触发。</li>
</ul>
<p>v-model 依然保持单向数据流</p>
<p>v-model 本质就是 :value + input 方法的语法糖。可以通过 model 属性的 prop 和 event 属性来进行自定义。</p>
<p>原生的 v-model，会根据标签的不同生成不同的事件和属性。</p>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件</li>
<li>select 字段将 value 作为 prop 并将 change 作为事件</li>
</ul>
<p>以输入框为例，当用户在输入框输入内容时，会触发 input 事件，从而更新 value。而 value 的改变同样会更新视图，这就是 vue 中的双向绑定。</p>
<h3 id="讲讲-vue-的-diff-算法"><a href="#讲讲-vue-的-diff-算法" class="headerlink" title="讲讲 vue 的 diff 算法"></a><strong>讲讲 vue 的 diff 算法</strong></h3><p>vue 一切的出发点，都是为了：</p>
<p>● 尽量啥也别做</p>
<p>● 不行的话，尽量仅改动元素属性</p>
<p>● 还不行的话，尽量移动元素，而不是删除和创建元素</p>
<p>● 还不行的话，删除和创建元素</p>
<p>在对比时，vue 采用深度优先、同层比较的方式进行比对。</p>
<blockquote>
<p>正常 Diff 两个树的时间复杂度是 O(n^3)，但实际情况下我们很少会进行跨层级的移动 DOM，所以 Vue 将 Diff 进行了优化，从 O(n^3) -&gt; O(n)，只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。</p>
</blockquote>
<p>简单来说，diff 算法有以下过程</p>
<ul>
<li>同级比较，再比较子节点</li>
<li>先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除)</li>
<li>比较都有子节点的情况(核心 diff)</li>
<li>递归比较子节点</li>
</ul>
<p>vue2 双端 diff：同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点</p>
<blockquote>
<p>在判断两个节点是否相同时，vue 是通过虚拟节点的 key 和 tag 来进行判断的</p>
<p>具体步骤：</p>
<p>1.对根节点进行对比，如果相同则将旧节点关联的真实 dom 的引用挂到新节点上，根据需要更新属性到真实 dom</p>
<p>2 再对比其子节点数组；如果不相同，则按照新节点的信息递归创建所有真实 dom，同时挂到对应虚拟节点上，然后移除掉旧的 dom。</p>
<p>在对比其子节点数组时，vue 对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实 dom，尽量少的销毁和创建真实 dom。如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实 dom 到合适的位置。（核心 diff）</p>
<p>这样一直递归的遍历下去，直到整棵树完成对比。</p>
</blockquote>
<p>vue2 diff 双端对比</p>
<p>1.比较头指针是否相同</p>
<p>2.比较尾部指针是否相同</p>
<p>3.用旧节点头指针去比较新节点尾指针</p>
<p>4.用新节点尾指针去看在旧的树中存在不存在</p>
<p>vue3 快速 diff：包括了双端 diff 和最长递增子序列算法</p>
<blockquote>
<p>vue3 还在单节点的比较上有较大提升，动态有标识，事件有缓存，block tree</p>
<p>预处理阶段：处理首尾节点，找出新旧两种子节点中首尾可复用的节点并更新。</p>
<p>处理理想情况下新增和删除节点：若通过预处理有一组节点已经更新完毕，证明新的一组子节点只需新增或删除部分节点即可完成更新。</p>
<p>构造 source 数组：通过遍历新旧两组子节点，构造一个 source 数组,去存储新的子节点对应的旧子节点的位置索引，并在此过程中判断是否需要使用 diff 算法处理移动。</p>
<p>节点位置移动：根据最长递增子序列判断具体的某个节点是否需要新增或者移动，在需要时移动节点以匹配新的子节点顺序。</p>
<p>最长递增子序列：找到两个最长的一样的序列，保持他们的不动，这样就可以最小量的修改 dom</p>
<p>最长递增子序列好在哪里？</p>
<p>用了这个方式不会降低是不会降低 diff 的时间复杂度的与空间复杂度</p>
<p>用这个方式是为了尽量的保证两棵树的稳定，降低修改真正 dom 的量</p>
</blockquote>
<h3 id="讲讲-vue-中的-key"><a href="#讲讲-vue-中的-key" class="headerlink" title="讲讲 vue 中的 key"></a><strong>讲讲 vue 中的 key</strong></h3><p><strong>key 的作用主要是为了高效的更新虚拟 DOM</strong></p>
<p>key 属性的目的是为了让 vue 可以区分它们，相当于是一个唯一 id</p>
<p>在 diff 算法和使用相同标签名元素的过渡切换时，会使用到 key 属性</p>
<p>1.高效的更新： key 帮助 Vue 识别哪些元素是变化的、哪些是新的、哪些是需要被移除的。</p>
<p>在没有 key 的情况下，Vue 会尽量复用已有元素，而不管它们的实际内容是否发生了变化，这可能导致不必要的更新或者错误的更新。</p>
<p>通过使用 key，Vue 可以准确地知道哪些元素发生了变化，从而高效地更新 DOM。</p>
<p>2.确保元素的唯一性： key 属性需要是唯一的，这样每个元素在列表中都可以被唯一标识。这避免了在元素移动、插入或删除时出现混淆，确保 Vue 可以正确地追踪每个元素。</p>
<p>3.提升渲染性能： 使用 key 可以显著提升列表渲染的性能。因为 Vue 能通过 key 快速定位到需要更新的元素，而不是重新渲染整个列表。尤其在处理大型列表时，使用 key 可以避免大量不必要的 DOM 操作，提升应用的响应速度。</p>
<p>同名元素过渡切换</p>
<pre><code class="javascript">&lt;transition name=&quot;fade-transition&quot;&gt;
    &lt;img v-for=&quot;(image, index) in images&quot; :key=&quot;image.id&quot; :src=&quot;image.src&quot; alt=&quot;Slide&quot;&gt;
&lt;/transition&gt;

.fade - transition - enter - from,
.fade - transition - leave - to &#123;
     opacity: 0;
 &#125;
.fade - transition - enter - to,
.fade - transition - leave - from &#123;
     opacity: 1;
 &#125;
.fade - transition - enter - active,
.fade - transition - leave - active &#123;
     transition: opacity 0.5s;
 &#125;
</code></pre>
<p><font style="color:rgba(0, 0, 0, 0.85);">由于</font><code>key</code><font style="color:rgba(0, 0, 0, 0.85);">的存在，Vue 能够正确地识别哪些图片元素是新的，哪些是旧的，从而在新旧图片之间应用淡入淡出的过渡效果。如果没有</font><code>key</code><font style="color:rgba(0, 0, 0, 0.85);">或者</font><code>key</code><font style="color:rgba(0, 0, 0, 0.85);">不唯一，可能会出现图片闪烁或者过渡效果混乱的情况。</font></p>
<h3 id="讲讲-keep-alive"><a href="#讲讲-keep-alive" class="headerlink" title="讲讲 keep-alive"></a><strong>讲讲 keep-alive</strong></h3><ul>
<li>keep-alive 的常用属性有哪些</li>
<li>keep-alive 相关的生命周期函数是什么，什么场景下会进行使用</li>
<li>keep-alive 的实现原理是什么</li>
</ul>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>keep-alive 组件是 vue 的内置组件，用于缓存内部组件实例。这样做的目的在于，keep-alive 内部的组件切回时，不用重新创建组件实例，而直接使用缓存中的实例，<strong>一方面能够避免创建组件带来的开销，另一方面可以保留组件的状态。</strong></p>
<p>keep-alive 核心原理就是将切换走的页面的虚拟 dom 保存在内存中，下次回来的时候还是继续使用保存在内存中的数据</p>
<h4 id="常用属性与生命周期"><a href="#常用属性与生命周期" class="headerlink" title="常用属性与生命周期"></a>常用属性与生命周期</h4><p>include 和 exclude 属性：通过它们可以控制哪些组件进入缓存。</p>
<p>max 属性：通过它可以设置最大缓存数，当缓存的实例超过该数时，vue 会移除最久没有使用的组件缓存。</p>
<p>两个生命周期钩子函数：分别是 activated 和 deactivated，它们分别在组件激活和失活时触发。第一次 activated 触发是在 mounted 之后</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>keep-alive 在内部维护了一个 key 数组和一个缓存对象</p>
<pre><code class="javascript">// keep-alive 内部的声明周期函数
created () &#123;
  this.cache = &#123;
    key(缓存组件id)：组件的虚拟DOM
  &#125;
&#125;
</code></pre>
<p>key 数组记录目前缓存的组件 key 值，如果组件没有指定 key 值，则会为其自动生成一个唯一的 key 值</p>
<p>cache 对象以 key 值为键，vnode 为值，用于缓存组件对应的虚拟 DOM</p>
<p>在 keep-alive 的渲染函数中，其基本逻辑是判断当前渲染的 vnode 是否有对应的缓存，如果有，从缓存中读取到对应的组件实例；如果没有则将其缓存。</p>
<p>他会把虚拟 dom 缓存在内存，当切换过来的时候就直接渲染</p>
<p>当缓存数量超过 max 数值时，keep-alive 会移除掉 key 数组的第一个元素。</p>
<h3 id="讲讲-computed"><a href="#讲讲-computed" class="headerlink" title="讲讲 computed"></a><strong>讲讲 computed</strong></h3><p>是什么</p>
<p>computed 是一种计算属性，来描述依赖响应式状态的复杂逻辑，并且具有缓存机制。</p>
<p>为计算属性创建的函数不会立即执行，如果没有使用，就不会得到执行</p>
<p>计算属性的 setter，则极其简单，当设置计算属性时，直接运行 setter 即可。</p>
<p>原理</p>
<p>在内部 effect 源码中会使用两个关键属性来实现缓存，一个是 value，一个是 dirty</p>
<p>value 属性用于保存 Watcher 运行的结果，受 lazy 的影响，该值在最开始是 undefined</p>
<p>dirty 属性用于指示当前的 value 是否已经过时了，即是否为脏值，受 lazy 的影响，该值在最开始是 true</p>
<p>应用</p>
<p>对 prop 传入数据的两次计算</p>
<p>计算商品总价</p>
<p>数据格式化或者映射</p>
<blockquote>
<p>副作用操作：</p>
<p>调用系统 I/O 的 API</p>
<p>发送网络请求</p>
<p>在函数体内修改外部变量的值</p>
<p>使用 console.log 等方法进行输出</p>
<p>调用存在副作用的函数</p>
</blockquote>
<h3 id="watch-与-computed-的区别是什么？以及他们的使用场景分别是什么？"><a href="#watch-与-computed-的区别是什么？以及他们的使用场景分别是什么？" class="headerlink" title="watch 与 computed 的区别是什么？以及他们的使用场景分别是什么？"></a><strong>watch 与 computed 的区别是什么？以及他们的使用场景分别是什么？</strong></h3><p>相同点：</p>
<ol>
<li>都是观察数据变化的</li>
</ol>
<p>区别点：</p>
<ol>
<li>watch 没有缓存；computed 有缓存，它依赖的值变了才会重新计算</li>
<li>watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）</li>
<li>watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；</li>
<li>计算属性是在依赖的数据发生变化的时候，重新做二次计算，不会涉及到副作用的操作(无副作用)；侦听器在依赖的数据发生变化的时候，允许做一些副作用的操作，例如更改 DOM、发送异步请求（有副作用）</li>
</ol>
<p>watch 的参数：</p>
<ul>
<li>deep：深度监听</li>
<li>immediate ：组件加载立即触发回调函数执行</li>
</ul>
<blockquote>
<p>这两个东西一个是用于计算的，一个是用于监听响应式的值</p>
</blockquote>
<p>关于 computed 中书写异步代码的问题：</p>
<p>其实无论是 watch,computed 还是 watchEffect 在 vue 内部都是使用一个 effect 函数，他里面创建数据和函数的关联是同步的，所以他根本无法读取到响应式数据。所以不能使用，如果一定要使用，可以在异步代码之前先使用一下响应式数据，让 effect 函数获取到。</p>
<p>应用：</p>
<p>watch:打开详情页切换 id 发送网络请求。</p>
<p>computed:二次计算</p>
<h3 id="computed-和-methods-的区别是什么？"><a href="#computed-和-methods-的区别是什么？" class="headerlink" title="computed 和 methods 的区别是什么？"></a><strong>computed 和 methods 的区别是什么？</strong></h3><ol>
<li>computed 当做属性使用，而 methods 则当做方法调用</li>
<li>computed 可以具有 getter 和 setter，因此可以赋值，而 methods 不行</li>
<li>computed 具有缓存，而 methods 没有</li>
</ol>
<h3 id="watch-与-watchEffect-的区别"><a href="#watch-与-watchEffect-的区别" class="headerlink" title="watch 与 watchEffect 的区别"></a>watch 与 watchEffect 的区别</h3><p>watchEffect 的回调函数一开始就执行，watch 的回调函数不会执行（除非配置 immediate: true）</p>
<p>watchEffect 数据改变，没有旧值参考，watch 有旧值与新值</p>
<p>watchEffect 监控的都是一些回调函数中用到的数据，watch 可以在回调执行与响应式无关的代码</p>
<h3 id="讲讲-scoped"><a href="#讲讲-scoped" class="headerlink" title="讲讲 scoped"></a><strong>讲讲 scoped</strong></h3><p>在 vue 文件中的 style 标签上，有一个特殊的属性：scoped。当一个 style 标签拥有 scoped 属性时，它的 CSS 样式就只能作用于当前的组件，也就是说，该样式只能适用于当前组件元素。通过该属性，可以使得组件之间的样式不互相污染。如果一个项目中的所有 style 标签全部加上了 scoped，相当于实现了样式的模块化。</p>
<p><strong>scoped**</strong> 的实现原理**</p>
<p>vue 中的 scoped 属性的效果主要通过 PostCSS 转译实现的。PostCSS 给一个组件中的所有 DOM 添加了一个独一无二的动态属性，然后，给 CSS 选择器额外添加一个对应的属性选择器来选择该组件中 DOM，这种做法使得样式只作用于含有该属性的 DOM，即组件内部 DOM。</p>
<p>例如：</p>
<p>转译前</p>
<pre><code class="plain">&lt;template&gt;
  &lt;div class=&quot;example&quot;&gt;hi&lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
.example &#123;
  color: red;
&#125;
&lt;/style&gt;
</code></pre>
<p>转译后：</p>
<pre><code class="plain">&lt;template&gt;
  &lt;div class=&quot;example&quot; data-v-5558831a&gt;hi&lt;/div&gt;
&lt;/template&gt;

&lt;style&gt;
.example[data-v-5558831a] &#123;
  color: red;
&#125;
&lt;/style&gt;
</code></pre>
<p><strong>scoped 样式穿透</strong></p>
<p>首先说一下什么场景下需要 scoped 样式穿透。</p>
<p>在很多项目中，会出现这么一种情况，即：引用了第三方组件，需要在组件中局部修改第三方组件的样式，而又不想去除 scoped 属性造成组件之间的样式污染。此时只能通过特殊的方式，穿透 scoped。</p>
<p>使用:deep()可以穿透的原理是在内部会创建全局 CSS 规则，但这个全局 css 规则只会在.common-image 之内生效。</p>
<p><font style="color:rgb(17, 17, 17);">未使用:deep</font></p>
<pre><code class="typescript">.my-input&#123;
  width: 300px;
  .el-input__wrapper&#123;
    width: 20px;
  &#125;
&#125;
</code></pre>
<p><img src="1733468410385-0a11fdde-f9f2-40b1-a048-3e74133861d3.png"></p>
<p><font style="color:rgb(17, 17, 17);">使用 deep</font></p>
<pre><code class="typescript">.my-input&#123;
  width: 300px;
  :deep(.el-input)&#123;
    .el-input__wrapper&#123;
      width: 20px;
    &#125;
  &#125;
&#125;
</code></pre>
<p><img src="1733468449788-c29e9624-0723-42ab-a272-555cccc16911.png"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="讲讲插槽"><a href="#讲讲插槽" class="headerlink" title="讲讲插槽"></a>讲讲插槽</h3><p>插槽的使用</p>
<p>子组件：通过 slot 来设置插槽</p>
<p>父组件：使用子组件时可以使用&lt;template #xxx&gt;语法去编写内容</p>
<p>插槽种类：</p>
<p>默认插槽：拥有默认的一些内容</p>
<p>具名插槽：给你的插槽取一个名字</p>
<p>作用域插槽：数据来自于子组件，通过插槽的形式传递给父组件使用</p>
<p>插槽本质：父组件向子组件传递模板内容</p>
<p>父组件向子组件传递过去的东西本质上是函数，通过调用这些函数，能够得到对应结构的虚拟 DOM.</p>
<p>子组件设置插槽的本质</p>
<p>其实就是对父组件传递过来的函数进行调用，得到对应的虚拟 DOM.</p>
<p>当父组件向子组件去传递插槽的时候，实际上传递的是一个对象；每传一个插槽，就相等于是传了一个 key/value(key 是插槽名，value 是一个 render 函数)，调用可以得到虚拟 dom</p>
<pre><code class="javascript">&#123;
  default: function()&#123; 虚拟dom &#125;,
  xxx: function()&#123; 虚拟dom &#125;,
  xxx: function()&#123; 虚拟dom &#125;,
&#125;
</code></pre>
<p><img src="1725435165565-577b95ae-4221-4415-9d78-ed909fcc0739.png"></p>
<p>作用域插槽</p>
<p>在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。要做到这一点，我们需要一种方法来让子组件在渲染时将一部分数据提供给插槽。</p>
<pre><code class="plain">&lt;!-- &lt;MyComponent&gt; 的模板 --&gt;
&lt;div&gt;
  &lt;slot :text=&quot;greetingMessage&quot; :count=&quot;1&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;
</code></pre>
<p><font style="color:rgb(33, 53, 71);">当需要接收插槽 props 时，默认插槽和具名插槽的使用方式有一些小区别。下面我们将先展示默认插槽如何接受 props，通过子组件标签上的 </font>v-slot<font style="color:rgb(33, 53, 71);"> 指令，直接接收到了一个插槽 props 对象：</font></p>
<pre><code class="plain">&lt;MyComponent v-slot=&quot;slotProps&quot;&gt;
  &#123;&#123; slotProps.text &#125;&#125; &#123;&#123; slotProps.count &#125;&#125;
&lt;/MyComponent&gt;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2024/svg/22718987/1707197205348-ed185c74-7343-4b4d-ac13-d51d698d8feb.svg"></p>
<p>插槽与作用域插槽</p>
<p>插槽的作用是子组件提供了可替换模板，父组件可以更换模板的内容。</p>
<p>作用域插槽给了子组件将数据返给父组件的能力，子组件一样可以复用，同时父组件也可以重新组织内容和样式。</p>
<h3 id="讲讲-nextTick"><a href="#讲讲-nextTick" class="headerlink" title="讲讲 nextTick"></a>讲讲 nextTick</h3><p>vue 是采用异步渲染的</p>
<p>因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，非常影响性能；所以为了性能考虑，Vue 会在本轮数据更新后，再去异步更新视图。</p>
<blockquote>
<p>同步代码执行完后，nextTick（flushSchedulerQueue）进行批量更新操作</p>
</blockquote>
<p>作用：vue 更新 DOM 是异步更新的，数据变化，DOM 的更新不会马上完成；所以 nextTick 提供了回调，在这个函数中，可以拿到视图更新过后的数据</p>
<p>实现原理</p>
<p>nextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用</p>
<ul>
<li>Promise：可以将函数延迟到当前函数调用栈最末端</li>
<li>MutationObserver ：是 H5 新加的一个功能，其功能是监听 DOM 节点的变动，在所有 DOM 变动完成后，执行回调函数</li>
<li>setImmediate：用于中断长时间运行的操作，并在浏览器完成其他操作（如事件和显示更新）后立即运行回调函数</li>
<li>如果以上都不行则采用 setTimeout 把函数延迟到 DOM 更新之后再使用</li>
</ul>
<h3 id="Vue-的路由实现"><a href="#Vue-的路由实现" class="headerlink" title="Vue 的路由实现"></a><strong>Vue 的路由实现</strong></h3><p><strong>解释 **<strong>hash*</strong>* 模式和 **<strong>history*</strong>* 模式的实现原理</strong></p>
<p>hash 模式的实现：hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面；通过监听 hashchange 事件可以知道 hash 发生了哪些变化，然后根据 hash 变化来实现更新页面部分内容的操作。</p>
<p>history 模式的实现：主要是 HTML5 标准发布的两个 API，pushState 和 replaceState，这两个 API 可以在改变 URL，但是不会发送请求。这样就可以监听 url 变化来实现更新页面部分内容的操作。</p>
<p>两种模式的区别：</p>
<ul>
<li>首先是在 URL 的展示上，hash 模式有“#”，history 模式没有</li>
<li>刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由</li>
<li>在兼容性上，hash 可以支持低版本浏览器和 IE</li>
</ul>
<p><strong>说一下 router （useRouter）与 route （useRoute）的区别</strong></p>
<p>router 对象是全局路由的实例</p>
<blockquote>
<p>router 对象常用的方法有：</p>
<ul>
<li>push：向 history 栈添加一个新的记录</li>
<li>go：页面路由跳转前进或者后退</li>
<li>replace：替换当前的页面，不会向 history 栈添加一个新的记录</li>
<li>beforeEach ：组件路由守卫</li>
</ul>
</blockquote>
<p>route 对象表示当前的路由信息，包含了当前 URL 解析得到的信息。</p>
<blockquote>
<p>route.path：字符串，对应当前路由的路径，总是解析为绝对路径，如 “/foo/bar”。</p>
<p>route.params： 一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。</p>
<p>route.query：一个 key/value 对象，表示 URL 查询参数。例如对于路径 /foo?user=1，则有 route.query.user == 1，如果没有查询参数，则是个空对象。</p>
<p>route.hash：当前路由的 hash 值 (不带 #) ，如果没有 hash 值，则为空字符串。</p>
<p>route.fullPath：完成解析后的 URL，包含查询参数和 hash 的完整路径。</p>
<p>route.matched：数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。</p>
<p>route.name：当前路径名字</p>
<p>route.meta：路由元信息</p>
</blockquote>
<p><strong>vueRouter 有哪几种导航守卫？</strong></p>
<ul>
<li>全局前置/钩子：beforeEach、<font style="color:rgb(0, 0, 0);">beforeResolve</font>、afterEach</li>
<li>路由独享的守卫：beforeEnter（自定义在路由上）</li>
<li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate（路由参数发生变化时）、beforeRouteLeave</li>
</ul>
<blockquote>
<p>to:跳转路由后的信息</p>
<p>from:从哪里来的信息</p>
<p>next:调用 next()方法可跳转路由</p>
</blockquote>
<p><strong>解释一下 **<strong>vueRouter*</strong>* 的完整的导航解析流程是什么</strong></p>
<p>一次完整的导航解析流程如下：</p>
<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。（beforeRouteLeave）</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ol>
<blockquote>
<p><code>beforeResolve</code><font style="color:rgba(0, 0, 0, 0.85);">守卫是一种全局路由守卫。它在</font><code>beforeRouteEnter</code><font style="color:rgba(0, 0, 0, 0.85);">（组件内进入守卫）之后、</font><code>afterEach</code><font style="color:rgba(0, 0, 0, 0.85);">（全局后置守卫）之前被触发</font></p>
</blockquote>
<p><font style="color:rgba(0, 0, 0, 0.85);"></font></p>
<p>原理源码：</p>
<p>1.根据用户的设置监听 hash 或者是 pushState（replaceState）</p>
<p>2.要根据完整的路由对象中去找到当前路由选中的组件</p>
<p>3.要提供一些守卫函数（beforeEach）（本质是注册一些钩子函数），路由对象的修改方法</p>
<p>4.要设计<router-link>（a 标签跳转）和<router-view>（本质就是一个插槽）确定渲染的位置</p>
<h3 id="讲讲-pinia-与直接使用-reactive-的区别"><a href="#讲讲-pinia-与直接使用-reactive-的区别" class="headerlink" title="讲讲 pinia 与直接使用 reactive 的区别"></a>讲讲 pinia 与直接使用 reactive 的区别</h3><p>Pinia 是经过了完善的测试的，会给你带来很多附加的价值，例如：</p>
<p>开发工具支持（调试工具）</p>
<p>插件机制</p>
<p>而且相比一个单纯的响应式数据，Pinia 语义上面也会更好一些：</p>
<p>一个单独抽出来的 reactive 对象，从语义上来讲可能是任何东西</p>
<p>一个 Pinia 对象，从语义上来讲就是全局共享数据的仓库</p>
<p>这样其实也能一定程度的降低开发者的心智负担，提高代码的可读性。</p>
<h3 id="讲讲动态组件"><a href="#讲讲动态组件" class="headerlink" title="讲讲动态组件"></a>讲讲动态组件</h3><pre><code class="javascript">&lt;component :is=&quot;component&quot; :option=&quot;option&quot; :paths=&quot;currentPaths&quot;&lt;/component&gt;

component是一个组件对象，可以到达修改这个值而改变页面组件的显示
</code></pre>
<h3 id="讲讲异步组件"><a href="#讲讲异步组件" class="headerlink" title="讲讲异步组件"></a>讲讲异步组件</h3><p>懒加载就是异步组件的方式</p>
<pre><code class="javascript">import &#123; defineAsyncComponent &#125; from &#39;vue&#39;

// 之后就可以像使用普通组件一样，使用 AsyncCom 这个异步组件
const AsyncCom = defineAsyncComponent(()=&gt;&#123;
  // 这是一个工厂函数，该工厂函数一般返回一个 Promise
  return new Promise((resolve, reject)=&gt;&#123;
    resolve(/* 获取到的组件 */)
  &#125;)
&#125;)

&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;button @click=&quot;loadComponent(&#39;Home&#39;)&quot;&gt;访问主页&lt;/button&gt;
    &lt;button @click=&quot;loadComponent(&#39;About&#39;)&quot;&gt;访问关于&lt;/button&gt;
    &lt;component :is=&quot;currentComponent&quot; v-if=&quot;currentComponent&quot;&gt;&lt;/component&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import &#123; shallowRef, defineAsyncComponent &#125; from &#39;vue&#39;
// import Home from &#39;./components/Home.vue&#39;
// import About from &#39;./components/About.vue&#39;

const currentComponent = shallowRef(null)
/**
 *
 * @param name 组件名
 */
const loadComponent = (name) =&gt; &#123;
  currentComponent.value = defineAsyncComponent(() =&gt; import(`./components/$&#123;name&#125;.vue`))
&#125;
&lt;/script&gt;
</code></pre>
<p>配置项</p>
<pre><code class="javascript">const AsyncComp = defineAsyncComponent(&#123;
  // 加载函数
  loader: () =&gt; import(&quot;./Foo.vue&quot;),

  // 加载异步组件时使用的组件
  // 如果提供了一个加载组件，它将在内部组件加载时先行显示。
  loadingComponent: LoadingComponent,
  // 展示加载组件前的延迟时间，默认为200ms
  // 在网络状况较好时，加载完成得很快，加载组件和最终组件之间的替换太快可能产生闪烁，反而影响用户感受。
  // 通过延迟来解决闪烁问题
  delay: 200,
  // 加载失败后展示的组件
  // 如果提供了一个报错组件，则它会在加载器函数返回的 Promise 抛错时被渲染。
  errorComponent: ErrorComponent,
  // 你还可以指定一个超时时间，在请求耗时超过指定时间时也会渲染报错组件。
  // 默认值是：Infinity
  timeout: 3000,
&#125;);
</code></pre>
<h3 id="讲讲-setup"><a href="#讲讲-setup" class="headerlink" title="讲讲 setup"></a>讲讲 setup</h3><p>1.简化书写：在传统的 setup 函数中，我们需要返回一个对象，其中包含需要在模板中使用的变量和方法。在 <script setup> 中，这一步被省略了，所有定义的变量和方法会自动暴露给模板使用，从而减少了样板代码。</p>
<p>2.更好的类型推断：在 <script setup> 中所有定义的内容都是顶层变量，TypeScript 的类型推断更加直观和简单。</p>
<p>3.可以使用 defineExpose 暴露指定的成员</p>
<p>4.setup 中定义了许多的宏 defineProps，defineEmits</p>
<h3 id="讲讲指令，自定义指令"><a href="#讲讲指令，自定义指令" class="headerlink" title="讲讲指令，自定义指令"></a>讲讲指令，自定义指令</h3><p>vue2 的自定义指令钩子函数</p>
<p>自定义指令的生命周期，有 5 个事件钩子，可以设置指令在某一个事件发生时的具体行为：</p>
<ul>
<li>bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</li>
<li>inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li>
<li>update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。</li>
<li>componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。</li>
<li>unbind: 只调用一次， 指令与元素解绑时调用。</li>
</ul>
<p>vue3 的自定义指令钩子函数</p>
<p><code>beforeMount</code></p>
<p><code>mounted</code></p>
<p><code>beforeUpdate</code></p>
<p><code>updated</code></p>
<p><code>beforeUnmount</code></p>
<p>钩子函数的参数 (包括 el，binding，vnode，oldVnode)</p>
<ul>
<li>el: 指令所绑定的元素，可以用来直接操作 DOM 。</li>
<li>binding: 一个对象，包含以下属性：name: 指令名、value: 指令的绑定值、oldValue: 指令绑定的前一个值、expression: 绑定值的字符串形式、arg: 传给指令的参数、modifiers: 一个包含修饰符的对象。</li>
<li>vnode: Vue 编译生成的虚拟节点。</li>
<li>oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li>
</ul>
<p>指令的本质：</p>
<p>比如使用 v-if 就是在生成虚拟 dom 之前加上三目运算符去判断</p>
<p>自定义指令那么就把需要做什么的事情的权限交给你</p>
<h2 id="vue-常见问题"><a href="#vue-常见问题" class="headerlink" title="vue 常见问题"></a>vue 常见问题</h2><h3 id="ref-与-reactive-的区别"><a href="#ref-与-reactive-的区别" class="headerlink" title="ref 与 reactive 的区别"></a>ref 与 reactive 的区别</h3><p>首先这两个 api 都是创建一个响应式的数据</p>
<p>其实 vue 的响应式系统内部都是基本靠 reactive 来完成的</p>
<p>区别</p>
<ol>
<li>ref 可以是任何值，reactive 响应式的对象不能是简单值</li>
<li>ref 在模板都会自动解包，但在 script 如果要访问值都必须要用.value 的方式访问</li>
</ol>
<p>原理</p>
<p>ref 和 reactive 在源码中都是一个类</p>
<p>ref 类中会设置 get 和 set，如果 ref 的值是一个引用类型（对象），那么他依然会交给 reactive 去处理，否则的话就利用 get 和 set 方法去收集依赖与派发更新</p>
<p>响应式系统本质来说就是响应式数据和函数之间的依赖，数据一变，函数重新运行</p>
<h3 id="v-if-与-v-show-的区别"><a href="#v-if-与-v-show-的区别" class="headerlink" title="v-if 与 v-show 的区别"></a><strong>v-if 与 v-show 的区别</strong></h3><p>共同点：都是动态显示隐藏 DOM 元素</p>
<p>区别点:</p>
<ol>
<li>v-if 是动态的向 DOM 树内添加或者删除 DOM 元素；v-show 是通过设置 DOM 元素的 display 样式属性控制显隐</li>
<li>编译过程 v-if 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show 只是简单的基于 css 切换</li>
<li>编译条件 v-if 是惰性的，如果初始条件为假，则什么也不做。只有在条件第一次变为真时才开始局部编译；v-show 是在任何条件下(首次条件是否为真)都被编译，然后被缓存，而且 DOM 元素保留</li>
<li>性能消耗 v-if 有更高的切换消耗；v-show 有更高的初始渲染消耗</li>
<li>使用场景 v-if 适合条件不大可能改变；v-show 适合频繁切换</li>
</ol>
<h3 id="vue-文件到底是什么，是如何解析与渲染的（开发环境）"><a href="#vue-文件到底是什么，是如何解析与渲染的（开发环境）" class="headerlink" title=".vue 文件到底是什么，是如何解析与渲染的（开发环境）"></a>.vue 文件到底是什么，是如何解析与渲染的（开发环境）</h3><p>一个.vue 文件，经过编译以后本质就是一个对象，template 模板最终会被渲染成一个 render 函数，而且这一步是在编译启动的时候就已经完成了。</p>
<p>当解析到路由的时候，会去请求.vue 文件，利用 compilerSfc 把他解析成 js 运行，同时再发一个带 type=style 的请求去解析 css 把他插入到 head 中</p>
<blockquote>
<p>生产环境直接就被打包成了静态 css,js,html</p>
</blockquote>
<h3 id="什么是-hooks"><a href="#什么是-hooks" class="headerlink" title="什么是 hooks"></a>什么是 hooks</h3><p>响应式的数据和逻辑可以复用</p>
<p>纯数据可以封装成 hooks（凡是不涉及界面的逻辑都可以提出去，变成函数）</p>
<h3 id="组件中写-name-选项有哪些好处"><a href="#组件中写-name-选项有哪些好处" class="headerlink" title="组件中写 name 选项有哪些好处"></a>组件中写 name 选项有哪些好处</h3><ol>
<li>可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）</li>
<li>可以通过 name 属性实现缓存功能（keep-alive）</li>
<li>可以通过 name 来识别组件（跨级组件通信时非常重要）</li>
<li>使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的</li>
</ol>
<h3 id="v-if-和-v-for-不要同时使用"><a href="#v-if-和-v-for-不要同时使用" class="headerlink" title="v-if 和 v-for 不要同时使用"></a>v-if 和 v-for 不要同时使用</h3><p>1.使用 computed 属性代替 v-if</p>
<p>2.先试用 v-for，内部使用 template 标签包一层</p>
<h3 id="开发过程中，如何进行公共组件的设计？"><a href="#开发过程中，如何进行公共组件的设计？" class="headerlink" title="开发过程中，如何进行公共组件的设计？"></a>开发过程中，如何进行公共组件的设计？</h3><p>确定组件的使用边界在哪，通用到什么程度（这会影响到这个组件的开发难度），设计组件功能根据其使用场景，设计出组件的属性、事件、使用说明文档，测试用例根据使用说明文档编写组件测试用例</p>
<p>要设计出来以后，尽量不耦合使用者的场景，而且尽量要使得调用者更加方便</p>
<h3 id="vue2-的-forceUpdate-是用来干嘛的，vue3-用什么"><a href="#vue2-的-forceUpdate-是用来干嘛的，vue3-用什么" class="headerlink" title="vue2 的$forceUpdate 是用来干嘛的，vue3 用什么?"></a>vue2 的$forceUpdate 是用来干嘛的，vue3 用什么?</h3><p>$forceUpdate 是用来强制更新界面的</p>
<p>但 vue3 不需要，因为响应式数据可以全方位监听到,vue2 只监听 get 与 set 可能出现数据变化但页面不更新的情况(举个例子)</p>
<h3 id="vue3-模板中的-ref-实现原理"><a href="#vue3-模板中的-ref-实现原理" class="headerlink" title="vue3 模板中的 ref 实现原理"></a>vue3 模板中的 ref 实现原理</h3><p>模板-&gt;预编译-&gt;render 函数-&gt;虚拟节点-&gt;diff-&gt;挂载或更新-&gt;渲染器(renderrer)-&gt;生成元素-&gt;把 ref 赋值给真实 dom</p>
<h3 id="如何监听-pushstate-和-replacestate-的变化呢？"><a href="#如何监听-pushstate-和-replacestate-的变化呢？" class="headerlink" title="如何监听 pushstate 和 replacestate 的变化呢？"></a><strong>如何监听 pushstate 和 replacestate 的变化呢？</strong></h3><p>History.replaceState 和 History.pushState 不会触发 pushState 和 popstate 事件，<font style="color:rgb(77, 77, 77);">浏览器也没有提供直接的事件来监听 </font><code>&lt;font style=&quot;color:rgb(77, 77, 77);&quot;&gt;pushState&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);"> 和 </font><code>&lt;font style=&quot;color:rgb(77, 77, 77);&quot;&gt;replaceState&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);"> 的变化</font>，所以我们可以通过在方法中创建一个新的全局事件来实现 pushstate 和 replacestate 变化的监听。</p>
<p>具体做法为：</p>
<pre><code class="javascript">function _wr(type) &#123;
  let orig = history[type];
  return function () &#123;
    //先保证原始代码执行
    let rv = orig.apply(this, arguments);

    //注册监听事件
    let e = new Event(type);
    e.arguments = arguments;
    window.dispatchEvent(e);

    //返回原始代码执行
    return rv;
  &#125;;
&#125;
history.pushState = _wr(&quot;pushState&quot;);
history.replaceState = _wr(&quot;replaceState&quot;);
</code></pre>
<p>这样就创建了 2 个全新的事件，事件名为 pushState 和 replaceState，我们就可以在全局监听：</p>
<pre><code class="javascript">window.addEventListener(&quot;replaceState&quot;, function (e) &#123;
  console.log(&quot;THEY DID IT AGAIN! replaceState 111111&quot;);
&#125;);
window.addEventListener(&quot;pushState&quot;, function (e) &#123;
  console.log(&quot;THEY DID IT AGAIN! pushState 2222222&quot;);
&#125;);
</code></pre>
<p>这样就可以监听到 pushState 和 replaceState 行为。</p>
<h3 id="讲讲组件通信"><a href="#讲讲组件通信" class="headerlink" title="讲讲组件通信"></a><strong>讲讲组件通信</strong></h3><p>父组件与子组件传值实现过程</p>
<ul>
<li>父组件传给子组件：子组件通过 props 方法接受数据</li>
<li>子组件传给父组件：使用自定义事件，组件通过 emit 方法触发父组件的方法来传递参数</li>
</ul>
<p>总结 vue 中的组件通信方式，常见使用场景可以分为三类：</p>
<ul>
<li>父子通信：<ul>
<li>父向子传递数据是通过 props ，子向父是通过 emit / on(v-model)</li>
<li>pinia</li>
<li>ref 也可以访问组件实例</li>
<li>路由传递</li>
<li>插槽传递</li>
</ul>
</li>
<li>兄弟通信：<ul>
<li>pinia</li>
</ul>
</li>
<li>跨级通信：<ul>
<li>provide / inject</li>
<li>pinia</li>
</ul>
</li>
</ul>
<h3 id="v-on-可以实现监听多个方法么？"><a href="#v-on-可以实现监听多个方法么？" class="headerlink" title="v-on 可以实现监听多个方法么？"></a><strong>v-on 可以实现监听多个方法么？</strong></h3><p>可以监听多个方法。关于监听多个方法提供了几种不同的写法：</p>
<pre><code class="html">写法一：
&lt;div v-on=&quot;&#123; 事件类型: 事件处理函数, 事件类型: 事件处理函数 &#125;&quot;&gt;&lt;/div&gt;
写法二：
&lt;div @事件类型=&quot;“事件处理函数”&quot; @事件类型=&quot;“事件处理函数”&quot;&gt;&lt;/div&gt;
写法三：在一个事件里面书写多个事件处理函数
&lt;div @事件类型=&quot;“事件处理函数1，事件处理函数2”&quot;&gt;&lt;/div&gt;
写法四：在事件处理函数内部调用其他的函数
</code></pre>
<h3 id="说一下你知道的-vue-修饰符都有哪些？"><a href="#说一下你知道的-vue-修饰符都有哪些？" class="headerlink" title="说一下你知道的 vue 修饰符都有哪些？"></a><strong>说一下你知道的 vue 修饰符都有哪些？</strong></h3><p>在 vue 中修饰符可以分为 3 类：</p>
<ul>
<li>事件修饰符</li>
<li>按键修饰符</li>
<li>表单修饰符</li>
</ul>
<p><strong>事件修饰符</strong></p>
<p>在事件处理程序中调用 event.preventDefault 或 event.stopPropagation 方法是非常常见的需求。尽管可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>
<p>为了解决这个问题，vue 为 v-on 提供了事件修饰符。通过由点 . 表示的指令后缀来调用修饰符。</p>
<p>常见的事件修饰符如下：</p>
<ul>
<li>.stop：阻止冒泡。</li>
<li>.prevent：阻止默认事件。</li>
<li>.capture：使用事件捕获模式。</li>
<li>.self：只在当前元素本身触发。</li>
<li>.once：只触发一次。</li>
<li>.passive：默认行为将会立即触发。</li>
</ul>
<p><strong>按键修饰符</strong></p>
<p>除了事件修饰符以外，在 vue 中还提供了有鼠标修饰符，键值修饰符，系统修饰符等功能。</p>
<ul>
<li>.left：左键</li>
<li>.right：右键</li>
<li>.middle：滚轮</li>
<li>.enter：回车</li>
<li>.tab：制表键</li>
<li>.delete：捕获 “删除” 和 “退格” 键</li>
<li>.esc：返回</li>
<li>.space：空格</li>
<li>.up：上</li>
<li>.down：下</li>
<li>.left：左</li>
<li>.right：右</li>
<li>.ctrl：ctrl 键</li>
<li>.alt：alt 键</li>
<li>.shift：shift 键</li>
<li>.meta：meta 键</li>
</ul>
<p><strong>表单修饰符</strong></p>
<p>vue 同样也为表单控件也提供了修饰符，常见的有 .lazy、.number 和 .trim。</p>
<ul>
<li>.lazy：在文本框失去焦点时才会渲染</li>
<li>.number：将文本框中所输入的内容转换为 number 类型</li>
<li>.trim：可以自动过滤输入首尾的空格</li>
</ul>
<h3 id="讲讲-transition-组件"><a href="#讲讲-transition-组件" class="headerlink" title="讲讲 transition 组件"></a>讲讲 transition 组件</h3><p>使用 Transition，它会自动的控制一组特定样式类的挂载和移除，这样的话模板就会清爽很多。但是对应的样式类还是要自己来写，因为 Vue 无法预知你要如何进入和离开，它只负责在特定时间挂载和移除样式类。</p>
<p>Transition 样式类有 6 个，分别对应两大阶段：</p>
<p>进入</p>
<p>v-enter-from</p>
<p>v-enter-to</p>
<p>v-enter-active</p>
<p>离开</p>
<p>v-leave-from</p>
<p>v-leave-to</p>
<p>v-leave-active</p>
<p>TransitionGroup 仍然是 Vue 里面一个内置的组件。作用：用于解决多个元素的过渡问题。</p>
<p>相关细节</p>
<p>TransitionGroup 可以看作是 Transition 的一个升级版，它支持和 Transition 基本相同的 props、CSS 过渡 class 和 JavaScript 钩子监听器，但有以下几点区别：</p>
<p>默认情况下，它不会渲染一个容器元素。但可以通过传入 tag prop 来指定一个元素作为容器元素来渲染。</p>
<p>过渡模式 mode 在这里不可用，因为不再是在互斥的元素之间进行切换。</p>
<p>列表中的每个元素都必须有一个独一无二的 key attribute。</p>
<p>CSS 过渡 class 会被应用在列表内的元素上，而不是容器元素上。</p>
<h2 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h2><h3 id="首屏优化解决方案"><a href="#首屏优化解决方案" class="headerlink" title="首屏优化解决方案"></a>首屏优化解决方案</h3><p>首屏优化分为两个问题：</p>
<p>渲染问题</p>
<p>打包体积过大巨型包需要消耗大量的传输时间，导致 JS 传输完成前页面只有一个<code>&lt;div&gt;</code>，没有可显示的内容</p>
<p>网络传输问题</p>
<p>需要立即渲染的内容太多 JS 传输完成后，浏览器开始执行 JS 构造页面。但可能一开始要渲染的组件太多，不仅 JS 执行的时间很长，而且执行完后浏览器要渲染的元素过多，从而导致页面白屏</p>
<p>解决方案</p>
<p><strong>延迟装载组件</strong>，让组件按照指定的先后顺序依次一个一个渲染出来。本质上是利用<code>requestAnimationFrame</code>事件分批渲染内容</p>
<h3 id="如何实现-vue-项目中的性能优化？"><a href="#如何实现-vue-项目中的性能优化？" class="headerlink" title="如何实现 vue 项目中的性能优化？"></a><strong>如何实现 vue 项目中的性能优化？</strong></h3><p><strong>编码阶段</strong></p>
<ul>
<li>使用计算属性缓存</li>
<li>采用 keep-alive 缓存组件</li>
<li>使用 v-if 替代 v-show（频繁切换情况下）</li>
<li>key 保证唯一</li>
<li>非实时绑定的表单项(v-lazy 或者不使用 v-model)</li>
<li>防抖、节流</li>
<li>长列表滚动到可视区域动态加载</li>
<li>图片懒加载</li>
<li>可以冻结一个只展示但不会修改的响应式对象</li>
<li>细分组件，因为当一个组件拆成 2 个的时候，当有一个组件改变的时候，可以只重新渲染一个。</li>
</ul>
<p><strong>传输优化</strong></p>
<ul>
<li>压缩代码</li>
<li>Tree Shaking/Scope Hoisting</li>
<li>多线程打包 happypack</li>
<li>splitChunks 抽离公共文件</li>
<li>使用路由懒加载、异步组件</li>
<li>利用文件指纹(hash)设置浏览器缓存</li>
<li>使用 cdn 加载第三方模块</li>
<li>开启 gzip 压缩，传输压缩过后的文件</li>
<li>服务器开启 http2</li>
</ul>
<blockquote>
<p>如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。</p>
</blockquote>
<p><strong>分析优化</strong></p>
<p>webpack-bundle-analyzer：分析打包过后的体积</p>
<p>speed-measure-webpack-plugin：分析打包的耗时</p>
<p><strong>用户体验</strong></p>
<ul>
<li>骨架屏</li>
<li>PWA</li>
</ul>
<p><strong>SEO**</strong> 优化**</p>
<ul>
<li>预渲染</li>
<li>服务端渲染 SSR</li>
</ul>
<h2 id="vue2-x"><a href="#vue2-x" class="headerlink" title="vue2.x"></a>vue2.x</h2><h3 id="vue-中相同逻辑如何进行抽离？"><a href="#vue-中相同逻辑如何进行抽离？" class="headerlink" title="vue 中相同逻辑如何进行抽离？"></a><strong>vue 中相同逻辑如何进行抽离？</strong></h3><p>可以使用 vue 里面的混入（mixin）技术。混入（mixin）提供了一种非常灵活的方式，来将 vue 中相同的业务逻辑进行抽离。</p>
<p>例如：</p>
<ul>
<li>在 data 中有很多是公用数据</li>
<li>引用封装好的组件也都是一样的</li>
<li>methods、watch、computed 中也都有大量的重复代码</li>
</ul>
<p>当然这个时候可以将所有的代码重复去写来实现功能，但是我们并不不推荐使用这种方式，无论是工作量、工作效率和后期维护来说都是不建议的，这个时候 mixin 就可以大展身手了。</p>
<p>一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。说白了就是给每个生命周期，函数等等中间加入一些公共逻辑。</p>
<p><strong>混入技术特点</strong></p>
<ul>
<li>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。</li>
<li>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。</li>
<li>值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</li>
</ul>
<p>缺点：</p>
<p>命名冲突</p>
<p>来源模糊</p>
<p>没有层级</p>
<h3 id="new-Vue之后，发生了什么？数据改变后，又发生了什么？"><a href="#new-Vue之后，发生了什么？数据改变后，又发生了什么？" class="headerlink" title="new Vue之后，发生了什么？数据改变后，又发生了什么？"></a><code>new Vue</code>之后，发生了什么？数据改变后，又发生了什么？</h3><p>创建 vue 实例和创建组件的流程基本一致</p>
<ol>
<li>首先做一些初始化的操作，主要是设置一些私有属性到实例中</li>
<li><strong>运行生命周期钩子函数</strong><code>beforeCreate</code></li>
<li>进入注入流程：处理属性、computed、methods、data、provide、inject，最后使用代理模式将它们挂载到实例中</li>
<li><strong>运行生命周期钩子函数</strong><code>created</code></li>
<li>生成<code>render</code>函数：如果有配置，直接使用配置的<code>render</code>，如果没有，使用运行时编译器，把模板编译为<code>render</code></li>
<li><strong>运行生命周期钩子函数</strong><code>beforeMount</code></li>
<li>创建一个<code>Watcher</code>，传入一个函数<code>updateComponent</code>，该函数会运行<code>render</code>，把得到的<code>vnode</code>再传入<code>_update</code>函数执行。在执行<code>render</code>函数的过程中，会收集所有依赖，将来依赖变化时会重新运行<code>updateComponent</code>函数在执行<code>_update</code>函数的过程中，触发<code>patch</code>函数，由于目前没有旧树，因此直接为当前的虚拟 dom 树的每一个普通节点生成 elm 属性，即真实 dom。如果遇到创建一个组件的 vnode，则会进入组件实例化流程，该流程和创建 vue 实例流程基本相同，最终会把创建好的组件实例挂载 vnode 的<code>componentInstance</code>属性中，以便复用。</li>
<li><strong>运行生命周期钩子函数</strong><code>mounted</code></li>
</ol>
<p>重渲染</p>
<ol>
<li>数据变化后，所有依赖该数据的<code>Watcher</code>均会重新运行，这里仅考虑<code>updateComponent</code>函数对应的<code>Watcher</code></li>
<li><code>Watcher</code>会被调度器放到<code>nextTick</code>中运行，也就是微队列中，这样是为了避免多个依赖的数据同时改变后被多次执行</li>
<li><strong>运行生命周期钩子函数</strong><code>beforeUpdate</code></li>
<li><code>updateComponent</code>函数重新执行在执行<code>render</code>函数的过程中，会去掉之前的依赖，重新收集所有依赖，将来依赖变化时会重新运行<code>updateComponent</code>函数在执行<code>_update</code>函数的过程中，触发<code>patch</code>函数。新旧两棵树进行对比。普通<code>html</code>节点的对比会导致真实节点被创建、删除、移动、更新组件节点的对比会导致组件被创建、删除、移动、更新当新组件需要创建时，进入实例化流程当旧组件需要删除时，会调用旧组件的<code>$destroy</code>方法删除组件，该方法会先触发<strong>生命周期钩子函数</strong><code>beforeDestroy</code>，然后递归调用子组件的<code>$destroy</code>方法，然后触发<strong>生命周期钩子函数</strong><code>destroyed</code>当组件属性更新时，相当于组件的<code>updateComponent</code>函数被重新触发执行，进入重渲染流程，和本节相同。</li>
<li><strong>运行生命周期钩子函数</strong><code>updated</code></li>
</ol>
<h3 id="说一下在-Vue2-x-中如何检测数组的变化？"><a href="#说一下在-Vue2-x-中如何检测数组的变化？" class="headerlink" title="说一下在 Vue2.x 中如何检测数组的变化？"></a><strong>说一下在 Vue2.x 中如何检测数组的变化？</strong></h3><p>Vue2.x 中实现检测数组变化的方法，是<strong>将数组的常用方法进行了重写</strong>。Vue 将 data 中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组 api 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p>
<p>流程:</p>
<ol>
<li>初始化传入 data 数据执行 initData</li>
<li>将数据进行观测 new Observer</li>
<li>将数组原型方法指向重写的原型</li>
<li>深度观察数组中的引用类型</li>
</ol>
<p>有两种情况无法检测到数组的变化。</p>
<ul>
<li>当利用索引直接设置一个数组项时，例如 vm.items[indexOfItem] = newValue</li>
<li>当修改数组的长度时，例如 vm.items.length = newLength</li>
</ul>
<p>不过这两种场景都有对应的解决方案。</p>
<p><strong>利用索引设置数组项的替代方案</strong></p>
<pre><code class="plain">//使用该方法进行更新视图
// vm.$set，Vue.set的一个别名
vm.$set(vm.items, indexOfItem, newValue)
</code></pre>
<p><strong>修改数组的长度的替代方案</strong></p>
<pre><code class="plain">//使用该方法进行更新视图
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
</code></pre>
<h3 id="vuex-是什么？怎么使用它？什么场景下我们会使用到-vuex"><a href="#vuex-是什么？怎么使用它？什么场景下我们会使用到-vuex" class="headerlink" title="vuex 是什么？怎么使用它？什么场景下我们会使用到 vuex"></a><strong>vuex 是什么？怎么使用它？什么场景下我们会使用到 vuex</strong></h3><p><strong>vuex 是什么</strong></p>
<p>vuex 是一个专为 Vue 应用程序开发的状态管理器，采用集中式存储管理应用的所有组件的状态。每一个 vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着应用中大部分的状态 (state)。</p>
<p>**为什么需要 ****vuex**</p>
<p>由于组件只维护自身的状态(data)，组件创建时或者路由切换时，组件会被初始化，从而导致 data 也随之销毁。</p>
<p><strong>使用方法</strong></p>
<p>在 main.js 引入 store，注入。只用来读取的状态集中放在 store 中， 改变状态的方式是提交 mutations，这是个同步的事物，异步逻辑应该封装在 action 中。</p>
<p>**什么场景下会使用到 ****vuex**</p>
<p>如果是 vue 的小型应用，那么没有必要使用 vuex，这个时候使用 vuex 反而会带来负担。组件之间的状态传递使用 props、自定义事件来传递即可。</p>
<p>但是如果涉及到 vue 的大型应用，那么就需要类似于 vuex 这样的集中管理状态的状态机来管理所有组件的状态。例如登录状态、加入购物车、音乐播放等，总之只要是开发 vue 的大型应用，都推荐使用 vuex 来管理所有组件状态。</p>
<pre><code class="javascript">  const moduleA = &#123;
       state: &#123;
           // 模块A的状态
           count: 0
       &#125;,
      getters: &#123;
           doubleCount(state) &#123;
               return state.count * 2;
           &#125;
       &#125;，
       mutations: &#123;
           incrementCount(state) &#123;
               state.count++;
           &#125;
       &#125;,
       actions: &#123;
           asyncIncrementCount(&#123; commit &#125;) &#123;
               setTimeout(() =&gt; &#123;
                   commit(&#39;incrementCount&#39;);
               &#125;, 1000);
           &#125;
       &#125;
   &#125;;
   const store = new Vuex.Store(&#123;
       modules: &#123;
           a: moduleA
       &#125;
   &#125;);


this.$store.state.a.count
getter：this.$store.getters(&#39;a/doubleCount&#39;)
mutation：this.$store.commit(&#39;a/incrementCount&#39;)
action：this.$store.dispatch(&#39;a/asyncIncrementCount&#39;)[异步]
</code></pre>
<h3 id="Vue-组件的-data-为什么必须是函数"><a href="#Vue-组件的-data-为什么必须是函数" class="headerlink" title="Vue 组件的 data 为什么必须是函数"></a><strong>Vue 组件的 data 为什么必须是函数</strong></h3><p>组件中的 data 写成一个函数，数据以函数返回值形式定义。这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果。</p>
<h3 id="Vue-中如何进行组件的使用？Vue-如何实现全局组件的注册？"><a href="#Vue-中如何进行组件的使用？Vue-如何实现全局组件的注册？" class="headerlink" title="Vue 中如何进行组件的使用？Vue 如何实现全局组件的注册？"></a><strong>Vue 中如何进行组件的使用？Vue 如何实现全局组件的注册？</strong></h3><p>要使用组件，首先需要使用 import 来引入组件，然后在 components 属性中注册组件，之后就可以在模板中使用组件了。</p>
<p>可以使用 Vue.component 方法来实现全局组件的注册。</p>
<h3 id="你的接口请求一般放在哪个生命周期中？为什么要这样做？"><a href="#你的接口请求一般放在哪个生命周期中？为什么要这样做？" class="headerlink" title="你的接口请求一般放在哪个生命周期中？为什么要这样做？"></a><strong>你的接口请求一般放在哪个生命周期中？为什么要这样做？</strong></h3><p>接口请求可以放在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p>
<p>但是推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面 loading 时间</li>
<li>SSR 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于代码的一致性</li>
<li>created 是在模板渲染成 html 前调用，即通常初始化某些属性值，然后再渲染成视图。如果在 mounted 钩子函数中请求数据可能导致页面闪屏问题</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="说一下-Vue-SSR-的实现原理"><a href="#说一下-Vue-SSR-的实现原理" class="headerlink" title="说一下 Vue SSR 的实现原理"></a><strong>说一下 Vue SSR 的实现原理</strong></h3><ul>
<li>app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还需要进行路由匹配与数据预获取。</li>
<li>webpack 为客服端打包一个 ClientBundle，为服务端打包一个 ServerBundle。</li>
<li>服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。</li>
<li>客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活（也就是转换为单页应用）。为确保混合成功，客户 端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 store 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 window.<em>INITIAL_STATE</em> 发送到客户端</li>
<li>VueSSR 的原理，主要就是通过 vue-server-renderer 把 Vue 的组件输出成一个完整 HTML，输出到客户端，到达客户端后重新展开为一个单页应用。</li>
</ul>
<h3 id="vue-如何快速定位那个组件出现性能问题的"><a href="#vue-如何快速定位那个组件出现性能问题的" class="headerlink" title="vue 如何快速定位那个组件出现性能问题的"></a><strong>vue 如何快速定位那个组件出现性能问题的</strong></h3><p>⽤ timeline ⼯具。 通过 timeline 来查看每个函数的调⽤时常，定位出哪个函数的问题，从⽽能判断哪个组件出了问题。</p>
<h3 id="既然-Vue-通过数据劫持可以精准探测数据变化，为什么还需要虚拟-DOM-进行-diff-监测差异-？"><a href="#既然-Vue-通过数据劫持可以精准探测数据变化，为什么还需要虚拟-DOM-进行-diff-监测差异-？" class="headerlink" title="既然 Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 监测差异 ？"></a><strong>既然 Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 监测差异 ？</strong></h3><p>当 Vue 程序初始化的时候就会对数据 data 进行依赖的收集，一但数据发生变化，响应式系统就会立刻得知，因此 Vue 是一开始就知道是「在哪发生变化了」</p>
<p>但是这又会产生一个问题，通常绑定一个数据就需要一个 Watcher，一但我们的绑定细粒度过高就会产生大量的 Watcher，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化，因此 Vue 的设计是选择中等细粒度的方案，在组件级别进行 push 侦测的方式，也就是那套响应式系统</p>
<h3 id="说一下你对-vue-事件绑定原理的理解？"><a href="#说一下你对-vue-事件绑定原理的理解？" class="headerlink" title="说一下你对 vue 事件绑定原理的理解？"></a><strong>说一下你对 vue 事件绑定原理的理解？</strong></h3><p>vue 中的事件绑定是有两种，一种是原生的事件绑定，另一种是组件的事件绑定。</p>
<p>原生的事件绑定在普通元素上是通过 @click 进行绑定</p>
<p>组件上是通过 @click.native 进行绑定，组件中的 nativeOn 是等价于 on 的。组件的事件绑定的 @click 是 vue 中自定义的 on 方法来实现的，必须有 emit 才可以触发。</p>
<p><strong>原生事件绑定原理</strong></p>
<p>在 runtime 下的 patch.js 中 createPatchFunction 执行了之后再赋值给 patch。</p>
<p>createPatchFunction 方法有两个参数，分别是 nodeOps 存放操作 dom 节点的方法和 modules，modules 是有两个数组拼接起来的，modules 拼接完的数组中有一个元素就是 events，事件添加就发生在这里。</p>
<p>events 元素关联的就是 events.js 文件，在 events 中有一个 updateDOMListeners 方法，在 events 文件的结尾导出了一个对象，然后对象有一个属性叫做 create，这个属性关联的就是 updateDOMListeners 方法。</p>
<p>在执行 createPatchFunction 方法时，就会将这两个参数传入，在 createPatchFunction 方法中接收了一个参数 backend，在该方法中一开始进行 backend 的解构，就是上面的 nodeOps 和 modules 参数，解构完之后进入 for 循环。</p>
<p>在 createPatchFunction 开头定义了一个 cbs 对象。for 循环遍历一个叫 hooks 的数组。hooks 是文件一开头定义的一个数组，其中包括有 create，for 循环就是在 cbs 上定义一系列和 hooks 元素相同的属性，然后键值是一个数组，然后数组内容是 modules 里面的一些内容。这时就把 events 文件中导出来的 create 属性放在了 cbs 上。</p>
<p>当我们进入首次渲染的时候，会执行到 patch 函数里面的 createElm 方法，这个方法中就会调用 invokeCreateHooks 函数，用来处理事件系统，这里就是真正准备进行原生事件绑定的入口。invokeCreateHooks 方法中，遍历了 cbs.create 数组里面的内容。然后把 cbs.create 里面的函数全部都执行一次，在 cbs.create 其中一个函数就是 updateDOMListeners。</p>
<p>updateDOMListeners 就是用来添加事件的方法，在这方法中会根据 vnode 判断是否有定义一个点击事件。如果没有点击事件就 return。有的话就继续执行，给 on 进行赋值，然后进行一些赋值操作，将 vnode.elm 赋值给 target，elm 这个属性就是指向 vnode 所对应的真实 dom 节点，这里就是把我们要绑定事件的 dom 结点进行缓存，接下来执行 updateListeners 方法。在接下来执行 updateListeners 方法中调用了一个 add 的方法，然后在 app 方法中通过原生 addEventListener 把事件绑定到 dom 上。</p>
<p><strong>组件事件绑定原理</strong></p>
<p>在组件实例初始化会调用 initMixin 方法中的 Vue.prototype._init，在 init 函数中，会通过 initInternalComponent 方法初始化组件信息，将自定义的组件事件放到_parentListeners 上，下来就会调用 initEvents 来初始化组件事件，在 initEvents 中会实例上添加一个 _event 对象，用于保存自定义事件，然后获取到 父组件给 子组件绑定的自定义事件，也就是刚才在初始化组件信息的时候将自定义的组件事件放在了_parentListeners 上，这时候 vm.$options._parentListeners 就是自定义的事件。</p>
<p>最后进行判断，如果有自定义的组件事件就执行 updateComponentListeners 方法进行事件绑定，在 updateComponentListeners 方法中会调用 updateListeners 方法，并传传一个 add 方法进行执行，这个 add 方法里就是$on 方法。</p>
<h2 id="源码层面"><a href="#源码层面" class="headerlink" title="源码层面"></a>源码层面</h2><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><h4 id="ref-源码"><a href="#ref-源码" class="headerlink" title="ref 源码"></a>ref 源码</h4><pre><code class="javascript">function Ref(rawValue, shallow = false) &#123;
  if (isRef(rawValue)) &#123;
    return rawValue;
  &#125;
  return new RefImpl(rawValue, shallow);
&#125;

class RefImpl&lt;T&gt; &#123;
  private _value: T
  private _rawValue: T

  constructor(value: T) &#123;
    this._rawValue =  toRaw(value)
    // 有可能是原始值，有可能是 reactive 返回的 proxy
    this._value =  toReactive(value)
  &#125;

  get value() &#123;
    //依赖收集
    trackRefValue(this);
    return this._value;
  &#125;

  set value(newVal) &#123;
    newVal = toReactive(newVal);
    //判断两次值是否有变化
    if (hasChanged(newVal, this._value)) &#123;
      this._value = newVal;
      //派发更新
      triggerRefValue(this, newVal);
    &#125;
  &#125;
&#125;

// 判断是否是对象，是对象就用 reactive 来处理，否则返回原始值
function toReactive(value)&#123;
  if(isObject(value))&#123;
    return reactive(value);
  &#125;
  return value
&#125;

const data = Ref(false);
</code></pre>
<h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h4><pre><code class="javascript">function createReactiveObject(
  target,
  baseHandlers,
  collectionHandlers,
  proxyMap
) &#123;
  // 创建 Proxy 代理对象
  const proxy = new Proxy(
    target,
    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
&#125;

export function reactive(target) &#123;
  return createReactiveObject(
    target,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
&#125;

const data = reactive(&#123; a: 1 &#125;);
</code></pre>
<pre><code class="javascript">// 映射表：用于存储原始对象和代理对象之间的映射关系
const proxyMap = new WeakMap();

// 用来存储对象和其属性的依赖关系
const targetMap = new WeakMap();

const handlers = &#123;
  get: getHandler,
  set: setHandler,
  deleteProperty: deleteHandler,
  has: hasHandler,
  ownKeys: ownKeysHandler,
&#125;;

//get
function getHandler(target, key) &#123;
  // 拦截到 get 操作后，要做一些额外的事情
  // 要做的事情，就是收集依赖
  track(target, TrackOpTypes.GET, key);

  //获取值
  const result = Reflect.get(target, key);

  // 获取到的成员可能是对象，需要递归处理，将其转换为响应式
  if (isObject(result)) &#123;
    return reactive(result);
  &#125;
  return result;
&#125;

function track(target, type, key) &#123;
  // 这里要做的事情其实很简单，就是一层一层的去找，找到了就存储
  let propMap = targetMap.get(target);
  if (!propMap) &#123;
    propMap = new Map();
    targetMap.set(target, propMap);
  &#125;

  let typeMap = propMap.get(key);
  if (!typeMap) &#123;
    typeMap = new Map();
    propMap.set(key, typeMap);
  &#125;

  // 最后一步，根据 type 值去找对应的 Set
  let depSet = typeMap.get(type);
  if (!depSet) &#123;
    depSet = new Set();
    typeMap.set(type, depSet);
  &#125;

  // 现在找到 set 集合了，就可以存储依赖了
  if (!depSet.has(activeEffect)) &#123;
    depSet.add(activeEffect);
    activeEffect.deps.push(depSet); // 将集合存储到 deps 数组里面
  &#125;
&#125;

//set
function setHandler(target, key, value) &#123;
  // 在设置之前需要缓存一下旧值
  const oldValue = target[key];

  // 先进行设置操作
  const result = Reflect.set(target, key, value);

  // 要不要派发更新需要一些判断
  if (hasChanged(oldValue, value)) &#123;
    // 派发更新
    trigger(target, type, key);
  &#125;
  return result;
&#125;

function trigger(target, type, key) &#123;
  // 要做的事情很简单，就是找到依赖，然后执行依赖
  const effectFns = getEffectFns(target, type, key);
  if (!effectFns) return;
  for (const effectFn of effectFns) &#123;
    if (effectFn.options &amp;&amp; effectFn.options.shcheduler) &#123;
      // 说明用户传递了回调函数，用户期望自己来处理依赖的函数
      effectFn.options.shcheduler(effectFn);
    &#125; else &#123;
      // 执行依赖函数
      effectFn();
    &#125;
  &#125;
&#125;

function reactive(target) &#123;
  //设置代理
  const proxy = new Proxy(target, handlers);

  // 将原始对象和代理对象存储到映射表中
  proxyMap.set(target, proxy);
  return proxy;
&#125;
</code></pre>
<h4 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h4><p>activeEffect 的作用是在 track（依赖收集的时候）将函数添加到依赖中</p>
<pre><code class="javascript">/**
 * 用于记录当前活动的 effect
 */
export let activeEffect = undefined;
export const targetMap = new WeakMap(); // 用来存储对象和其属性的依赖关系
const effectStack = [];

/**
 * 该函数的作用，是执行传入的函数，并且在执行的过程中，收集依赖
 * @param &#123;*&#125; fn 要执行的函数
 */
export function effect(fn, options = &#123;&#125;) &#123;
  const &#123; lazy = false &#125; = options;
  const environment = () =&gt; &#123;
    try &#123;
      activeEffect = environment;
      effectStack.push(environment);
      cleanup(environment);
      return fn();
    &#125; finally &#123;
      effectStack.pop();
      activeEffect = effectStack[effectStack.length - 1];
    &#125;
  &#125;;
  environment.deps = [];
  environment.options = options;
  if (!lazy) &#123;
    environment();
  &#125;
  return environment;
&#125;

export function cleanup(environment) &#123;
  let deps = environment.deps; // 拿到当前环境函数的依赖（是个数组）
  if (deps.length) &#123;
    deps.forEach((dep) =&gt; &#123;
      dep.delete(environment);
    &#125;);
    deps.length = 0;
  &#125;
&#125;
</code></pre>
<h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><p>1.参数归一化</p>
<pre><code class="javascript">function normalizeParameter(getterOrOptions) &#123;
  let getter, setter;
  if (typeof getterOrOptions === &quot;function&quot;) &#123;
    getter = getterOrOptions;
    setter = () =&gt; &#123;
      console.warn(`Computed property was assigned to but it has no setter.`);
    &#125;;
  &#125; else &#123;
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  &#125;
  return &#123; getter, setter &#125;;
&#125;
</code></pre>
<p>2.实现</p>
<p><font style="color:rgb(37, 41, 51);">l</font><font style="color:rgb(37, 41, 51);">azy：此值为 true 时，只有在第一次手动调用 runner 后，依赖数据变更时，才会自动执行 effect 的回调，可以理解为 effect 的是在手动调用 runner 后才首次执行</font></p>
<p><font style="color:rgb(37, 41, 51);">scheduler：传入此参数，开启了调度模式，只有手动调用 runner 时，才会执行对应的注册回调</font></p>
<pre><code class="javascript">export function computed(getterOrOptions) &#123;
  // 1. 参数归一化
  const &#123; getter, setter &#125; = normalizeParam(getterOrOptions);

  let value; // 存储计算属性的值
  let dirty = true; // 表示计算属性是否脏，如果为 true，说明需要重新计算

  const effectFn = effect(getter, &#123;
    lazy: true,
    shcheduler() &#123;
      dirty = true;
      trigger(obj, TriggerOpTypes.SET, &quot;value&quot;);
    &#125;,
  &#125;);

  // 2. 返回一个对象
  const obj = &#123;
    get value() &#123;
      track(obj, TrackOpTypes.GET, &quot;value&quot;);
      if (dirty) &#123;
        value = effectFn();
        dirty = false;
      &#125;
      return value;
    &#125;,
    set value(newValue) &#123;
      setter(newValue);
    &#125;,
  &#125;;

  return obj;
&#125;
</code></pre>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><pre><code class="javascript">import &#123; effect, cleanup &#125; from &quot;./effect/effect.js&quot;;

/**
 * @param &#123;*&#125; source
 * @param &#123;*&#125; cb 要执行的回调函数
 * @param &#123;*&#125; options 选项对象
 * @returns
 */
export function watch(source, cb, options = &#123;&#125;) &#123;
  let getter;
  if (typeof source === &quot;function&quot;) &#123;
    getter = source;
  &#125; else &#123;
    getter = () =&gt; traverse(source);
  &#125;

  // 用于保存上一次的值和当前新的值
  let oldValue, newValue;

  // 这里的 job 就是要执行的函数
  const job = () =&gt; &#123;
    newValue = effectFn();
    cb(newValue, oldValue);
    oldValue = newValue;
  &#125;;

  const effectFn = effect(() =&gt; getter(), &#123;
    lazy: true,
    scheduler: () =&gt; &#123;
      if (options.flush === &quot;post&quot;) &#123;
        Promise.resolve().then(job);
      &#125; else &#123;
        job();
      &#125;
    &#125;,
  &#125;);

  if (options.immediate) &#123;
    job();
  &#125; else &#123;
    oldValue = effectFn();
  &#125;

  return () =&gt; &#123;
    cleanup(effectFn);
  &#125;;
&#125;

function traverse(value, seen = new Set()) &#123;
  // 检查 value 是否是对象类型，如果不是对象类型，或者是 null，或者已经访问过，则直接返回 value。
  if (typeof value !== &quot;object&quot; || value === null || seen.has(value)) &#123;
    return value;
  &#125;

  // 将当前的 value 添加到 seen 集合中，标记为已经访问过，防止循环引用导致的无限递归。
  seen.add(value);

  // 使用 for...in 循环遍历对象的所有属性。
  for (const key in value) &#123;
    // 递归调用 traverse，传入当前属性的值和 seen 集合。
    traverse(value[key], seen);
  &#125;

  // 返回原始值
  return value;
&#125;
</code></pre>
<h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><pre><code class="javascript">const KeepAlive = &#123;
  // 这是 keepalive 组件独有的属性，用于标识这是一个 keepalive 组件
  __isKeepAlive: true,
  props: &#123;
    include: RegExp,
    exclude: RegExp,
  &#125;,
  setup(props, &#123; slots &#125;) &#123;
    // 这是一个缓存对象
    // key：vnode.type
    // value: vnode
    const cache = new Map();
    // 存储当前 keepalive 组件的实例
    const instance = currentInstance;
    // 这里从组件实例上面解构出来两个方法，这两个方法实际上是由渲染器注入的
    const &#123; move, createElement &#125; = instance.keepAliveCtx;

    // 创建隐藏容器
    const storageContainer = createElement(&quot;div&quot;);

    // 这两个方法所做的事情，就是将组件从页面和隐藏容器之间进行移动
    // 这两个方法在渲染器中会被调用
    instance._deActivate = (vnode) =&gt; &#123;
      move(vnode, storageContainer);
    &#125;;
    instance._activate = (vnode, container, anchor) =&gt; &#123;
      move(vnode, container, anchor);
    &#125;;

    return () =&gt; &#123;
      // 获取到默认插槽里面的内容
      let rawVNode = slots.default();

      // 如果不是对象，说明是非组件的虚拟节点，直接返回
      if (typeof rawVNode.type !== &quot;object&quot;) &#123;
        return rawVNode;
      &#125;

      // 接下来我们从缓存里面找一下，看当前的组件是否存在于缓存里面
      const cachedVNode = cache.get(rawVNode.type);

      if (cachedVNode) &#123;
        // 缓存中存在
        // 如果缓存中存在，直接使用缓存的组件实例
        rawVNode.component = cachedVNode.component;
        // 并且挂上一个 keptAlive 属性
        rawVNode.keptAlive = true;
      &#125; else &#123;
        // 缓存中不存在
        // 那么就添加到缓存里面，方便下次使用
        cache.set(rawVNode.type, rawVNode);
      &#125;
      // 接下来又挂了一个 shouldKeepAlive 属性
      rawVNode.shouldKeepAlive = true;
      // 将 keepalive 组件实例也添加到 vnode 上面，后面在渲染器中有用
      rawVNode.keepAliveInstance = instance;
      return rawVNode;
    &#125;;
  &#125;,
&#125;;
</code></pre>

    </div>
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 后知后觉的个人主页
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;知乐
        </div>
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src='/js/main.js'></script>
    </body>
</html>
