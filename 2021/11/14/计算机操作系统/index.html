<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="John Doe" />
<meta name="referrer" content="no-referrer" />

<meta name="description" content="一、计算机系统概述操作系统的基本概念操作系统的概念1.控制和管理整个计算机系统的硬件与软件资源 2.合理地组织、调度计算机的工作与资源 3.为用户和其他软件提供方便接口与环境的程序集合 操作系统的特征基本特征：并发、共享、虚拟、异步 并发1.两个或者多个事件在同一时间间隔内发生 2.使得系统具有处理和调度多个程序同时执行的能力 3.操作系统的并发是通过分时实现的 tip:并发是指在一个时间段 并行">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机操作系统">
<meta property="og:url" content="https://merry-9001.github.io/docs/2021/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="后知后觉的个人主页">
<meta property="og:description" content="一、计算机系统概述操作系统的基本概念操作系统的概念1.控制和管理整个计算机系统的硬件与软件资源 2.合理地组织、调度计算机的工作与资源 3.为用户和其他软件提供方便接口与环境的程序集合 操作系统的特征基本特征：并发、共享、虚拟、异步 并发1.两个或者多个事件在同一时间间隔内发生 2.使得系统具有处理和调度多个程序同时执行的能力 3.操作系统的并发是通过分时实现的 tip:并发是指在一个时间段 并行">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-11-14T07:42:53.000Z">
<meta property="article:modified_time" content="2023-01-27T05:30:50.887Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="shortcut icon" href="/docs//img/favicon.ico">
<link href="/docs//css/bootstrap.css" rel="stylesheet">
<link href="/docs//css/person.css"  rel="stylesheet">
<link href="//at.alicdn.com/t/font_2822169_7n9pu9ptxz8.css" rel="stylesheet">

    <link href="/docs/plugins/jquery.fancybox.min.css" rel="stylesheet">



    <script src="/docs/plugins/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link href="/docs//css/style.css?v=1" rel="stylesheet">

<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>
    计算机操作系统 | 
    后知后觉的个人主页
</title>

<script src="/docs/plugins/jquery.min.js"></script>
<script src="/docs/plugins/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: "true",
        isHome: "false",
        isPost: "true",
        isArchive: "false",
        isTag: "false",
        isCategory: "false",
        fancybox_js: "/docs/plugins/jquery.fancybox.min.js",
        scrollreveal: "/docs/plugins/scrollreveal.min.js",
        search: ""
    }
</script>



    <script> yiliaConfig.rootUrl = "/docs/"; </script>


<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/docs/" class="profilepic">
            <img src="/docs//img/index.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/docs/"></a></h1>
        </hgroup>

        

        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/docs//docs/docs">主页</a></li>
                        
                            <li><a href="/docs//docs/tags">标签云</a></li>
                        
                            <li><a href="/docs//docs/about">关于我</a></li>
                        
                        </ul>
                    </nav>
                </section>
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger hide"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/docs/" class="profilepic">
                <img src="/docs//img/index.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/docs/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/docs/docs">主页</a></li>
                
                    <li><a href="/docs/tags">标签云</a></li>
                
                    <li><a href="/docs/about">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me"/>
</nav>
      <div class="body-wrap"><div class="post"></div>
<article id="post-计算机操作系统" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/docs/2021/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
      <time datetime="2021-11-14T07:42:53.000Z" itemprop="datePublished">2021-11-14</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      计算机操作系统
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="一、计算机系统概述"><a href="#一、计算机系统概述" class="headerlink" title="一、计算机系统概述"></a>一、计算机系统概述</h1><h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h2><h3 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h3><p>1.控制和管理整个计算机系统的硬件与软件资源</p>
<p>2.合理地组织、调度计算机的工作与资源</p>
<p>3.为用户和其他软件提供方便接口与环境的程序集合</p>
<h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><p>基本特征：并发、共享、虚拟、异步</p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>1.两个或者多个事件在同一时间间隔内发生</p>
<p>2.使得系统具有处理和调度多个程序同时执行的能力</p>
<p>3.操作系统的并发是通过分时实现的</p>
<p>tip:并发是指在一个时间段 并行是指在同一个时刻</p>
<p>并行是指系统具有同时执行或操作（多处理机）</p>
<p>对于单处理机来说，宏观上程序是并发的，微观上程序是交替执行的</p>
<h5 id="重要考点"><a href="#重要考点" class="headerlink" title="重要考点"></a>重要考点</h5><p>1.单核 cpu 同一时刻只能执行一个程序，各个程序只能并发地执行</p>
<p>2.多核 cpu 同一时刻可以同时执行多个程序，多个程序可以并行地执行</p>
<h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><h5 id="互斥共享方式"><a href="#互斥共享方式" class="headerlink" title="互斥共享方式"></a>互斥共享方式</h5><p>例如打印机，磁带，同一时刻只能供一个进程对资源进行访问</p>
<p>这种资源叫做临界资源或者独占资源</p>
<h5 id="同时访问方式"><a href="#同时访问方式" class="headerlink" title="同时访问方式"></a>同时访问方式</h5><p>一段时间内允许多个进程对资源进行访问</p>
<p>典型代表：磁盘设备</p>
<h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><p>一个物理上的实体变为若干逻辑上的对应物，这种技术也被称为虚拟技术</p>
<p>虚拟处理器：采用多道程序并发的方式，让每个终端用户感觉到有多个处理器（时分复用技术）</p>
<p>虚拟存储器：将物理存储变为虚拟存储器，逻辑上扩充存储器用量（空分复用技术）</p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>多道程序走走停停，进程以不可预知的速度向前进</p>
<h3 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h3><h4 id="管理功能"><a href="#管理功能" class="headerlink" title="管理功能"></a>管理功能</h4><h5 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h5><p>管理处理机的分配和运行，解决冲突问题，可以理解为对进程的管理</p>
<p>进程管理：进程控制 进程同步 进程通信 死锁处理 处理机调度</p>
<h5 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h5><p>为了提高多道程序运行效率，方便用户使用</p>
<p>内存分配、地址映射、内存保护、共享和内存扩充</p>
<h5 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h5><p>操作系统负责管理文件的系统称为文件系统</p>
<p>文件存储空间的管理 目录管理 文件读写管理和保护</p>
<h5 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h5><p>完成用户的 IO 请求，方便用户使用设备，提高设备的利用率</p>
<p>缓冲管理 设备分配 设备处理 虚拟设备</p>
<h4 id="接口功能"><a href="#接口功能" class="headerlink" title="接口功能"></a>接口功能</h4><h5 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h5><p>联机控制方式</p>
<p>交互式命令接口：适用于分时或者实时系统，就像人与机器对话一样</p>
<p>脱机控制方式：又称批处理系统，提交一组作业，系统进行处理，用户不能干预作业的运行</p>
<h5 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h5><p>有一组系统调用命令组成（也称作系统调用或者广义指令）</p>
<p>例如：图形用户界面（GUI）</p>
<h4 id="操作系统用作扩充机器"><a href="#操作系统用作扩充机器" class="headerlink" title="操作系统用作扩充机器"></a>操作系统用作扩充机器</h4><p>操作系统提供了资源管理功能和方便用户使用的各种服务功能，将机器改造为功能更强的机器</p>
<p>覆盖了软件的机器成为扩充机器，又称之为虚拟机</p>
<h4 id="封装思想"><a href="#封装思想" class="headerlink" title="封装思想"></a>封装思想</h4><p>操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可</p>
<h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h3><p>程序的装入，运行，结果的输出都需要人为的干预</p>
<p>缺点：资源利用率低   CPU 利用不充分</p>
<h3 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h3><p>为了解决人机矛盾以及 CPU 和 IO 设备之间速度不匹配的矛盾</p>
<h4 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h4><p>内存中始终保存一道作业，作业成批进行</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>自动性：一批作业自动执行不需要人工干预</p>
<p>顺序性：各道作业依次执行</p>
<p>单道性：仅有一道程序执行</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>缓解了一定程度的人机速度矛盾，资源利用率有所提升</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>高速 CPU 等待 I/O 设备的完成</p>
<p>内存中仅有一道程序运行，只有该程序运行结束之后才能调入下一道程序</p>
<h4 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h4><p>允许多个程序在 CPU 中交替运行，程序共享各种硬件和软件资源</p>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><p>多道：计算机中同时存放多道相互独立的程序</p>
<p>宏观中并行：多道程序都会开始运行，但都没有运行完毕</p>
<p>微观上串行：多道程序轮流占有 CPU，交替运行</p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>资源利用率</p>
<p>多道程序并发执行，共享计算机资源</p>
<p>CPU 和其他资源更能保持“忙碌”状态，系统吞吐量增大</p>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>设计复杂，要考虑各种资源调度问题</p>
<p>响应时间过长，没有人机交互功能</p>
<h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4><p>将处理器运行时间划分为时间片，将时间片分配给不同作业/用户从而占用处理机</p>
<h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><p>同时性：允许多个终端用户使用同一台计算机</p>
<p>交互性：方便进行人机对话，用户采用人机对话方式控制程序运行</p>
<p>独立性 ：多个用户彼此之间独立的操作，互不干扰</p>
<p>及时性 ：用户请求能在很短时间内获得响应</p>
<h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><p>保证在规定时间内完成某项任务</p>
<h5 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h5><p>及时性：规定时间内完成规定任务</p>
<p>可靠性：输出的结果正确，系统运行时确保稳定</p>
<h4 id="分布式计算机系统"><a href="#分布式计算机系统" class="headerlink" title="分布式计算机系统"></a>分布式计算机系统</h4><p>网络操作系统将多个计算机有机的结合在一起</p>
<p>任意两台计算机之间没有主从之分，互相交换信息，并行工作、协同完成</p>
<h4 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h4><p>广泛应用于文字处理，电子表格，游戏</p>
<p>“windows 系统现在已形成一个多系列，多用途的操作系统集合。严格上说它的本质应该是多种集合的操作系统，它在运行过程中，根据不同的进行会有实时响应和分时响应，部分功能中，它也可以实现分布式操作。同时，根据它的版本和用途不同，它也有网络操作系统版本。”</p>
<h2 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h2><h3 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h3><p>程序运行的过程其实就是 CPU 执行一条一条的机器指令的过程</p>
<h3 id="操作的运行机制"><a href="#操作的运行机制" class="headerlink" title="操作的运行机制"></a>操作的运行机制</h3><h4 id="CPU-执行的两种性质程序"><a href="#CPU-执行的两种性质程序" class="headerlink" title="CPU 执行的两种性质程序"></a>CPU 执行的两种性质程序</h4><p>操作系统内核程序</p>
<p>用户自编程序</p>
<h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>时钟管理：操作系统对用户提供标志时间，根据时钟对进程进行管理，实现进程切换</p>
<p>中断机制：初衷是为了提高多道程序运行环境中的 CPU 利用率   保护和恢复中断现场的信息，转移控制权到相关程序</p>
<p>原语：处于系统的最底层，最接近硬件</p>
<p>运行具有原子性，即只能一气呵成</p>
<p>系统控制的数据结构及处理</p>
<p>1.进程管理：进程状态管理、进程调度和分派，创建和撤销进程控制块</p>
<p>2.存储器管理：存储器的空间分配和回收，内存信息保护程序、代码对换程序</p>
<p>3.设备管理：缓冲区管理 设备分配和回收</p>
<h3 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h3><p>为了进行核心态和用户态两种状态的切换，引入了中断机制</p>
<p>核心态可以执行用户态无法执行的特权指令</p>
<p>访管指令是在用户态使用，将用户态转换为核心态，所以访管指令不是特权指令</p>
<p>“中断”是让操作系统内核夺回 CPU 使用权的唯一途径</p>
<h4 id="中断（外中断）"><a href="#中断（外中断）" class="headerlink" title="中断（外中断）"></a>中断（外中断）</h4><p>来自于 CPU 指令之外的事件发生</p>
<p>I/O 中断：输入输出已经完成</p>
<p>时钟中断：固定时间片已到，让处理机处理</p>
<h4 id="异常-内中断"><a href="#异常-内中断" class="headerlink" title="异常(内中断)"></a>异常(内中断)</h4><p>源自于 CPU 执行指令内部的事件</p>
<p>非法操作码，除零，地址越界，算术溢出</p>
<p>陷入指令：用户自行设置，执行陷入后，用户态转换为核心态</p>
<p>异常不能被屏蔽</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>用户在程序中调用操作系统提供的一些子功能</p>
<p>设备功能：完成设备的请求或者释放，设备启动等功能</p>
<p>文件管理:   完成文件的读，写，创建以及删除功能</p>
<p>进程控制：完成进程的创建，撤销，阻塞以及唤醒功能</p>
<p>进程通信：完成进程之间的消息传递和信号传递功能</p>
<p>内存管理：完成内存的分配、回收以及获取作业占用内存区大小及始址等功能</p>
<h3 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h3><p>处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令</p>
<p>处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令</p>
<p>别名：内核态=核心态=管态；用户态=目态</p>
<p>tip:cpu 中有一个寄存器叫程序状态字寄存器(psw),二进制位：1 表示内核态，0 表示用户态</p>
<h3 id="内核态、用户态的切换"><a href="#内核态、用户态的切换" class="headerlink" title="内核态、用户态的切换"></a>内核态、用户态的切换</h3><p>内核态–&gt;用户态:执行一条特权指令—–修改 psw 的标志位为用户态，这个动作意味着操作系统将主动让出 CPU 使用权</p>
<p>用户态–&gt;内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回 CPU 的使用权</p>
<h2 id="大内核与微内核"><a href="#大内核与微内核" class="headerlink" title="大内核与微内核"></a>大内核与微内核</h2><h3 id="大内核"><a href="#大内核" class="headerlink" title="大内核"></a>大内核</h3><p>将操作系统的主要功能模块进行集中，从而用以提供高性能的系统服务</p>
<p>优点：各个管理模块之间共享信息，能够有效利用相互之间的有效特性，所以有着巨大的性能优势</p>
<p>缺点：层次交互关系复杂，层次接口难以定义，层次之间界限模糊</p>
<h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>背景：随着计算机体系结构的不断发展，操作系统提供的服务越来越多，接口形式越来越复杂</p>
<p>将内核中最基本的功能(如：进程管理)保留在内核，将不需要在核心态执行的功能转移到用户态执行，降低内核设计的复杂性</p>
<p>优点：</p>
<p>有效的分离内核与服务、服务与服务、使得他们之间的接口更加的清晰，维护的代价大大降低</p>
<p>各部分可以独立的优化和演进</p>
<p>缺点</p>
<p>性能问题，需要频繁的在核心态和用户态之间进行切换</p>
<h1 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h4 id="进程的概念和特征"><a href="#进程的概念和特征" class="headerlink" title="进程的概念和特征"></a>进程的概念和特征</h4><h5 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h5><p>为了更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性</p>
<p>进程控制块(PCB)：为了更好的描述进程的基本情况和运行状态，进而控制和管理进程（PCB 是进程存在的唯一标志）</p>
<p>进程的一些典型定义</p>
<p>1.进程是程序—次执行过程</p>
<p>2.进程是一次程序及其数据在处理机上顺序执行时所发生的活动</p>
<p>3.进程是具有独立功能的程序在一个数据集合上运行的过程，是资源分配和调度的独立单位（没有引入线程）</p>
<h5 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h5><p>动态性：动态性是进程最基本特征，进程有着创建、活动、暂停、终止等过程，具有生命周期</p>
<p>并发性：多个进程实体同时存在内存中，引入进程的目的就是为了程序与其他程序并发执行</p>
<p>独立性：进程实体是—个能独立运行、独立获得资源和独立接受调度的基本单位(没有建立 PCB 的程序 ，都不能作为—个独立单位参与运行)</p>
<p>异步性: 进程相互制约，进程以不可预知的速度向前推进   所以操作系统中—定要配置响应的进程同步机制</p>
<p>结构性:每个进程都配置一个 PCB 对其进行描述(程序段、数据段、进程控制段组成进程实体)</p>
<h4 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h4><h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><p>运行态:进程在处理机上运行</p>
<p>就绪态:进程已处于准备运行状态</p>
<p>阻塞态:又称等待态，进程正在等待某个时间而暂停运行</p>
<p>创建态:进程正在被创建，尚未进入就绪态</p>
<p>结束态:进程正在从系统中消失（包括正常结束或者异常终止）</p>
<h5 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h5><p>就绪态一＞运行态 处于就绪态的进程获得处理机进入运行态</p>
<p>运行态一＞就绪态 处于运行态的进程时间片用完后，让出处理机进入就绪态</p>
<p>运行态一＞阻塞态   进程请求除处理机外的其他资源，此时运行态进入阻塞态（系统调用请求 操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式）</p>
<p>阻塞态一&gt;就绪态   进程等待其他资源的获得，如 IO 资源、或者中断结束</p>
<h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><h5 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h5><p>分配进程标识号 ，申请 PCB ( PCB 是有限的）</p>
<p>为进程分配资源，为程序和数据以及用户栈分配必要的内存空间</p>
<p>初始化 PCB , 包括初始化标志信息、初始化处理机状态信息、初始化处理机控制信息、设置进程的优先级</p>
<p>若进程就绪队列可以接纳新进程，进程就进入就绪态</p>
<h5 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h5><p>结束的分类</p>
<p>正常结束:进程的任务已经完成并且准备退出运行</p>
<p>异常结束:进程正在运行，出现了某些异常事件，导致程序无法继续运行（存储区越界、保护错、非法指令、特权指令错、IO 故障等）</p>
<p>外界干预:进程应外界请求终止运行</p>
<p>结束过程</p>
<p>根据被终止进程的标识符 ，检索 PCB , 读取进程状态</p>
<p>若进程处于运行态，终止运行，剥夺处理机</p>
<p>终止进程之下的子进程</p>
<p>该进程拥有的全部资源还给父进程或者操作系统</p>
<p>将 PCB 从队列中删除</p>
<h5 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h5><h6 id="阻塞原语执行过程"><a href="#阻塞原语执行过程" class="headerlink" title="阻塞原语执行过程"></a>阻塞原语执行过程</h6><p>找到要被阻塞进程标识号对应的 PCB</p>
<p>若该进程处于运行态，保护其现场，将其状态转换为阻塞态，停止运行</p>
<p>将 PCB 插入相应时间的等待队列</p>
<p>阻塞是一种自主行为，自我阻塞</p>
<h6 id="唤醒原语的执行过程"><a href="#唤醒原语的执行过程" class="headerlink" title="唤醒原语的执行过程"></a>唤醒原语的执行过程</h6><p>找到等待队列中进程相应的 PCB</p>
<p>将其从等待队列中移出,置其状态为就绪态</p>
<p>将 PCB 插入就绪队列 ，等待调度程序调度</p>
<p>唤醒是被相互有联系的其他进程进行唤醒</p>
<h5 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h5><p>进程切换是在内核态下完成的</p>
<p>进程切换过程</p>
<p>保存处理机上下文，包括程序计数器和其他寄存器</p>
<p>更新 PCB 信息</p>
<p>把进程的 PCB 移入相应的队列，如就绪、在某时间阻塞等队列选择另一个进程执行 ，更新其 PCB</p>
<p>更新内存管理的数据结构</p>
<p>恢复处理机上下文</p>
<h4 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h4><p>进程是一个独立的运行单位，也是操作系统进行资源分配和调度基本单位</p>
<p>进程由进程控制块，程序段，数据段组成</p>
<h5 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h5><h6 id="进程描述信息"><a href="#进程描述信息" class="headerlink" title="进程描述信息"></a>进程描述信息</h6><p>进程标识符：标志进程</p>
<p>用户标识符：进程归属的用户，主要为共享和保护服务</p>
<h6 id="进程控制和管理信息"><a href="#进程控制和管理信息" class="headerlink" title="进程控制和管理信息"></a>进程控制和管理信息</h6><p>进程当前状态:描述进程状态信息</p>
<p>进程优先级：描述进程抢占处理机优先级</p>
<p>代码运行入口地址</p>
<p>程序的外存地址</p>
<p>进入内存时间</p>
<p>处理机占用时间</p>
<p>信号量使用</p>
<h6 id="资源分配清单"><a href="#资源分配清单" class="headerlink" title="资源分配清单"></a>资源分配清单</h6><p>用以说明有关内存地址空间或者虚拟地址空间状况所打开的文件的列表和所使用的输入／输出设备信息</p>
<p>代码段指针、数据段指针、堆栈段指针、文件描述符、键盘、鼠标</p>
<h6 id="处理机相关信息"><a href="#处理机相关信息" class="headerlink" title="处理机相关信息"></a>处理机相关信息</h6><p>处理机中各寄存器的值</p>
<p>通用寄存器值、地址寄存器值、控制寄存器值，标志寄存器值，状态字</p>
<h5 id="程序段"><a href="#程序段" class="headerlink" title="程序段"></a>程序段</h5><p>能被进程调度到 CPU 执行的程序代码段</p>
<h5 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h5><p>进程对应的程序加工处理的原始数据或者程序执行时产生的中间或最者终结果</p>
<h5 id="进程的组织方式"><a href="#进程的组织方式" class="headerlink" title="进程的组织方式"></a>进程的组织方式</h5><h6 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h6><p>按照进程状态将 PCB 分为多个队列</p>
<p>操作系统持有指向各个队列的指针</p>
<h6 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h6><p>根据进程状态的不同，建立几张索引表</p>
<p>操作系统持有指向各个索引表的指针</p>
<h4 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h4><h5 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h5><p>通信进程之间存在一块可以被直接访问的共享空间</p>
<p>低级方式：基于数据结构共享</p>
<p>高级方式：基于存储区共享</p>
<p>操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，数据交换则由用户自己安排读/写指令完成</p>
<h5 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h5><p>进程间的数据交换是以格式化的消息为单位的，进程通过系统提供的发送消息和接收消息的两个原语进行数据交换</p>
<p>直接通信方式：发送进程直接发送消息给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息</p>
<p>间接通信方式：发送进程把消息发送给某个中间实体，接收进程从中间实体中获得消息   例如电子邮件系统</p>
<h5 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h5><p>发送进程以字符流形式将大量数据送入写管道，接收进程从管道中接收数据（当管道写满时，写进程的 write()系统调用将被阻塞，等待读进程将数据取走，当读进程将数据全部取走后，管道变空，此时读进程的 read()系统调用将被阻塞，管道变空的时候阻塞读进程）</p>
<p>功能互斥同步、确定对方存在</p>
<p>半双工通信，不可以同时读和写</p>
<p>限制管道的大小</p>
<p>管道变空的时候阻塞读进程</p>
<p>管道中的数据被读取后会马上被丢弃</p>
<h4 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h4><h5 id="线程基本概念"><a href="#线程基本概念" class="headerlink" title="线程基本概念"></a>线程基本概念</h5><p>减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能</p>
<p>引入线程后，进程只作为系统资源的分配单元，线程作为处理机的分配单元</p>
<h5 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h5><h6 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h6><p>传统中进程是资源和独立调度的基本单位</p>
<p>引入线程后，进程是独立调度的基本单位，线程是资源的基本单位 (不同进程的线程切换会引起进程切换)</p>
<h6 id="拥有资源"><a href="#拥有资源" class="headerlink" title="拥有资源"></a>拥有资源</h6><p>进程是资源分配的基本单位</p>
<h6 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h6><p>引入线程后 ，进程可以并发执行，多个线程之间也可以并发执行，提高了系统的吞吐量</p>
<h6 id="系统开销"><a href="#系统开销" class="headerlink" title="系统开销"></a>系统开销</h6><p>同一进程的线程切换要比进程切换开销小的多</p>
<h6 id="地址空间和其他资源"><a href="#地址空间和其他资源" class="headerlink" title="地址空间和其他资源"></a>地址空间和其他资源</h6><p>进程的地址空间之间相互独立，同—进程的各线程之间共享进程的资源，某进程的线程对其他进程不可见</p>
<h6 id="通信方面"><a href="#通信方面" class="headerlink" title="通信方面"></a>通信方面</h6><p>进程间通信需要进程同步和互斥手段的辅助，保证数据的—致性</p>
<p>线程间可以直接读／写进程程序段来进行通信</p>
<h5 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h5><p>不拥有系统资源，拥有唯一标识符和线程控制块</p>
<p>不同的线程可以执行相同的程序，同一个服务程序被不同用户调用时，操作系统将其创建为不同线程</p>
<p>同一进程的线程共享该进程拥有的全部资源</p>
<p>线程是处理机的独立调度单位</p>
<p>线程也有生命周期，阻塞，就绪，运行等状态</p>
<p>多 CPU 计算机中各个线程可占用不同的 CPU</p>
<p>每个线程都有—个线程 ID、线程控制块 (TCB)</p>
<p>切换同进程内的线程系统开销很小</p>
<p>切换进程系统开销较大</p>
<p>由于共享内存地址空间，同—进程中的线程间通信甚至无需系统干预</p>
<h4 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h4><p>用户级线程 有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在线程的实现方式</p>
<p>内核级线程 线程的管理工作全部由内核完成</p>
<h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>多对一</p>
<p>经多个用户级线程映射到—个内核级线程，线程管理在用户空间完成，用户级线程对操作系统不可见</p>
<p>优点：线程管理是在用户控件进行的，效率比较高</p>
<p>缺点：一个线程阻塞全部线程都会阻塞，多个线程不能并行运行在多处理机上</p>
<p>一对一</p>
<p>优点：并发能力强</p>
<p>缺点：创建线程开销大，影响应用程序的性能多个线程映射到多个内核线程上</p>
<p>多对多</p>
<p>多个线程映射到多个内核线程上</p>
<p>结合上述两种，既可以提高并发性 ，又适当的降低了开销</p>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h4 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h4><p>调度的基本概念：合理的对进程进行处理机分配</p>
<h5 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h5><p>作业调度（高级调度）．从辅存中选择作业送入内存，每个作业只调入一次，调出一次</p>
<p>中级调度（内存调度）：提高内存利用率和系统吞吐量，将暂时不能运行的进程调至外存，使其进入挂起态,或者将已经具备运行条件的进程调入内存，修改其状态为就绪态</p>
<p>进程调度（低级调度）：按照某种策略或者方法从就绪队列中选取一个进程，将处理机分配给它（最基本的调度，频率很高）</p>
<h5 id="三级调度的联系"><a href="#三级调度的联系" class="headerlink" title="三级调度的联系"></a>三级调度的联系</h5><p>作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间</p>
<p>作业调度次数少，中级调度次数略多，进程调度频率最高</p>
<p>进程调度使最基本的，不可或缺的</p>
<h4 id="调度时机、切换与过程"><a href="#调度时机、切换与过程" class="headerlink" title="调度时机、切换与过程"></a>调度时机、切换与过程</h4><h5 id="不能切换的情况"><a href="#不能切换的情况" class="headerlink" title="不能切换的情况"></a>不能切换的情况</h5><p>处理中断过程</p>
<p>进程在操作系统内核程序临界区的时候</p>
<p>其他需要完全屏蔽中断的原子操作过程</p>
<h5 id="可以切换的情况"><a href="#可以切换的情况" class="headerlink" title="可以切换的情况"></a>可以切换的情况</h5><p>发生引起调度条件且当前进程无法继续进行</p>
<p>中断处理结束或者自陷处理结束</p>
<h4 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h4><h5 id="非剥夺调度方式"><a href="#非剥夺调度方式" class="headerlink" title="非剥夺调度方式"></a>非剥夺调度方式</h5><p>如果想将处理机分配给一个更高优先级的进程，必须要等待当前占用处理机的进程释放处理机后才能将处理机分配给更高优先级进程</p>
<p>特点：</p>
<p>实现简单 开销小 适合大多数批处理系统</p>
<p>不适用于分时系统和大多数实时系统</p>
<h5 id="剥夺调度方式"><a href="#剥夺调度方式" class="headerlink" title="剥夺调度方式"></a>剥夺调度方式</h5><p>如果有更高级进程请求处理机，暂停正在执行的进程，将处理机分配给更高级进程</p>
<p>特点：提高系统吞吐率和响应效率</p>
<h4 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h4><p>CPU 利用率 :尽可能保持 CPU 处于忙碌状态</p>
<p>系统吞吐量:单位时间内 CPU 完成作业的数量， 调度算法和方式会对吞吐量造成较大影响</p>
<p>周转时间:作业提交到作业完成的时间</p>
<p>1.周转时间＝作业完成时间－作业提交时间</p>
<p>2.平均周转时间＝总周转时间/N 个作业</p>
<p>3.带权周转时间＝作业周转时间／作业实际运行时间</p>
<p>4.平均带权周转时间＝总带权周转时间/N 个作业</p>
<p>等待时间 作业等待处理机的时间，衡扯一个算法优劣，只需要简单的考察等待时间</p>
<p>响应时间 从用户提交请求到系统首次产生响应所用的时间</p>
<h4 id="进程的挂起态与七状态模型"><a href="#进程的挂起态与七状态模型" class="headerlink" title="进程的挂起态与七状态模型"></a>进程的挂起态与七状态模型</h4><h5 id="暂时调到外存等待的进程状态为挂起状态（挂起态）"><a href="#暂时调到外存等待的进程状态为挂起状态（挂起态）" class="headerlink" title="暂时调到外存等待的进程状态为挂起状态（挂起态）"></a>暂时调到外存等待的进程状态为挂起状态（挂起态）</h5><p>就绪挂起</p>
<p>阻塞挂起</p>
<h5 id="挂起“和“阻塞＂的区别"><a href="#挂起“和“阻塞＂的区别" class="headerlink" title="挂起“和“阻塞＂的区别"></a>挂起“和“阻塞＂的区别</h5><p>两种状态都是暂时不能获得 CPU 的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中</p>
<h3 id="典型调度算法"><a href="#典型调度算法" class="headerlink" title="典型调度算法"></a>典型调度算法</h3><h4 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h4><p>作业调度 进程调度</p>
<p>先来的先分配处理机</p>
<p>优点：算法简单，对长作业有利，有利于 CPU 繁忙型作业（计算型）</p>
<p>缺点：效率低，不利于短作业，不利于 IO 繁忙型作业</p>
<p>不会导致饥饿</p>
<p>非抢占式的算法</p>
<h4 id="短作业优先算法"><a href="#短作业优先算法" class="headerlink" title="短作业优先算法"></a>短作业优先算法</h4><p>进程调度</p>
<p>优先选择预计运行时间最短的进程</p>
<p>优点：平均等待时间,平均周转时间最短</p>
<p>缺点：对长作业不利，造成饥饿现象，没有考虑作业的紧迫性，用户可能可以缩短作业预估时间，使得无法做到短作业优先</p>
<p>产生饥饿现象，如果一直得不到服务，则称为饿死</p>
<p>SJF 和 SPF[短进程优先算法(SPF),短作业优先算法(SJF)]是非抢占式的算法，但是也有抢占式的版本–最短剩余时间优先算法</p>
<h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p>作业调度 进程调度</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>剥夺型：立即停止当前运行进程，将处理机分配给更高优先级进程</p>
<p>非剥夺型：等待当前进程运行完成，然后将处理机分配给更高优先级进程</p>
<h5 id="优先级分类"><a href="#优先级分类" class="headerlink" title="优先级分类"></a>优先级分类</h5><p>静态优先级：进程创建后无法对优先级进行修改</p>
<p>动态优先级：可以根据进程运行状态，对进程优先级进行动态调整</p>
<h5 id="优先级设置原则"><a href="#优先级设置原则" class="headerlink" title="优先级设置原则"></a>优先级设置原则</h5><p>系统进程&gt;用户进程</p>
<p>交互型进程&gt;非交互型进程</p>
<p>IO 进程&gt;计算型进程(cpu 繁忙型)</p>
<h5 id="产生饥饿现象"><a href="#产生饥饿现象" class="headerlink" title="产生饥饿现象"></a>产生饥饿现象</h5><h5 id="有抢占式的，也有非抢占式的"><a href="#有抢占式的，也有非抢占式的" class="headerlink" title="有抢占式的，也有非抢占式的"></a>有抢占式的，也有非抢占式的</h5><h4 id="高响应比调度算法"><a href="#高响应比调度算法" class="headerlink" title="高响应比调度算法"></a>高响应比调度算法</h4><p>响应比＝（等待时间＋要求服务时间）／要求服务时间= 1+ 等待时间／要求服务时间</p>
<p>等待时间相同情况下，要求服务时间越短响应比越大，有利于短作业进程</p>
<p>要求服务时间相同，作业响应比由其等待时间决定，等待时间越长响应比越高，实现先来先服务</p>
<p>对于长作业，作业的响应比可以随等待时间的增加而提高，等待时间足够长时，其响应比可以升到很高，从而获得处理机</p>
<p>不会导致饥饿</p>
<p>非抢占式的算法</p>
<h4 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h4><p>使用与分时系统，使用时间片，就绪进程按照到达先后排成队列，依次在时间片内占用处理机，时间片到达时就释放处理机</p>
<p>时间片选择很重要，过大就变成了先来先服务，过短又变成了短作业优先</p>
<p>时间片影响因素：系统响应时间，就绪队列中的进程数目和系统的处理能力</p>
<p>不会导致饥饿</p>
<p>抢占式</p>
<h4 id="多级反馈队列调度算法（融合前面几种算法）"><a href="#多级反馈队列调度算法（融合前面几种算法）" class="headerlink" title="多级反馈队列调度算法（融合前面几种算法）"></a>多级反馈队列调度算法（融合前面几种算法）</h4><h5 id="实现思想"><a href="#实现思想" class="headerlink" title="实现思想"></a>实现思想</h5><p>设置多个就绪队列，为每个队列设置不同的优先级，优先级依次递减</p>
<p>每个队列中的时间片各不相同，时间片依次递增</p>
<p>每个队列按照先来先服务原则进行进程排队，若规定时间片内没有完成，就将进程放入下—级队列</p>
<p>只有到高级队列为空的时候，低等级队列才能开始调度。</p>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>终端型作业用户：短作业优先</p>
<p>短批处理作业用户：周转时间较短</p>
<p>长批处理作业用户：讲过前面几个队列得到部分执行，不会长期得不到处理</p>
<h5 id="产生“饥饿“现象"><a href="#产生“饥饿“现象" class="headerlink" title="产生“饥饿“现象"></a>产生“饥饿“现象</h5><h5 id="抢占式"><a href="#抢占式" class="headerlink" title="抢占式"></a>抢占式</h5><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><p>一次只允许一个进程使用的资源（打印机，特殊变量，数据）</p>
<h5 id="临界资源的访问过程"><a href="#临界资源的访问过程" class="headerlink" title="临界资源的访问过程"></a>临界资源的访问过程</h5><p>进入区 检查进程是否可以进入临界区</p>
<p>临界区 可以访问临界资源的代码</p>
<p>退出区 将正在访问临界区的标志清除</p>
<p>剩余区 代码中的其余部分</p>
<h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>直接制约关系 为了完成某种任务而建立的多个进程相互合作 所以要相互进行通信同步</p>
<h6 id="遵循的原则"><a href="#遵循的原则" class="headerlink" title="遵循的原则"></a>遵循的原则</h6><p>空闲让进 临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</p>
<p>忙则等待 已有进程进入临界区后，其他试图进入临界区的进程必须等待</p>
<p>有限等待 对于请求访问临界区的进程 在有限时间内进入临界区</p>
<p>让权等待 进程不能进入临界区的时候，应当立即释放处理机</p>
<h5 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h5><p>间接制约关系，当一个进程访问临界资源的时候，其他进程不能访问</p>
<h3 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h3><h5 id="软件实现方法"><a href="#软件实现方法" class="headerlink" title="软件实现方法"></a>软件实现方法</h5><h6 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h6><p>两个程序进程交替进入临界区</p>
<p>优点 实现简单</p>
<p>缺点 可能会违背空闲让进，造成资源无法充分利用</p>
<h6 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h6><p>每个进程访问临界区资源前，先检查临界资源是否被访问，如果空闲才能进入</p>
<p>优点不用交替进入可以连续使用</p>
<p>缺点 两个进程可能同时进入临界区，违背忙则等待</p>
<h6 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h6><p>先设詈自己标志，表明自己想要进入，检查对方标志，如果对方也要进入，那么就等待否则就进入 双标志）去后检查</p>
<p>优点 不会导致两个进程都进入临界区</p>
<p>缺点 双方可能会互相谦让，导致饥饿现象</p>
<h6 id="皮特森算法"><a href="#皮特森算法" class="headerlink" title="皮特森算法"></a>皮特森算法</h6><p>防止两个进程无限期等待，在算法三的基础上增加—个标志位，从而防止饥饿</p>
<p>优点 解决了饥饿现象</p>
<p>缺点．算法复杂</p>
<h5 id="硬件实现方法"><a href="#硬件实现方法" class="headerlink" title="硬件实现方法"></a>硬件实现方法</h5><h6 id="中断屏蔽法"><a href="#中断屏蔽法" class="headerlink" title="中断屏蔽法"></a>中断屏蔽法</h6><p>对中断进行屏蔽、关中断</p>
<p>优点:关中断非常方便</p>
<p>缺点：限制了处理机交替执行程序的能力</p>
<h6 id="硬件指令法"><a href="#硬件指令法" class="headerlink" title="硬件指令法"></a>硬件指令法</h6><p>读出指定标志后，将该标志置为真</p>
<p>缺点:算法复杂</p>
<p>硬件实现方法优缺点</p>
<p>优点</p>
<p>适用于任意数目的进程</p>
<p>优点 简单且容易验证正确性</p>
<p>支持进程内有多个临界区</p>
<p>缺点</p>
<p>不能实现让权等待</p>
<p>可能会导致饥饿现象</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h4 id="整形信号量"><a href="#整形信号量" class="headerlink" title="整形信号量"></a>整形信号量</h4><p>wait:资源-1 signal =资源+1</p>
<p>没有遵循让权等待机制，会导致进程处于忙等状态</p>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>记录型信号量不存在忙等现象，除了需要一个用于代表资源数目的整型变量 value 外，再增加一个进程链表 L，用于链接所有等待该资源的进程</p>
<h4 id="利用信号量实现同步"><a href="#利用信号量实现同步" class="headerlink" title="利用信号量实现同步"></a>利用信号量实现同步</h4><p>设 S 为进程 P1 和 P2 同步的公共信号量 ，初值为 0  ,   通过设置 S 的值可以使得 P1 与 P2 按照一定顺序执行</p>
<h4 id="利用信号量实现互斥"><a href="#利用信号量实现互斥" class="headerlink" title="利用信号量实现互斥"></a>利用信号量实现互斥</h4><p>通过设置 S 的值 ，可以实现进程对临界资源的互斥访问</p>
<h4 id="利用信号量实现前驱关系"><a href="#利用信号量实现前驱关系" class="headerlink" title="利用信号量实现前驱关系"></a>利用信号量实现前驱关系</h4><p>通过设置不同的进程运行结束后，产生不同的信号量，从而可以使得目标进程运行，从而实现前驱关系</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程</p>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>局部于管程的共享结构数据说明</p>
<p>对该数据结构进行操作的—组过程</p>
<p>对局部于管程的共享数据设置初始值的语句</p>
<h4 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h4><p>局部于管程的数据只能被局部于管程内的过程所访问</p>
<p>—个进程只有通过调用管程内的过程才能进入管程访间共享数据</p>
<p>每次仅允许一个进程在管程内执行某个内部过程</p>
<h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><h4 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h4><p>多个进程因为竞争资源造成的一种僵局，没有外力作用，这些进程都无法向前继续推进</p>
<h4 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h4><p>系统资源的竞争</p>
<p>进程推进顺序非法</p>
<h5 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h5><p>互斥条件：进程对分配的资源进行排他性控制</p>
<p>不可剥夺条件：进程获得资源在未使用完之前，不能被其他进程强行夺走</p>
<p>请求并保持条件：进程已经保持了至少一个资源，提出新的资源请求，而该资源已经被其他进程占有，此时该进程被阻塞，但是自己已经获得的资源保持不放</p>
<p>循环等待条件：你等我释放 我等你释放</p>
<h3 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h3><p>破坏四个必要条件中的一个或几个，防止死锁</p>
<h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>资源分配保守，宁可资源闲置</p>
<p>—次性请求所有资源，资源剥夺，资源按序分配</p>
<p>优点 适用于突发式处理的进程，不必进行剥夺</p>
<p>缺点 效率低，进程初始化时间长，剥夺次数过多，不便灵活申请新资源</p>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>在资源的动态分配中，用某种方法防止系统进入不安全状态，避免死锁</p>
<p>运行过程中预测分配资源是否会死锁</p>
<p>寻找可能的安全序列</p>
<p>优点：不必进行剥夺</p>
<p>缺点 ：必须知道将来的资源需求，进程不能被长时间阻塞</p>
<h4 id="死锁的检测及解除"><a href="#死锁的检测及解除" class="headerlink" title="死锁的检测及解除"></a>死锁的检测及解除</h4><p>允许进程死锁，通过检测及时的判断死锁，然后对其进行解除</p>
<p>宽松，只要允许就分配资源</p>
<p>定期检测是否死锁</p>
<p>优点：不延长初始化时间，允许对死锁进行现场处理</p>
<p>缺点：通过剥夺解除死锁，造成损失</p>
<h3 id="死锁预防-1"><a href="#死锁预防-1" class="headerlink" title="死锁预防"></a>死锁预防</h3><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>某些资源只能被互斥访问，并且某些情况下必须保护互斥性</p>
<h4 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h4><p>释放已经占有的资源</p>
<p>特点:增加系统开销实现要杂降低吞吐量</p>
<p>用于状态易于保存和恢复的数据( CPU 的寄存器及内存资源）</p>
<h4 id="破坏请求并保持条件"><a href="#破坏请求并保持条件" class="headerlink" title="破坏请求并保持条件"></a>破坏请求并保持条件</h4><p>—次性申请完所需要的全部资源</p>
<p>特点:实现简单，但是资源被严重浪费，甚至可能导致进程饥饿</p>
<h4 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h4><p>采用顺序资源法，对进程进行顺序推荐</p>
<p>特点：进程编号必须稳定，可能会导致资源浪费，并且不利于用户编程</p>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><h4 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h4><p>按照某种方式分配资源后，是否会导致死锁，如果会导致死锁，那么就是不安全状态，反之就是安全状态</p>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>思想：通过计算当前资源的不同分配方式，从而预测系统是否会进入不安全状态就像是银行贷款，是否会导致银行没有足够的资金对外出借</p>
<h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p>圆圈表示进程，框表示一类资源，进程到资源的有向边称为请求边，资源到进程的边称为分配边</p>
<h4 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h4><p>在资源分配图中找到分配满足的进程，然后消去其请求边与分配</p>
<p>如果最后所有边都可以被消去，那么就是可以简化的，不存在死锁，反之存在死锁</p>
<h4 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h4><p>资源剥夺法:挂起某些死锁进程，抢占资源，将这些资源分配给其他死锁进程，但是要防止挂起时间过长</p>
<p>撤销进程法 强制撤销部分甚至全部死锁进程，并目剥夺他们的资源，撤销原则可以根据优先级和撤销进程的代价进行</p>
<p>进程回退法 让一个或者多个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而非被剥夺。要求系统保持进程历史信息，设置还原点</p>
<h4 id="死锁、饥饿、死循环的区别"><a href="#死锁、饥饿、死循环的区别" class="headerlink" title="死锁、饥饿、死循环的区别"></a>死锁、饥饿、死循环的区别</h4><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</p>
<p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象</p>
<p>死循环：某进程执行过程中一直跳不出某个循环的现象</p>
<h1 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h1><h2 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h2><h3 id="内存管理的基本原理和要求"><a href="#内存管理的基本原理和要求" class="headerlink" title="内存管理的基本原理和要求"></a>内存管理的基本原理和要求</h3><p>程序执行前需要先放到内存中才能被 CPU 处理,以缓和 CPU 与硬盘之间的速度矛盾</p>
<h4 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h4><p>内存空间的分配与回收：操作系统完成主存储器空间的分配和管理</p>
<p>地址转换：逻辑地址转换为物理地址</p>
<p>内存空间的扩充：利用虚拟存储技术或者自动覆盖技术，从逻辑上扩充内存存储保护</p>
<p>存储保护：保护各道作业在各自存储空间运行，互不干扰</p>
<h4 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h4><h5 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h5><p>编译：程序将用户源代码编译成若干目标模块</p>
<p>链接：由链接程序将编译后的形成的一组目标模块及所需要的库函数链接在一起，形成一个完整的装入模块</p>
<p>装入：由装入程序将装入模块装入内存运行</p>
<h5 id="链接的类型"><a href="#链接的类型" class="headerlink" title="链接的类型"></a>链接的类型</h5><p>静态链接：程序运行之前，将库函数连接成一个完整的可执行程序</p>
<p>装入时动态链接：将用户源程序编译后得到目标模块，装入内存时，采用边装入边链接的方式</p>
<p>运行时动态链接：对于某些目标模块的链接 ，程序需要时才会对其链接便于修改和更新，便于实现对目标模块的共享</p>
<h5 id="装入模式"><a href="#装入模式" class="headerlink" title="装入模式"></a>装入模式</h5><h6 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h6><p>装入时按照实际的内存地址，将程序和数据装入内存</p>
<p>优点:不需要对程序和数据的地址进行修改</p>
<p>缺点:只适用于单道程序环境</p>
<h6 id="可重定位装入（静态重定位）"><a href="#可重定位装入（静态重定位）" class="headerlink" title="可重定位装入（静态重定位）"></a>可重定位装入（静态重定位）</h6><p>此时采用的是模块与模块的相对地址，然后将程序和数据装入内存</p>
<p>装入时对目标程序中指令和数据的修改过程称为重定位 地址变换通常是在装入时一次完成的，又被称为静态重定位</p>
<p>特点:作业装入必须要一次性全部装入，井且运行中作业不能在内存中移动，也不能申请内存空间</p>
<h6 id="动态运行时装入（动态重定位）"><a href="#动态运行时装入（动态重定位）" class="headerlink" title="动态运行时装入（动态重定位）"></a>动态运行时装入（动态重定位）</h6><p>装入程序把装入模块装入内存后，井不立即把装入模块中的相对地址转换为绝对地址，当程序真正执行时才进行转换</p>
<p>特点:需要重定位寄存器 可以将程序分配到不连续的存储区中便于程序段的共享 可以向用户提供更大的地址空间（地址空间大于存储空间）</p>
<h5 id="逻辑地址空间与物理地址空间"><a href="#逻辑地址空间与物理地址空间" class="headerlink" title="逻辑地址空间与物理地址空间"></a>逻辑地址空间与物理地址空间</h5><p>逻辑地址空间:即相对地址，链接程序依次按照各个模块的相对地址构成统一的 0 号从单元开始的逻辑地址空间</p>
<p>物理地址空间:内存中物理单元的集合 ，是地址转换的最终地址，进程在运行时执行指令和访问数据 ，最后都要通过物理地址从主存中存取</p>
<p>地址重定位：逻辑地址转换成物理地址的过程</p>
<h5 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h5><p>CPU 中设置上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当 CPU 要访问一个地址时，分别和两个寄存器的数据比较，判断是否越界</p>
<p>重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）</p>
<p>重定位寄存器中包含最小物理地址值，界地址寄存器包含逻辑地址的最大值</p>
<p>地址转换过程:逻辑地址-&gt;界地址寄存器-&gt;重定位寄存器-&gt;物理地址</p>
<h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>思想 ：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存</p>
<p>将用户空间分为一个固定区和若干覆盖区，活跃部分放在固定区，即将访问的段放在覆盖区</p>
<p>特点:打破了必须将一个进程的全部信息装入主存后才能运行的，但限制内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存</p>
<h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><h5 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h5><p>内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</p>
<h5 id="换出"><a href="#换出" class="headerlink" title="换出"></a>换出</h5><p>将处于等待状态的程序从内存中转移到辅存</p>
<h5 id="换入"><a href="#换入" class="headerlink" title="换入"></a>换入</h5><p>把准备好竞争 CPU 运行的程序从辅存转移到内存</p>
<h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p>把磁盘空间分为文件区和对换区两部分</p>
<p>文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式</p>
<p>对换区空间只占磁盘空间的小部分 ，被换出的进程数据就存放在对换区，主要追求换入换出速度，因此通常对换区采用连续分配方式</p>
<h4 id="交换存在的问题"><a href="#交换存在的问题" class="headerlink" title="交换存在的问题"></a>交换存在的问题</h4><p>备份存储，使用快速硬盘，要求存储空间足够大，而且能够对内存映像进行直接访问</p>
<p>转移时间和所交换的内存空间成正比</p>
<p>只有进程空闲状态才能将进程换出</p>
<p>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来会很快</p>
<p>交换通常在有许多进程运行且内存吃紧时开始启动，系统负荷降低就暂停</p>
<p>普通的交换使用不多，但交换策略的某些变体在许多系统中仍发挥作用</p>
<p>注意：PCB 会常驻内存，不会被换出外存</p>
<h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><p>内存分为系统区和用户区，系统区仅供操作系统使用，通常在低地址部分，用户区为用户提供</p>
<h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><p>无须进行内存保护，不会出现越界异常</p>
<p>实现简单，无外部碎片，采用覆盖技术 ，不需要额外技术支持</p>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>只适用于单用户，单任务的操作系统</p>
<p>存在内部碎片，存储器利用率低</p>
<h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><h5 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h5><p>分区大小相等 用一台计算机去控制多个相同对象的场合，缺乏灵活性</p>
<p>分区大小不等 划分为多个较小的分区，适量的中等分区和少量大分区</p>
<h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><p>适用于多道程序的存储，无外部碎片</p>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><p>程序太大，无法放入任何一个分区</p>
<p>主存利用率低，存在内部碎片</p>
<p>不能实现多进程共享一个主存区</p>
<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>在进程装入内存的时候，根据内存的大小动态的建立分区</p>
<h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><p>分区大小可以根据进程的实际情况进行分配</p>
<h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><p>存在外部碎片，导致主存利用率下降，采用紧凑技术可以缓解这种缺陷</p>
<h5 id="动态分配算法"><a href="#动态分配算法" class="headerlink" title="动态分配算法"></a>动态分配算法</h5><h6 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h6><p>空闲分区按照地址递增的顺序进行查找，找到第一个满足要求的分区进行分配</p>
<p>优点 综合看性能最好，算法开销小，回收分区后一般不需要对空闲分区队列重新排序</p>
<h6 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h6><p>按照容量递增的顺序进行查找分区，将第一个满足条件的进行分配</p>
<p>优点:可以尽可能多地留下大片的空闲区</p>
<p>缺点:性能较差，产生最多的外部碎片</p>
<p>回收分区后可能需要对空闲分区队列重新排序</p>
<h6 id="最坏适应算法（最大适应算法）"><a href="#最坏适应算法（最大适应算法）" class="headerlink" title="最坏适应算法（最大适应算法）"></a>最坏适应算法（最大适应算法）</h6><p>空闲分区按照容量递减的次序进行查找，第一个满足条件的进行分配</p>
<p>优点:可以减少难以利用的小碎片</p>
<p>缺点导致很快，负有较大的内存块，性能很差 不利于大进程，算法开销大</p>
<h6 id="邻近适应算法（首次适应算法）"><a href="#邻近适应算法（首次适应算法）" class="headerlink" title="邻近适应算法（首次适应算法）"></a>邻近适应算法（首次适应算法）</h6><p>分配内存时从上次查找结束的位置开始继续查找</p>
<p>优点 算法开销小</p>
<p>缺点 会使高地址的大分区也被用完</p>
<h3 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>允许一个程序分散的装入不相邻的内存分区</p>
<h4 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h4><h5 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h5><p>将主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位，进程以块为单位进行空间申请</p>
<p>分页存储与固定分区技术很像，但是其分页相对于分区又很小，分页管理不会产生外部碎片，产生的内部碎片也非常的小</p>
<h5 id="分页存储的基本概念"><a href="#分页存储的基本概念" class="headerlink" title="分页存储的基本概念"></a>分页存储的基本概念</h5><h6 id="页面和页面大小"><a href="#页面和页面大小" class="headerlink" title="页面和页面大小"></a>页面和页面大小</h6><p>进程中的块＝页</p>
<p>内存中的块＝页框（页帧）</p>
<p>进程申请主存空间， 为每个页面(进程中的块)分配主存中可用页框 ，即页与页框一一对应页</p>
<p>tip:页面大小要适中</p>
<p>页面太小:进程页面数过多，页表过长，增加内存占用，降低硬件地址转换效率</p>
<p>页面太大:页内碎片过多降低内存利用率</p>
<h6 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h6><p>页号（有多少页的编号）＋页内偏移（页内存了多少东西）</p>
<h6 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h6><p>为了便于在内存中找到进程的每个页面对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般放在内存中</p>
<p>页表项：页号＋物理内存中的块号（不要与地址结构搞混）</p>
<p>页表项的物理内存块号＋地址结构中的页内偏移＝物理地址</p>
<p>差一张图</p>
<h5 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h5><p>页表项大小的设计应当尽量一页正好能装下所有的页表项</p>
<h6 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a>计算方式</h6><p>页号 P=A/L , 页内偏移量 W=A% L</p>
<p>比较页号 P 和页表长度 M , 若 P&gt;=M 产生越界中断</p>
<p>页表中页号 P 对应的页表项地址＝页表始址 F+ 页号户页表项长度取出该页表项内容 b</p>
<p>计算 E=b* L+W 使用 E 去访问内存</p>
<h6 id="分页管理存在的问题"><a href="#分页管理存在的问题" class="headerlink" title="分页管理存在的问题"></a>分页管理存在的问题</h6><p>地址变换过程必须足够快，否则访存速率会降低</p>
<p>页表不能太大，否则会降低内存利用率</p>
<h6 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h6><p>设置一个页表寄存器(PTR) , 存放页表在内存中的起始地址 F 和页表长度 M</p>
<p>页表的始址和页表长度放在进程控制块(PCB)中</p>
<h5 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h5><p>可优化方向</p>
<p>如果页表放在内存中，取地址访问一次内存，按照地址取出数据访问一次内存，共需要两次访问内存</p>
<p>优化 :地址变换机构中增加一个具有并性查找能力的高速缓冲寄存器（又称快表）为相关联存储器 (TLB),相关联存储器既可以按照地址查找也可以按照内容查找</p>
<h6 id="访问一个逻辑地址的访存次数"><a href="#访问一个逻辑地址的访存次数" class="headerlink" title="访问一个逻辑地址的访存次数"></a>访问一个逻辑地址的访存次数</h6><p>基本地址变换机构</p>
<p>两次访存</p>
<p>具有快表的地址变换机构</p>
<p>快表命中，只需一次访存</p>
<p>快表未命中 ，需要两次访存</p>
<h6 id="变换过程"><a href="#变换过程" class="headerlink" title="变换过程"></a>变换过程</h6><p>CPU 给出逻辑地址后，先查询快表中是否命中</p>
<p>若快表命中 直接从快表中该页对应的页框好与页内偏移量拼接成物理地址</p>
<p>若快表不命中，再按照正常方式从页表中查询相应页表项，并将该页表项存入快表中（按照一定策略）</p>
<h5 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h5><p>如果页数过多，就会导致页表也过多，那么我们可以考虑设置一个用来储存页表的页表（套娃）</p>
<p>逻辑地址空间格式＝一级页号＋二级页号＋页内偏移</p>
<p>设计多级页表的时候，最后一定要保证顶级页表一定只有一个</p>
<p>建立多级页表的目的在于建立索引，不必浪费主存空间去储存无用的页表项，也不用盲目式的查询页表项</p>
<p>缺少一张图</p>
<h3 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h3><h4 id="出发点"><a href="#出发点" class="headerlink" title="出发点"></a>出发点</h4><p>分页是从计算机角度考虑设计的，目的是为了内存的利用率，提高计算机性能，分页通过硬件机制实现，对用户完全透明</p>
<p>分段是从用户和程序员的角度提出，满足方便编程，信息保护和共享，动态增长及动态链接等多方面的需要</p>
<h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>按照用户进程中的自然段划分逻辑空间</p>
<p>地址结构 ＝ 段号 S+ 段内偏移量 W</p>
<p>页式系统中，页号和页内偏移对用户透明</p>
<p>段式系统中段号和段内偏移量必须由用户显示的提供</p>
<h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p>每个进程都有一张逻辑空间与内存空间映射的段表，这个段表项对应进程的一段 ，段表项记录该段在内存中的始址和长度</p>
<p>段表内容＝段号＋段长＋本段在主存中的地址</p>
<h4 id="地址变换机构（变换过程）"><a href="#地址变换机构（变换过程）" class="headerlink" title="地址变换机构（变换过程）"></a>地址变换机构（变换过程）</h4><p>逻辑地址 A 中取出段号 S 和段内偏移量 W</p>
<p>比较段号 S 和段表长度 M , 若 S&gt;=M,则产生越界中断，否则继续执行</p>
<p>段号 S 对应的段表项地址＝ 段表始址 F+段号 s•段表项长度，从该段表项中取出段长 C , 比较段内偏移量与 C 的大小判断是否出现越界</p>
<p>取出段表项中该段的始址 b,计算 E = b+W, 用得到的物理地址 E 去访问内存</p>
<h4 id="段的共享与保护"><a href="#段的共享与保护" class="headerlink" title="段的共享与保护"></a>段的共享与保护</h4><h5 id="共享-1"><a href="#共享-1" class="headerlink" title="共享"></a>共享</h5><p>两个作业的段表中响应表项指向被共享段的同—个物理副本来实现的纯代码或者可重入代码以及不可修改的数据可以被共享</p>
<h5 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h5><p>存取控制保护</p>
<p>地址越界保护</p>
<h3 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h3><p>页式存储有效的提高内存利用率，分段存储能反映程序的逻辑结构并有利于段的分享，将这两种方式结合—下，这种二者结合的方法经常在计算机理论中遇到</p>
<h4 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h4><p>作业的地址空间首先被分成若干逻辑段，每段有自己的段号</p>
<p>每个段分成若干大小固定的页</p>
<p>对内存空间的管理仍然和分页存储管理—样</p>
<h4 id="地址结构-1"><a href="#地址结构-1" class="headerlink" title="地址结构"></a>地址结构</h4><p>段号 S+ 页号 P+ 页内偏移量 W</p>
<h4 id="实现地址变换"><a href="#实现地址变换" class="headerlink" title="实现地址变换"></a>实现地址变换</h4><p>为了实现地址变换系统为每个进程建立了一张段表，每个分段有一个页表</p>
<p>—个进程中，段表只能有—个，页表可以有多个</p>
<h4 id="地址变换方式"><a href="#地址变换方式" class="headerlink" title="地址变换方式"></a>地址变换方式</h4><p>缺图</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>不能被修改的代码称为纯代码或可重入代码（不属于临界资源）</p>
<h4 id="分段与分页的区别"><a href="#分段与分页的区别" class="headerlink" title="分段与分页的区别"></a>分段与分页的区别</h4><p>分页对用户不可见，分段对用户可见</p>
<p>分页的地址空间是一维的，分段的地址空间是二维的</p>
<p>分页(单级页表),分段访问一个逻辑地址都需要两次访存，分段存储中也可以引入快表机构</p>
<p>分段更容易实现信息的共享和保护（纯代码或可重入代码可以共享）</p>
<h4 id="分段与分页优缺点"><a href="#分段与分页优缺点" class="headerlink" title="分段与分页优缺点"></a>分段与分页优缺点</h4><h5 id="分页管理"><a href="#分页管理" class="headerlink" title="分页管理"></a>分页管理</h5><p>优点：内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</p>
<p>缺点：不方便按照逻辑模块实现信息的共享和保护</p>
<h5 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h5><p>优点：很方便按照逻辑模块实现信息的共享和保护</p>
<p>缺点：如果段长过大，为其分配很大的连续空间会很不方便</p>
<p>段式管理会产生外部碎片</p>
<h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3><h4 id="传统存储管理方式的特征"><a href="#传统存储管理方式的特征" class="headerlink" title="传统存储管理方式的特征"></a>传统存储管理方式的特征</h4><h5 id="一次性"><a href="#一次性" class="headerlink" title="一次性"></a>一次性</h5><p>作业必须一次性全部装入内存后，才能开始运行</p>
<p>作业很大无法装入则无法运行</p>
<p>大量作业要求运行时，由于内存不足，只能一部分作业先运行，导致多道程序度下降</p>
<h5 id="驻留性"><a href="#驻留性" class="headerlink" title="驻留性"></a>驻留性</h5><p>作业装入内存后，一直驻留在内存中，任何部分不会被换出。</p>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><h5 id="时间局部性"><a href="#时间局部性" class="headerlink" title="时间局部性"></a>时间局部性</h5><p>一条指令执行后，不久之后指令可能被再次执行，数据被访问后，不久后数据可能再次被访问</p>
<p>原因：程序中存在着大量的循环操作</p>
<p>时间局部性通过将最近使用的指令和数据存储在高速缓冲存储器中</p>
<h5 id="空间局部性"><a href="#空间局部性" class="headerlink" title="空间局部性"></a>空间局部性</h5><p>一旦程序访问了某个存储单元，不久之后附近的存储单元也将被访问</p>
<p>原因：指令通常是顺序存放， 顺序执行的，数据一般也是以向量、数组表等形式簇聚存储的</p>
<p>空间局部性使用较大的离速缓存，将预取机制继承到离速缓存控制逻辑中实现</p>
<h4 id="虚拟存储器的定义和特征"><a href="#虚拟存储器的定义和特征" class="headerlink" title="虚拟存储器的定义和特征"></a>虚拟存储器的定义和特征</h4><p>基于局部性原理，程序的—部分装入内存，—部分留在外存，需要的时候将外存内容调入内存，就好像产生了—个巨大的内存空间</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>多次性：作业在运行时，分多次调入内存运行</p>
<p>对换性：作业不必一直驻留内存，允许作业在运行过程中进行换进换出</p>
<p>虚拟性：从逻辑上扩充内存容量 ，使用户看到的内存容量远大于实际的内存容量</p>
<h4 id="虚拟内存技术的实现"><a href="#虚拟内存技术的实现" class="headerlink" title="虚拟内存技术的实现"></a>虚拟内存技术的实现</h4><p>建立在离散分配的内存管理方式上</p>
<h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><p>请求分页存储管理</p>
<p>请求分段存储管理</p>
<p>请求段页式存储管理</p>
<h5 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h5><p>一定容量的内存和外存</p>
<p>页表机制（或者段表机制）</p>
<p>中断机构</p>
<p>地址变换机构</p>
<h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><p>系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能</p>
<h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h4><p>组成：页号 物理块号 状态位 P 访问字段 A 修改位 M 外存地址</p>
<p>状态位：当前页是否已经调入内存</p>
<p>访问字段 A ：记录本页在一段时间内被访问的次数</p>
<p>修改位 M:记录本页是否被修改过</p>
<p>外存地址 指出该页在外存上的位置（通常是物理块号）</p>
<h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><p>当访问页面不在内存时就会产生缺页中断</p>
<h5 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h5><p>指令执行期间产生中断，而不是指令执行之后产生中断和处理中断</p>
<p>一条指令在执行期间，可能产生多次缺页中断</p>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p>检索快表,找到访问页，修改页表项中的访问位，利用页表项中给出的物理块号和页内地址形成物理地址，若没有找到该页的页表项，去内存中寻找页表，看该页是否已经调入内存，没有调入则产生缺页中断，请求从外存把该页调入内存</p>
<h3 id="易混知识点"><a href="#易混知识点" class="headerlink" title="易混知识点"></a>易混知识点</h3><p>虚拟内存的最大容量是由计算机的地址结构( CPU 寻址范围）确定的</p>
<p>虚拟内存的实际容量 =min ( 内存和外存容量之和 ，CPU 寻址范围）</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法 ( OPT )"></a>最佳置换算法 ( OPT )</h4><p>选择永不使用或者最长时间内不再访问的页面进行淘汰，但是现实中是无法预知的</p>
<p>优点缺页率最小，性能最好</p>
<h4 id="先进先出页面置换算法-FIFO"><a href="#先进先出页面置换算法-FIFO" class="headerlink" title="先进先出页面置换算法(FIFO)"></a>先进先出页面置换算法(FIFO)</h4><p>优先淘汰最早进入的页面</p>
<h5 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h5><p>实现简单</p>
<h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><p>实际运行规律不匹配</p>
<h5 id="Belady-异常"><a href="#Belady-异常" class="headerlink" title="Belady 异常"></a>Belady 异常</h5><p>增大分配的物理块数但是故障数不减反增</p>
<p>只有先进先出算法会出现</p>
<h4 id="最近最久未使用-LRU-置换算法"><a href="#最近最久未使用-LRU-置换算法" class="headerlink" title="最近最久未使用( LRU ) 置换算法"></a>最近最久未使用( LRU ) 置换算法</h4><p>选择最近最长时间没有被访问的页面进行淘汰，每 个页面设置—个访问字段， 用来标识上次被访问到现在经历的时间</p>
<h5 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h5><p>性能好</p>
<h5 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h5><p>实现复杂需要寄存器和栈的硬件支持</p>
<p>LRU 是堆栈类算法</p>
<h4 id="时钟-CLOCK-置换算法"><a href="#时钟-CLOCK-置换算法" class="headerlink" title="时钟(CLOCK)置换算法"></a>时钟(CLOCK)置换算法</h4><p>像一个时钟一样转圈，每个页面设置一个使用位（访问位），遇到没有被使用的就会将页面换出，然后将使用位置 0，如果遇到使用的就会将使用位归零，然后扫描下一个</p>
<h5 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h5><p>性能接近于最佳置换算法</p>
<h5 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h5><p>实现复杂 开销大</p>
<h5 id="改进型-CLOCK-算法"><a href="#改进型-CLOCK-算法" class="headerlink" title="改进型 CLOCK 算法"></a>改进型 CLOCK 算法</h5><p>使用位（访问位）的基础上增加修改位</p>
<h6 id="扫描过程"><a href="#扫描过程" class="headerlink" title="扫描过程"></a>扫描过程</h6><p>扫描缓冲区，选择第—个使用位和修改位都为 0 的页面换出</p>
<p>第一步失败后 ，查找使用位为 0 , 修改位为 1 的进行替换 ，对于每个跳过的帧，将使用位置为 0</p>
<p>第二步失败后，指针回到初始地点且使用位（访问位）均为 0 , 重复第—步</p>
<h6 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h6><p>相对于未改进型，节省了时间</p>
<h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><p>驻留集：给—个进程的分配的物理页框的集合就是这个进程的驻留集</p>
<h4 id="考虑因素"><a href="#考虑因素" class="headerlink" title="考虑因素"></a>考虑因素</h4><p>分配给一个进程的的存储量越小 ，任何时候驻留在主存中的进程数就越多，可以提高处理机的时间利用率</p>
<p>一个进程在主存中的页数过少，页错误率就会相对较高</p>
<p>页数过多，对进程的错误率也不会产生过多的影响</p>
<h4 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h4><h5 id="固定分配局部置换"><a href="#固定分配局部置换" class="headerlink" title="固定分配局部置换"></a>固定分配局部置换</h5><p>每个进程分配固定物理块数，缺页的时候就进行换页</p>
<p>难以确定每个进程应该分配的物理块数</p>
<p>太多导致资源利用率下降 太少导致频繁缺页中断</p>
<h5 id="可变分配全局置换"><a href="#可变分配全局置换" class="headerlink" title="可变分配全局置换"></a>可变分配全局置换</h5><p>进程分配—定物理块，系统自身保留—定空闲物理块，如果进程缺页，就对该进程分配新的物理块</p>
<p>优点：最容易实现，动态调整物理块分配</p>
<p>缺点：如果盲目分配物理块，就会导致多道程序并发能力下降</p>
<h5 id="可变分配局部置换"><a href="#可变分配局部置换" class="headerlink" title="可变分配局部置换"></a>可变分配局部置换</h5><p>根据进程的缺页情况，对物理块进行动态分配，如果频繁缺页，就对其多分配物理块，如果缺页率特别低，就减少其物理块</p>
<p>优点 保持了系统的多道程序并发能力</p>
<p>缺点 加大了开销 ，实现复杂</p>
<h4 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a>调入页面的时机</h4><h5 id="预调页策略"><a href="#预调页策略" class="headerlink" title="预调页策略"></a>预调页策略</h5><p>将预计不久被访问的页面调入 ，成功率约为 50%</p>
<h5 id="请求调页策略"><a href="#请求调页策略" class="headerlink" title="请求调页策略"></a>请求调页策略</h5><p>当进程提出缺页的时候，再按照一定策略进行调页</p>
<p>特点 一次调入一页 ，调入／调出页面数多时会花费过多 I/O 开销</p>
<p>一般情况下两种策略同时使用</p>
<h4 id="从何处调入页"><a href="#从何处调入页" class="headerlink" title="从何处调入页"></a>从何处调入页</h4><p>当拥有足够的对换空间，可以全部从对换区调入所需页面，提高调页速度</p>
<p>当缺少足够的对换区空间，不会被修改的文件从文件区调入，可能被修改的部分换入对换区，以后再从对换区调入</p>
<p>原理</p>
<p>读速度比写速度块</p>
<p>UNIX 方式</p>
<p>进程相关文件访问文件区，没有运行的页面从文件区调入，曾经运行过但又被换出的页面放在对换区</p>
<h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>刚换出的页面又要换入内存</p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>分配的物理页帧数不足（主要原因）</p>
<p>置换算法不当</p>
<h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>某段时间内，进程要访问的页面集合．</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>操作系统跟走每个进程的工作集，并为进程分配大于其工作集的物理块</p>
<p>落入工作集的页面需要涸入驻留集中，落在工作集外面的页面可以从驻留集中换出</p>
<p>若还有空闲物理块，可以再调入—个进程到内存以增加多道程序数。</p>
<p>若所有进程的工作集之和超过了可用物理块的总数，操作系统就会暂停一个进程 ，并将其页面调出并将其物理块分配给其他进程</p>
<h1 id="文件管理-1"><a href="#文件管理-1" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="4-1-文件系统基础"><a href="#4-1-文件系统基础" class="headerlink" title="4.1 文件系统基础"></a>4.1 文件系统基础</h2><h3 id="文件的相关概念"><a href="#文件的相关概念" class="headerlink" title="文件的相关概念"></a>文件的相关概念</h3><h4 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h4><p>文件是以计算机硬盘为载体的存储在计算机上的信息集合，文件可以是文本文档、图片、程序等</p>
<p>系统运行时，计算机以进程为基本单位进行资源的调度和分配</p>
<p>在用户输入输出时，以文件为基本单位</p>
<p>操作系统的文件系统用于实现文件的权限访问，修改，查询和保存等功能</p>
<h5 id="文件的结构"><a href="#文件的结构" class="headerlink" title="文件的结构"></a>文件的结构</h5><h6 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h6><p>数据项是文件系统中最低级的数据组织形式</p>
<p>基本数据项 用于描述一个对象的某种属性的—个值</p>
<p>组合数据项 多个基本数据项组成</p>
<h6 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h6><p>一组数据项的集合 用于描述—个对象在某方面的属性</p>
<h6 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h6><p>创建者所定义的一组相关信息的集合</p>
<p>有结构文件 相似的记录组成（记录式文件）</p>
<p>无结构式文件 字符流组成（流式文件）</p>
<h4 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h4><p>名称：文件名称唯一，以容易读取的形式保存</p>
<p>标识符：文件的唯一标签，通常为数字，是对人不可读的一种内部名称</p>
<p>类型：被支持的不同类型的文件系统所使用</p>
<p>位置：指向设备和设备上文件的指针</p>
<p>大小：文件当前的大小，包含文件允许的最大值</p>
<p>保护：对文件进行保护的访问控制信息</p>
<p>时间，日期和用户标识：文件创建，修改和上次访问的相关信息，用于保护和跟踪文件的使用</p>
<h4 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h4><h5 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h5><p>文件系统为文件找到空间</p>
<p>目录中为文件创建条目 ，该条目记录文件名称、在文件系统中的位置以及其他可能的信息</p>
<h5 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h5><p>执行系统调用，指明文件名称和写入内容，查找文件位置，为该文件维护一个写位置的指针，当发生写操作的时候更新写指针</p>
<h5 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h5><p>执行系统调用，指出文件名称和文件位置 ，搜索目录项，系统维护一个读指针，发生读操作就对该指针进行更新</p>
<h5 id="文件重定位（文件寻址）"><a href="#文件重定位（文件寻址）" class="headerlink" title="文件重定位（文件寻址）"></a>文件重定位（文件寻址）</h5><p>按照某种条件搜索目录，将当前文件位置设为定值。并且不会读、写文件</p>
<h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5><p>搜索目录，找到文件的目录项，使其变为空项，然后回收目标文件占用的存储空间</p>
<h5 id="截断文件"><a href="#截断文件" class="headerlink" title="截断文件"></a>截断文件</h5><p>允许文件的所有属性不变，并删除文件内容，即将其长度设为 0 并释放其空间</p>
<h4 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h4><h5 id="open-请求"><a href="#open-请求" class="headerlink" title="open 请求"></a>open 请求</h5><p>首次使用文件，会调用 open 请求指明文件的属性（包括其物理位置 ）从外存复制到内存打开文件表的一个表目中，并将该表目的编号（索引）返回给用户</p>
<p>操作 open 会根据文件名搜索目录 ，并将目录条目复制到打开文件</p>
<p>调用 open 请求（创建、只读、读写、添加）等得到允许 ，进程就可以打开文件，open 会返回—个指向打开文件表中的—个条目的指针</p>
<p>通过使用该指针进行 I/0 操作 ，简化步骤并节省资源</p>
<h5 id="文件关联信息"><a href="#文件关联信息" class="headerlink" title="文件关联信息"></a>文件关联信息</h5><p>文件指针   系统跟踪上次的读写位置作为当前文件位置的指针，这种指针对于打开文件的某个进程来说是唯—的，因此必须与磁盘文件属性分开保存文件</p>
<p>文件打开计数 文件关闭时 必须重用其打开文件表条目，否则表内空间会不够用 计数器为 0 关闭文件 删除该条目</p>
<p>文件磁盘位置 该信息存储在内存，以免每个操作都要从磁盘中读取</p>
<p>访问权限 每个进程打开文件都需要—个访问模式（创建、只读、读写、添加）等。该信息保存在进程打开的文件表中 ，以便操作系统能够允许或拒绝之后的 I/0 请求</p>
<h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><h4 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h4><p>最简单的文件组织形式</p>
<p>将数据按照顺序组织记录并积累、保存。是有序相关信息项的集合</p>
<p>由于其没有结构，所以只能采用穷举搜索</p>
<p>管理简单，方便用户对其操作</p>
<p>基本信息单位操作不多的文件适合采用字符流的无结构方式</p>
<h4 id="有结构文件（记录式文件）"><a href="#有结构文件（记录式文件）" class="headerlink" title="有结构文件（记录式文件）"></a>有结构文件（记录式文件）</h4><h5 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h5><p>文件的记录是一个接—个排列，记录通常是定长的，可以顺序存储或者链表存储</p>
<p>批量处理时，顺序文件的效率是所有逻辑文件中效率最高的</p>
<p>但是增删改查操作比较困难</p>
<h5 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h5><h6 id="定长记录文件"><a href="#定长记录文件" class="headerlink" title="定长记录文件"></a>定长记录文件</h6><p>按照公式 A = i* L 可以直接得到文件地址（第 i 条记录，L 是文件长度）</p>
<h6 id="变长记录文件"><a href="#变长记录文件" class="headerlink" title="变长记录文件"></a>变长记录文件</h6><p>查找前 i- 1 条记录后，才能查找第 i 条记录</p>
<p>通过建立索引表后可以有效提高查找速度</p>
<h5 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h5><p>顺序和索引两种组织形式的结合</p>
<p>索引文件将顺序文件中的所有记录分成若干组</p>
<p>顺序文件建立起一张索引表 在索引表中为每组中的第一条记录建立一个索引项 其中含有该记录得关键字值和指向该记录的指针</p>
<p>索引顺序文件提高了查找效率，但是索引表也占用了存储空间</p>
<h5 id="直接文件或散列文件"><a href="#直接文件或散列文件" class="headerlink" title="直接文件或散列文件"></a>直接文件或散列文件</h5><p>给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址</p>
<p>这种映射结构不同于顺序文件或者索引文件，没有顺序的特性</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>包含有关文件的信息，如属性、位置和所有权等</p>
<h4 id="文件控制块和索引结点"><a href="#文件控制块和索引结点" class="headerlink" title="文件控制块和索引结点"></a>文件控制块和索引结点</h4><h5 id="文件控制块-FCB"><a href="#文件控制块-FCB" class="headerlink" title="文件控制块 ( FCB )"></a>文件控制块 ( FCB )</h5><p>用来存放控制文件需要的各种信息的数据结构，实现”按名存取“。</p>
<h6 id="包含信息"><a href="#包含信息" class="headerlink" title="包含信息"></a>包含信息</h6><p>基本信息文件名，文件的物理位置，逻辑结构、物理结构等</p>
<p>存取控制信息：文件存取权限</p>
<p>使用信息：文件建立时间、修改时间</p>
<h5 id="索引结点"><a href="#索引结点" class="headerlink" title="索引结点"></a>索引结点</h5><p>检索目录文件时，不需要将文件调入内存，只是查找其目录项，文件的描述信息单独形成为索引节点的数据结构</p>
<h6 id="磁盘索引节点"><a href="#磁盘索引节点" class="headerlink" title="磁盘索引节点"></a>磁盘索引节点</h6><p>文件主标识符拥有该文件的个人或小组的标识符</p>
<p>文件类型：普通文件、目录文件、特别文件</p>
<p>文件存取权限：各类用户对该文件的存取权限</p>
<p>文件物理地址：每个索引节点中含有 13 个地址项 ，直接或者间接的方式给出数据文件所在盘块的编号</p>
<p>文件长度：字节为单位</p>
<p>文件链接计数：本文件系统中所有指向该文件的文件名的指针计数</p>
<p>文件存取时间：文件路径被进程存取，修改以及索引节点最近被修改的时间</p>
<h6 id="文件打开后内存索引节点增加的内容"><a href="#文件打开后内存索引节点增加的内容" class="headerlink" title="文件打开后内存索引节点增加的内容"></a>文件打开后内存索引节点增加的内容</h6><p>索引结点编号:用于标识内存索引节点</p>
<p>状态:指示 i 节点是否被上锁或者被修改</p>
<p>访问计数:每当有一个进程要访问此结点时 计数加 1 访问结束减 1</p>
<p>逻辑设备号 文件所属文件系统的逻辑设备号</p>
<p>链接指针：设置分别指向空闲链表和散列队列的指针</p>
<h4 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h4><p>搜索：用户使用给一个文件时，需要搜索目录，找到该文件对应的目录项</p>
<p>创建文件:   创建一个新文件时，需要在目录中增加一个目录项</p>
<p>删除文件：删除一个文件时，需要在目录中删除相应的目录项目</p>
<p>显示目录：用户可以请求显示目录的内容，显示该用户目录中的所有文件及属性</p>
<p>修改目录：某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项</p>
<h4 id="目录结构分类"><a href="#目录结构分类" class="headerlink" title="目录结构分类"></a>目录结构分类</h4><h5 id="单机目录结构"><a href="#单机目录结构" class="headerlink" title="单机目录结构"></a>单机目录结构</h5><p>整个文件系统只建立一张目录表，每个文件占一个目录项</p>
<p>优点 实现了按名存取</p>
<p>缺点·查找速度慢，文件不允许重名，不便于文件共享，不适用于多用户的操作系统</p>
<h5 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h5><p>将文件分为主目录和用户目录，主目录记录用户名及相应用户文件目录所在的存储位置，用户目录项记录该用户文件的 FCB 信息。</p>
<p>优点：解决了不同用户文件重名问题，在—定程度上保证了文件的安全</p>
<p>缺点：缺乏灵活性，不能对文件分类</p>
<h5 id="多级目录结构"><a href="#多级目录结构" class="headerlink" title="多级目录结构"></a>多级目录结构</h5><p>将两级目录结构的层次关系加以推广，就形成了多级目录结构，即树形目录结构</p>
<p>进程对各文件的访问都是相对于当前目录进行的</p>
<p>优点 有效的对文件进行分类 文件结构层次，能够清晰有效的进行文件管理和保护</p>
<p>缺点 按照路径名访问中间结点，增加了磁盘访问次数，降低了查询速度</p>
<h5 id="无环图目录结构"><a href="#无环图目录结构" class="headerlink" title="无环图目录结构"></a>无环图目录结构</h5><p>在树形目录结构基础上增加了一些指向同一结点的有向边，使整个目录称为一个有向无环圈</p>
<p>优点有利于实现文件共享</p>
<h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><h4 id="基于索引节点的共享方式（硬链接）"><a href="#基于索引节点的共享方式（硬链接）" class="headerlink" title="基于索引节点的共享方式（硬链接）"></a>基于索引节点的共享方式（硬链接）</h4><p>文件目录中只设置文件名及指向相应索引节点的指针， 在索引节点中还有一个链接计数 count , 用于表示链接到本索引节点（即文件）上的用户目录项的数目</p>
<p>硬链接是多个指针指向一个索引结点 保证只要还有—个指针指向索引节点 索引节点就不能删除</p>
<p>优点 硬链接的查找速度要比软链接快</p>
<h4 id="利用符号链实现文件共享（软链接-）"><a href="#利用符号链实现文件共享（软链接-）" class="headerlink" title="利用符号链实现文件共享（软链接 ）"></a>利用符号链实现文件共享（软链接 ）</h4><p>B 用户共享 A 用户的文件 F 时候，系统创建—个 LINK 类型的新文件 ，也取名 F , 然后将文件 F 写入用户 B 的目录中 ，但是新文件中知识含有被链接文件 F 的路径名</p>
<p>软链接就是把到达共享文件的路径记下录来 当要访问文件时 根据路径寻找文件</p>
<p>优点 网络共享只需要提供该文件所在机器的网络地址及该机器中的文件路径</p>
<p>缺点 由于是根据文件路径名查找文件，因此会增加时间开销并且增加了启动磁盘的频率 ，同时符号链的索引节点也会耗费—定的硬盘空间</p>
<h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3><p>为了防止文件共享导致文件被破坏或者未经允许修改文件，文件系统必须控制用户对文件的存取， 解决对文件的读、写、执行的许可问题</p>
<h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><p>口令保护，加密保护（为了防止用户文件被别人窃取或者存取）</p>
<p>访问控制：用于控制用户对文件的访问方式</p>
<h4 id="访问类型"><a href="#访问类型" class="headerlink" title="访问类型"></a>访问类型</h4><p>读、写、执行、添加、删除列表清单（列出文件名和属性名）</p>
<p>还可以对文件重命名、复制、编辑等加以控制</p>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><h5 id="根据用户身份进行控制"><a href="#根据用户身份进行控制" class="headerlink" title="根据用户身份进行控制"></a>根据用户身份进行控制</h5><p>为每个文件和目录增加—个访问控制列表，规定每个用户名及其所允许的访问类型</p>
<p>优点 可以使用复杂的访问方法</p>
<p>缺点 长度无法预计且可能导致复杂空间管理</p>
<h5 id="精简访问列表"><a href="#精简访问列表" class="headerlink" title="精简访问列表"></a>精简访问列表</h5><p>拥有者：创建文件的用户</p>
<p>组：一组需要共享文件且具有类似访问的用户</p>
<p>其他：系统内的所有其他用户</p>
<h5 id="口令"><a href="#口令" class="headerlink" title="口令"></a>口令</h5><p>用户请求访问时需要提供相应的口令</p>
<p>优点 时间和空间开销不多</p>
<p>缺点 口令直接存储在系统内部不安全</p>
<h5 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h5><p>用户对文件进行加密， 用户访问需要秘钥解密</p>
<p>优点 保密性强。节省了存储空间</p>
<p>缺点 加密和解密需要花费—定时间</p>
<p>tip:口令和密码都是防止文件被他人存取或者窃取 ，没有控制用户对文件的访问类型</p>
<h2 id="4-2-文件系统的实现"><a href="#4-2-文件系统的实现" class="headerlink" title="4.2 文件系统的实现"></a>4.2 文件系统的实现</h2><h3 id="文件层结构"><a href="#文件层结构" class="headerlink" title="文件层结构"></a>文件层结构</h3><p>用户调用接口 文件系统为用户提供与文件及目录有关的调用</p>
<p>文件目录系统   管理文件目录，管理活跃文件目录表，管理读写状态信息表，管理用户进程的打开文件表，管理与组织存储设备上的文件目录结构。调用下—级存取控制模块</p>
<p>存取控制验证 实现文件保护，将用户的访问请求与 FCB 中指示的访问控制权限进行比较，以确认访问的合法性</p>
<p>逻辑文件系统关于文件信息缓冲区 逻辑文件系统与文件信息缓冲区的主要功能是，根据文件的逻辑结构将用户要读写的逻辑记录转换成文件逻辑结构内的相应块号</p>
<p>物理文件系统把逻辑记录所在的相对块号转换成实际的物理地址</p>
<p>辅助分配模块 管理辅存空间，负责分配辅存空闲空间和回收辅存空间</p>
<p>设备管理程序模块 分配设备，分配设备读写用缓冲区，磁盘调度，启动设备，处理设备中断，释放设备读写缓冲区，释放设备</p>
<h3 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h3><h4 id="线性列表"><a href="#线性列表" class="headerlink" title="线性列表"></a>线性列表</h4><p>使用存储文件名和数据块指针的线性表</p>
<p>优点：实现简单</p>
<p>缺点：耗费时间</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>根据文件名得到一个值，然后返回一个指向线性列表中元素的指针</p>
<p>优点 查找迅速，插入和删除简单</p>
<p>缺点   要避免充足，哈希表长度固定以及哈希函数对表长有依赖性</p>
<h3 id="文件实现"><a href="#文件实现" class="headerlink" title="文件实现"></a>文件实现</h3><h4 id="文件的分配方式"><a href="#文件的分配方式" class="headerlink" title="文件的分配方式"></a>文件的分配方式</h4><h5 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h5><p>每个文件在磁盘上占有一组连续的块，磁盘地址定义了磁盘上的一个线性排序</p>
<p>访存 1 次</p>
<p>优点   实现简单，存取速度快，使得访问磁盘需要的寻道数和寻道时间最小</p>
<p>缺点 文件长度不宜动态的堵加，会产生外部碎片</p>
<h5 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h5><p>采用离散分配方式，提高了磁盘空间利用率，消除了外部碎片</p>
<p>访存 n 次</p>
<h6 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h6><p>磁盘块分布在磁盘的任何地方，除最后—个盘块，其他盘块都有指向下—个盘块的指针</p>
<p>优点：不会有碎片问题，外存利用率高</p>
<p>缺点：不能直接访问，稳定性存在问题</p>
<h6 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h6><p>把用于链接文件各物理块的指针，从每个物理块的末尾提取出来，显示的存放在内存的一张连接表中。整个磁盘设詈一张</p>
<p>优点：显著的提高检索速度，减少了访问磁盘次数</p>
<p>缺点：文件分配表的需要占用—定的存储空间</p>
<h5 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h5><p>索引分配解决了链接分配不能直接访问的问题</p>
<p>m 级要访存 m+l 次</p>
<h6 id="优化机制"><a href="#优化机制" class="headerlink" title="优化机制"></a>优化机制</h6><p>链接方案一个索引块通常为一个磁盘块，为了处理大文件，可以将多个索引块链接起来</p>
<p>多层索引     第—层索引块指向第二层索引块，第二层索引块，指向文件块</p>
<p>混合索引 系统既采用直接地址有采用单级索引分配方式或者两级索引分配方式</p>
<h4 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h4><p>文件存储在一个文件卷中，文件卷可以是物理盘的一部分，也可以是整个物理盘在一个文件卷中，文件数据信息的（文件区）和存放文件控制信息 FCB 的空间是分离的</p>
<p>文件存储设备分成许多大小相同的物理块，以块为单位交换信息</p>
<p>文件存储设备管理的实质是对空闲块的组织和管理，包括空闲块的组织、分配与回收等问题</p>
<h5 id="空闲块管理"><a href="#空闲块管理" class="headerlink" title="空闲块管理"></a>空闲块管理</h5><p>空闲表法 属于连续分配方式，系统为空闲区建立—张空闲盘块表，每个空闲区第—个盘块号，该区的空闲盘块数等信息。</p>
<p>空闲链表法 将所有的空闲盘区拉成一条空闲链，根据构成链所有的基本元素不同，可以把链表分成两种形式</p>
<p>空闲盘块链 将磁盘上所有空闲空间以盘块为单位拉成—条链</p>
<p>空闲盘区链 将磁盘上所有空闲盘区拉成一条链</p>
<h5 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h5><p>采用二进制的—位来表示—个盘块的使用情况，磁盘上所有的盘块都有—个二进制位与之对应</p>
<p>盘块的分配</p>
<p>计算公式 b = n(i-1)+j</p>
<p>盘块的回收</p>
<p>i= (b-1) DIV n + 1</p>
<p>J = (b-1) MOD n + 1</p>
<p>i 行 j 列</p>
<h5 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h5><p>UNIX 使用 ，结合了空闲表和空闲链表法克服了表太大的缺点</p>
<p>把顺序的 n 个空闲扇区地址保存在第—个空闲扇区内，其后—个空闲扇区内则保存另一顺序空闲扇区的地址</p>
<h2 id="磁盘组织与管理"><a href="#磁盘组织与管理" class="headerlink" title="磁盘组织与管理"></a>磁盘组织与管理</h2><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p>表面涂有磁性物质的金属或塑料构成的圆形盘片，通过一个称为磁头的导体线圈从磁盘读取数据。</p>
<p>磁盘盘面上的数据存储在一组同心圆中，称为磁道</p>
<p>一个盘面有上千个磁道，磁道又划分为几百个扇区，每个扇区固定存储大小，一份扇区称为一个盘块</p>
<p>磁盘地址用柱面号－盘面号－扇区号（块号）表示</p>
<h4 id="磁盘分类"><a href="#磁盘分类" class="headerlink" title="磁盘分类"></a>磁盘分类</h4><p>固定头磁盘磁头相对于盘片的径向方向固定</p>
<p>活动头磁盘每个磁道—个磁头，磁头可以移动</p>
<p>固定盘磁盘 磁头臂可以来回伸缩定位磁道，磁盘永久固定在磁盘驱动器内</p>
<p>可换盘磁盘可以移动和替换</p>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><h4 id="读写时间组成"><a href="#读写时间组成" class="headerlink" title="读写时间组成"></a>读写时间组成</h4><p>寻找时间 活动头磁盘在读写信息前,将磁头移动到指定磁道所需要的时间（跨越 n 条磁道＋启动磁臂 ） Ts= m*n +s</p>
<p>延迟时间 磁头定位到某—磁道扇区所需要的时间,Tr=1/2r(转速为 r)</p>
<p>传输时间· 从磁盘读出或向磁盘写入数据经过时间， Tr=b/rN</p>
<h4 id="磁盘调度算法-1"><a href="#磁盘调度算法-1" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><h5 id="先来先服务算去-FCFS"><a href="#先来先服务算去-FCFS" class="headerlink" title="先来先服务算去 (FCFS )"></a>先来先服务算去 (FCFS )</h5><p>按照进程请求访问磁盘的先后顺序进行调度</p>
<p>优点 公平 实现简单</p>
<p>缺点： 适用于少量进程访问 ，如果进程过多算法更倾向于随机调度</p>
<h5 id="最短寻找时间有限算法-SSTF"><a href="#最短寻找时间有限算法-SSTF" class="headerlink" title="最短寻找时间有限算法(SSTF)"></a>最短寻找时间有限算法(SSTF)</h5><p>选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道</p>
<p>优点：性能强于先来先服务算法</p>
<p>缺点：容易产生饥饿现象</p>
<h5 id="扫描-SCAN-算法"><a href="#扫描-SCAN-算法" class="headerlink" title="扫描(SCAN) 算法"></a>扫描(SCAN) 算法</h5><p>在磁头当前移动方向上选择与当前磁头所在的磁道距离最近的请求作为下一次服务对象</p>
<p>优点 寻道性能好，可以避免饥饿现象</p>
<p>缺点 对最近扫描过的区域不公平， 访问局部性方面不如 FCFS 和 SSTF 好</p>
<h5 id="循环扫描算法-C-SCAN"><a href="#循环扫描算法-C-SCAN" class="headerlink" title="循环扫描算法 ( C-SCAN)"></a>循环扫描算法 ( C-SCAN)</h5><p>磁头单向移动，回返时直接回到起始端，而不服务任何请求</p>
<p>在 SCAN 与 C-SCAN 算法的基础上规定了查看移动方向上是否有请求，如果没有就不会继续向前移动，而是直接改变方向 ( LOOK ) 或者直接回到第一个请求处(C-LOOK)</p>
<h5 id="LOOK-与-C-LOOK-算法"><a href="#LOOK-与-C-LOOK-算法" class="headerlink" title="LOOK 与 C-LOOK 算法"></a>LOOK 与 C-LOOK 算法</h5><p>少图</p>
<h5 id="对盘面交替编号"><a href="#对盘面交替编号" class="headerlink" title="对盘面交替编号"></a>对盘面交替编号</h5><p>因磁头在读／写一个物理块后，需要经过短暂的处理时间才能开始处理下一块</p>
<h3 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h3><h4 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h4><h5 id="低级格式化"><a href="#低级格式化" class="headerlink" title="低级格式化"></a>低级格式化</h5><p>磁盘分扇区，为每个扇区采用特别的数据结构（头、数据区域、尾部组成），头部含有一些磁盘控制器所使用的信息</p>
<p>进一步格式化处理   磁盘分区，对物理分区进行逻辑格式化（创建文件管理系统），包括空闲和已分配的空间及—个初始为空的目录</p>
<h5 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h5><p>计算机启动时运行自举程序，初始化 CPU 寄存器、设备控制器和内存等， 然后启动操作系统</p>
<p>组局程序通常保存在 ROM 中 ，在 ROM   中保留很小的自举块，完整的自举程序保存在启动块上</p>
<p>拥有启动分区的磁盘称为启动磁盘或系统磁盘</p>
<h5 id="坏块"><a href="#坏块" class="headerlink" title="坏块"></a>坏块</h5><p>无法使用的扇区</p>
<p>对于简单的磁盘 可以在逻辑格式化时（ 建立文件系统时）对整个磁盘进行坏块检查 标明哪些扇区是坏扇区，比如在 FAT 表上标明</p>
<h6 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h6><p>简单磁盘：手动处理， 对坏块进行标记，程序不会使用</p>
<p>复杂磁盘：控制器维护一个磁盘坏块链表，同时将一些块作为备用，用于替代坏块（ 扇区备用）</p>
<h1 id="输入输出（IO）管理"><a href="#输入输出（IO）管理" class="headerlink" title="输入输出（IO）管理"></a>输入输出（IO）管理</h1><h2 id="IO-管理概述"><a href="#IO-管理概述" class="headerlink" title="IO 管理概述"></a>IO 管理概述</h2><h3 id="I-0-设备"><a href="#I-0-设备" class="headerlink" title="I/ 0 设备"></a>I/ 0 设备</h3><h4 id="人机交互的外部设备"><a href="#人机交互的外部设备" class="headerlink" title="人机交互的外部设备"></a>人机交互的外部设备</h4><p>用于与计算机用户之间交互设备（打印机，鼠标，键盘）</p>
<p>交换速度相对较慢，以字节为单位进行数据交换</p>
<h4 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h4><p>用于存储程序和数据的设备（磁盘、磁带 、光盘 ）</p>
<p>交换速度较快，以多字节组成的块为基本单位交换</p>
<h4 id="网络通信设备"><a href="#网络通信设备" class="headerlink" title="网络通信设备"></a>网络通信设备</h4><p>用于远程设备通信的设备（网络接口、调制解调器）</p>
<p>速度介于前两类之间</p>
<h4 id="传输速率分类"><a href="#传输速率分类" class="headerlink" title="传输速率分类"></a>传输速率分类</h4><p>低速设备 每秒进位几个字节到数百字节（鼠标、键盘）</p>
<p>中速设备 传输速率为每秒数干字节至数万字节（行式打印机、激光打印机）</p>
<p>高速设备 传输速率在数百前字节至干兆字节的—类设备（磁带机、磁盘机、光盘机）</p>
<h4 id="信息交换单位分类"><a href="#信息交换单位分类" class="headerlink" title="信息交换单位分类"></a>信息交换单位分类</h4><h5 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h5><p>信息存取总是以数据块为基本单位，存储信息的设备称为块设备</p>
<p>传输速率高，可寻址，可以任意读写某块</p>
<h5 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h5><p>用于数据输入输出的设备为字符设备，传输的基本单位是字符（交互式终端机，打印机）</p>
<p>传输速率低，不可寻址，输入轮出时常采用中断驱动方式</p>
<h3 id="I-0-控制方式"><a href="#I-0-控制方式" class="headerlink" title="I/0 控制方式"></a>I/0 控制方式</h3><h4 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h4><p>计算机从外部设备读取数据到存储器 ，每次读—个字的数据，对读入的每个字，CPU 都要对外设状态进行循环检查 ，直到确定该字已经在 IO 设备控制器的数据寄存器中。</p>
<p>读写单位：字</p>
<p>优点：容易实现，操作简单</p>
<p>缺陷：CPU 高速性和 IO 设备的低速性的矛盾（降低了 CPU 的利用率 ） ，CPU 和 IO 设备只能串行工作</p>
<h4 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h4><p>允许 IO 设备主动打断 CPU 的允许并请求服务，进而解放 CPU，使其向 IO 控制器发送读命令后可以继续做其他有用的工作</p>
<p>读写单位：字</p>
<p>优点：比程序直接控制方式有效</p>
<p>缺点：数据的传输必须要经过 CPU，仍然后消耗 CPU 的时间</p>
<h4 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h4><p>IO 设备和内存之间开辟直接的数据交换通路 ，彻底解放 CPU</p>
<h5 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h5><p>读写单位数据块</p>
<p>设备直接送入内存</p>
<p>只有当一个或多个数据块开始和结束的时候 ， CPU 才会进行干预</p>
<h5 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h5><p>命令／状态寄存器(CR)   用于接收 CPU 发送的 IO 命令和有关控制信息或者设备状态</p>
<p>内存地址寄存器 ( MAR) 数据直接在设备与内存之间交互</p>
<p>数据寄存器 ( DR)用于暂存从设备到内存或者从内存到设备的数据</p>
<p>数据计数器 ( DC ) 存放本次要传送的字（ 节 ）数</p>
<h4 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h4><p>设置—个专门负责轮入／输出的处理机 ( DMA 方式的发展 ） ，实现对一组数块的读写以及相关控制和管理为单位干预</p>
<p>读写单位—组块</p>
<p>优点 有效的提高了系统资源利用率</p>
<p>缺点 实现较为复杂</p>
<h4 id="DMA-与通道的区别"><a href="#DMA-与通道的区别" class="headerlink" title="DMA 与通道的区别"></a>DMA 与通道的区别</h4><p>DMA 需要 CPU 来控制传输的数据块大小、传输的内存位置、而通道方式中这些信息是由通道控制的</p>
<p>DMA 控制器对应—台设备与内存传递数据 ，通道可以控制多态设备与内存的数据交换</p>
<h2 id="I-O-子系统的层次结构"><a href="#I-O-子系统的层次结构" class="headerlink" title="I/O 子系统的层次结构"></a>I/O 子系统的层次结构</h2><h3 id="层次划分"><a href="#层次划分" class="headerlink" title="层次划分"></a>层次划分</h3><p>用户层 IO 软件 实现与用户交互的接口 ，用户可以直接调用在用户层提供的，与 IO 操作有关的库函数 ，对设备进行操作</p>
<h4 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h4><p>用于实现用户程序与设备驱动器的统—接口、设备命令、设备保护及设备分配与释放，同时为设备管理与数据传送提供必要的存储空间</p>
<p>设备独立性也称为设备无关性，使得应用程序独立于具体使用的物理设备（使用逻辑设备名）</p>
<h5 id="使用逻辑设备名的好处"><a href="#使用逻辑设备名的好处" class="headerlink" title="使用逻辑设备名的好处"></a>使用逻辑设备名的好处</h5><p>增加设备分配的灵活性</p>
<p>易于实现 IO 重定向</p>
<h5 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h5><p>执行所有设备的公有操作（设备的分配与回收，逻辑设备名映射为物理设备名，对设备进行保护，进制用户直接访问设备），屏蔽设备之间数据交换的速度差异等</p>
<p>向用户层（文件层）提供统一接口 无论哪种设备，他们向用户提供的接口都是相同的</p>
<h4 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h4><p>与硬件直接相关 ，负责实现系统对设备发出的操作命令，驱动 IO 设备工作的驱动程序</p>
<h4 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h4><p>用于保存被中断进程的 CPU 环境，转入相应的中断处理程序进行处理，处理完并恢复被中断进程的现场后，返回被中断进程</p>
<h4 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h4><p>IO 设备通常包括一个机械部件和一个电子部件</p>
<h3 id="设备控制的功能"><a href="#设备控制的功能" class="headerlink" title="设备控制的功能"></a>设备控制的功能</h3><p>接收和识别 CPU 或通道发来的命令(磁盘的读写查找等命令)</p>
<p>实现数据交换 （设备与控制器之间 控制器与主存之间）</p>
<p>发现和记录设备及自身的状态信息，供 CPU 处理使用</p>
<p>设备地址识别</p>
<h3 id="设备控制器的组成"><a href="#设备控制器的组成" class="headerlink" title="设备控制器的组成"></a>设备控制器的组成</h3><h4 id="设备控制器与-CPU-的接口"><a href="#设备控制器与-CPU-的接口" class="headerlink" title="设备控制器与 CPU 的接口"></a>设备控制器与 CPU 的接口</h4><h5 id="信号线"><a href="#信号线" class="headerlink" title="信号线"></a>信号线</h5><p>数据线</p>
<p>地址线</p>
<p>控制线</p>
<h4 id="设备控制器与设备的接口"><a href="#设备控制器与设备的接口" class="headerlink" title="设备控制器与设备的接口"></a>设备控制器与设备的接口</h4><p>每个接口存在数据，控制和状态三种类型的信号</p>
<h4 id="IO-控制逻辑"><a href="#IO-控制逻辑" class="headerlink" title="IO 控制逻辑"></a>IO 控制逻辑</h4><p>用于实现对设备的控制,通过—组控制线与 CPU 进行交互，对从 CPU 受到的 IO 命令进行译码</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>一个 I/0 控制器可能会对应多个设备</p>
<p>数据寄存器、控制寄存器 状态寄存器可能有多个，且这些寄存器都要有相应的地址， 才能方便 CPU 操作</p>
<p>有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像 I/0</p>
<p>一些计算机则采用 I/0 专用地址，即寄存器独立编址</p>
<h2 id="IO-核心子系统"><a href="#IO-核心子系统" class="headerlink" title="IO 核心子系统"></a>IO 核心子系统</h2><h3 id="IO-子系统概述"><a href="#IO-子系统概述" class="headerlink" title="IO 子系统概述"></a>IO 子系统概述</h3><p>主要提供 IO 调度，缓冲与高速缓存  ，设备分配与回收，假脱机 ，设备保护和差错处理</p>
<h3 id="IO-调度概念"><a href="#IO-调度概念" class="headerlink" title="IO 调度概念"></a>IO 调度概念</h3><p>通过 IO 调度改善系统整体性能，使得进程之间公平共享设备访问，减少 IO 完成所需要的平均等待时间</p>
<p>使用主存或者磁盘上的存储空间的技术，如缓冲，高速缓存｀假脱机等来改善计算机效率</p>
<h3 id="高速缓存与缓冲区"><a href="#高速缓存与缓冲区" class="headerlink" title="高速缓存与缓冲区"></a>高速缓存与缓冲区</h3><h4 id="磁盘高速缓存"><a href="#磁盘高速缓存" class="headerlink" title="磁盘高速缓存"></a>磁盘高速缓存</h4><p>使用磁盘高速缓存技术可以提高磁盘的 IO 速度 ，对高速缓存复制的访问要比原始数据访问更高效</p>
<p>高速缓存 逻辑上属于磁盘 物理上属于驻留在内存中的盘</p>
<h5 id="在内存中的两种形式"><a href="#在内存中的两种形式" class="headerlink" title="在内存中的两种形式"></a>在内存中的两种形式</h5><p>在内存中开辟一个单独的存储空间作为磁盘高速缓存，大小固定</p>
<p>把未利用的内存空间作为一个缓冲池，供谓求分页系统和磁盘 IO 时共享</p>
<h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h4><h5 id="引入缓冲区的目的"><a href="#引入缓冲区的目的" class="headerlink" title="引入缓冲区的目的"></a>引入缓冲区的目的</h5><p>缓和 CPU 与 IO 之间的速度差异矛盾</p>
<p>减少对 CPU 的中断频率 ， 放宽对 CPU 中断、响应时间的限制</p>
<p>解决基本数据单元大小不匹配的问题</p>
<p>提高 CPU 和 IO 设备之间的并行性</p>
<h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><p>采用硬件缓冲器（成本过高），除了关键位置，一般不使用硬件缓冲</p>
<p>采用缓冲区（位于内存区域 ）</p>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><h5 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h5><p>设备和处理机之间设置缓冲区，设备和处理机交换数据的时候，先把被交换的数据写入缓冲区，然后需要数据的设备或处理机从缓冲区中取走数据</p>
<p>使用时间 max (C,T)+M</p>
<h5 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h5><p>设置两个缓冲区，当缓冲区 1 满时 ，向缓冲区 2 中注入数据 ，只有缓冲区满才能取出数据</p>
<p>提高了处理机和输入设备的并行操作程度</p>
<p>max ( C+M, T）</p>
<p>tip:参数表示</p>
<p>C: CPU 对数据的处理时间</p>
<p>T   数据写入缓冲区的时间</p>
<p>M 缓冲区数据传入用户区的时间( CPU 区 ）</p>
<h5 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h5><p>包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区 ，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环形</p>
<h5 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h5><p>缓冲区分为三个队列，空缓冲队列，装满输入数据的缓冲队列，装满输出数据的缓冲队列</p>
<p>四种缓冲区 收容输入数据的工作缓冲区，提取输入数据的工作缓冲区，收容输出数据的工作缓冲区，提取输出数据的工作缓冲区</p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>管道通信中的“管道“其实就是缓冲区。要实现数据的双向传输，必须设置两个管道</p>
<h3 id="设备分配与回收"><a href="#设备分配与回收" class="headerlink" title="设备分配与回收"></a>设备分配与回收</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>根据用户 IO 请求分配设备，原则充分发挥设备的使用效率，避免进程死锁</p>
<h4 id="设备类型分类"><a href="#设备类型分类" class="headerlink" title="设备类型分类"></a>设备类型分类</h4><p>独占式使用设备 设备只能互斥使用（打印机）</p>
<p>分时共享使用设备 — 通过分时共享来提高设备的利用率</p>
<p>SPOOLing 方式使用设备 使用空间换时间，对 IO 设备进行批处理</p>
<h4 id="设备分配的数据结构"><a href="#设备分配的数据结构" class="headerlink" title="设备分配的数据结构"></a>设备分配的数据结构</h4><p>设备控制表(DCT)：一个设备控制表表征一个设备，控制表中是设备的各项属性</p>
<p>控制器控制表( COCT)：COCT 与 DCT 一 一对应关系，DCT 需要一个表项来表示控制器 即一个指向控制器控制表的指针</p>
<p>通道控制表(CHCT)：CHCT 提供服务的那几个设备控制器</p>
<p>系统设备表(SDT)：记录已经连接到系统中的所有物理设备的情况</p>
<h4 id="设备分配的策略"><a href="#设备分配的策略" class="headerlink" title="设备分配的策略"></a>设备分配的策略</h4><p>分配原则 充分发挥设备效率，避免进程死锁</p>
<h5 id="分配方式"><a href="#分配方式" class="headerlink" title="分配方式"></a>分配方式</h5><h6 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h6><p>系统一次性的把设备分配给相应作业，直到作业结束</p>
<p>优点：没有死锁问题</p>
<p>缺点：降低了设备使用率</p>
<h6 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h6><p>进程执行过程中根据执行需要进行分配</p>
<p>优点提高了设备利用率</p>
<p>缺点分配算法不当可能导致死锁</p>
<h5 id="设备分配算法"><a href="#设备分配算法" class="headerlink" title="设备分配算法"></a>设备分配算法</h5><p>先请求先分配(类似于先来先服务)</p>
<p>优先级高者优先</p>
<p>独占设备一般使用静态分配，共享设备一般使用动态分配</p>
<h3 id="IO-调度"><a href="#IO-调度" class="headerlink" title="IO 调度"></a>IO 调度</h3><h4 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h4><p>独占设备：一个时段只能分配给一个进程（如打印机）</p>
<p>共享设备： 可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备而微观上交替使用</p>
<p>虚拟设备： 采用 SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用 SPOOLing 技术实现的共享打印机）</p>
<h4 id="设备分配的安全性"><a href="#设备分配的安全性" class="headerlink" title="设备分配的安全性"></a>设备分配的安全性</h4><h5 id="安全分配方式"><a href="#安全分配方式" class="headerlink" title="安全分配方式"></a>安全分配方式</h5><p>进程发出 IO 请求后便进入阻塞态直到 IO 结束才被唤醒</p>
<p>优点：设备分配安全</p>
<p>缺点：CPU 和 IO 设备串行工作</p>
<h5 id="不安全分配方式"><a href="#不安全分配方式" class="headerlink" title="不安全分配方式"></a>不安全分配方式</h5><p>进程发出 IO 请求后继续允许，需要时发出第二个，第三个 IO 请求</p>
<p>优点：进程推进迅速</p>
<p>缺点：可能产生死锁</p>
<h4 id="逻辑设备名到物理设备名的映射"><a href="#逻辑设备名到物理设备名的映射" class="headerlink" title="逻辑设备名到物理设备名的映射"></a>逻辑设备名到物理设备名的映射</h4><h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><p>提高设备分配的灵活性和利用率</p>
<p>实现 IO 重定向</p>
<p>引入设备独立性</p>
<h5 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h5><p>引入逻辑设备表(LUT) , 用来将逻辑设备名映射为物理设备名</p>
<h5 id="建立方式"><a href="#建立方式" class="headerlink" title="建立方式"></a>建立方式</h5><p>整个系统设置一张 LUT , 所有设备分配情况都记录在这张上表（单用户设备 ）</p>
<p>每个用户建立—张 LUT , 分别记录设备的分配情况</p>
<h3 id="SPOOLING-技术（假脱机技术）"><a href="#SPOOLING-技术（假脱机技术）" class="headerlink" title="SPOOLING 技术（假脱机技术）"></a>SPOOLING 技术（假脱机技术）</h3><p>目的：缓解 CPU 与 IO 的速度差异矛盾</p>
<p>要实现 SPOOLing 技术，必须要有多道程序技术的支持</p>
<h4 id="输入井和输出井"><a href="#输入井和输出井" class="headerlink" title="输入井和输出井"></a>输入井和输出井</h4><p>输入井用来收容 IO 设备的数据</p>
<p>输出井用来模拟输出时的磁盘</p>
<h4 id="输入缓冲区和输出缓冲区"><a href="#输入缓冲区和输出缓冲区" class="headerlink" title="输入缓冲区和输出缓冲区"></a>输入缓冲区和输出缓冲区</h4><p>输入缓冲区：暂存由输入设备送来的数据</p>
<p>输出缓冲区：暂存从输出井送来的设备</p>
<h4 id="输入进程和输出进程"><a href="#输入进程和输出进程" class="headerlink" title="输入进程和输出进程"></a>输入进程和输出进程</h4><p>输入进程 模拟脱机输入时的外围控制机，将用户要求的数据从鞘入机通过输入缓冲区送到输入井中，当 CPU 需要数据，直接将鞘出井中的数据送入内存</p>
<p>输出进程 模拟脱机输出时的外围控制机，把用户要求轮出的数据先从内存送到轮出井中，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备</p>
<h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><p>提高了 IO 速度</p>
<p>独占设备变成了共享设备</p>
<p>实现了虚拟设备功能</p>
<p>通俗一点就是，如果设备被占用，我们就先把数据暂存—下，等到设备空闲了就把这些数据输送到设备中</p>
<h2 id="缓存与缓冲区对比"><a href="#缓存与缓冲区对比" class="headerlink" title="缓存与缓冲区对比"></a>缓存与缓冲区对比</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>都介于高速设备和低速设备之间</p>
<h3 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h3><h4 id="存放数据"><a href="#存放数据" class="headerlink" title="存放数据"></a>存放数据</h4><p>高速缓存：存放的是低速设备上的某些数据的复制数据</p>
<p>缓冲区：存放的是低速设备传递给高速设备的数据，这些数据在低速设备上不一定有备份，这些数据再从缓冲区传送到高速设备</p>
<h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><p>高速缓存：高速缓存存放的是高速设备经常要访问的数据，如高速缓存中数据不在，高速设备就要访问低速设备</p>
<p>高速设备和低速设备的通信都要经过缓冲区，高速设备永远不会去直接访问低速设备</p>

      
    </div>
    
  </div>
  
    
    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/docs/2021/12/08/git%E4%BD%BF%E7%94%A8/">
                    git使用
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/docs/2021/11/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%83%8C%E8%AF%B5/">
                    操作系统背诵
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-text">一、计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">操作系统的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">操作系统的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">操作系统的特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E8%80%83%E7%82%B9"><span class="toc-text">重要考点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB"><span class="toc-text">共享</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="toc-text">互斥共享方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="toc-text">同时访问方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F"><span class="toc-text">虚拟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-text">异步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="toc-text">操作系统的目标和功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-text">管理功能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86"><span class="toc-text">处理机管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-text">存储器管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">文件管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-text">设备管理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%8A%9F%E8%83%BD"><span class="toc-text">接口功能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%8E%A5%E5%8F%A3"><span class="toc-text">命令接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">程序接口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%A8%E4%BD%9C%E6%89%A9%E5%85%85%E6%9C%BA%E5%99%A8"><span class="toc-text">操作系统用作扩充机器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E6%80%9D%E6%83%B3"><span class="toc-text">封装思想</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-text">操作系统的发展与分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%B7%A5%E6%93%8D%E4%BD%9C%E9%98%B6%E6%AE%B5"><span class="toc-text">手工操作阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5"><span class="toc-text">批处理阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">单道批处理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">多道批处理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">分时操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">实时操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="toc-text">分布式计算机系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">个人计算机操作系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-text">操作系统的运行环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C"><span class="toc-text">程序运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">操作的运行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%80%A7%E8%B4%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">CPU 执行的两种性质程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8"><span class="toc-text">内核</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-text">中断与异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%EF%BC%88%E5%A4%96%E4%B8%AD%E6%96%AD%EF%BC%89"><span class="toc-text">中断（外中断）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8-%E5%86%85%E4%B8%AD%E6%96%AD"><span class="toc-text">异常(内中断)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8E%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-text">用户态与内核态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E3%80%81%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-text">内核态、用户态的切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%86%85%E6%A0%B8%E4%B8%8E%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-text">大内核与微内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%86%85%E6%A0%B8"><span class="toc-text">大内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-text">微内核</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-text">二、进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-text">进程的概念和特征</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">进程的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">进程的特征</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-text">进程的状态与转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-text">状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text">相互转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">进程的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="toc-text">进程的终止</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E5%94%A4%E9%86%92"><span class="toc-text">进程的阻塞和唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%8E%9F%E8%AF%AD%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">阻塞原语执行过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%94%A4%E9%86%92%E5%8E%9F%E8%AF%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">唤醒原语的执行过程</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-text">进程切换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-text">进程的组织</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-text">进程控制块</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E4%BF%A1%E6%81%AF"><span class="toc-text">进程描述信息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E7%AE%A1%E7%90%86%E4%BF%A1%E6%81%AF"><span class="toc-text">进程控制和管理信息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E6%B8%85%E5%8D%95"><span class="toc-text">资源分配清单</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="toc-text">处理机相关信息</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%AE%B5"><span class="toc-text">程序段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-text">数据段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-text">进程的组织方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-text">链接方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F"><span class="toc-text">索引方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">进程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-text">共享存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-text">消息传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-text">管道通信</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">线程概念和多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">线程基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">线程与进程的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-text">调度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%A5%E6%9C%89%E8%B5%84%E6%BA%90"><span class="toc-text">拥有资源</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%80%A7"><span class="toc-text">并发性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%BC%80%E9%94%80"><span class="toc-text">系统开销</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%92%8C%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90"><span class="toc-text">地址空间和其他资源</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%96%B9%E9%9D%A2"><span class="toc-text">通信方面</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-text">线程属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">线程的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">多线程模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-text">处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">调度的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-text">调度的层次</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-text">三级调度的联系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA%E3%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B"><span class="toc-text">调度时机、切换与过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E5%88%87%E6%8D%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">不能切换的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E5%88%87%E6%8D%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">可以切换的情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">进程调度的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%89%A5%E5%A4%BA%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-text">非剥夺调度方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%A5%E5%A4%BA%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-text">剥夺调度方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%87%86%E5%88%99"><span class="toc-text">调度的基本准则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%E6%80%81%E4%B8%8E%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-text">进程的挂起态与七状态模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9A%82%E6%97%B6%E8%B0%83%E5%88%B0%E5%A4%96%E5%AD%98%E7%AD%89%E5%BE%85%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%BA%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81%EF%BC%88%E6%8C%82%E8%B5%B7%E6%80%81%EF%BC%89"><span class="toc-text">暂时调到外存等待的进程状态为挂起状态（挂起态）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E2%80%9C%E5%92%8C%E2%80%9C%E9%98%BB%E5%A1%9E%EF%BC%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">挂起“和“阻塞＂的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">典型调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95"><span class="toc-text">先来先服务算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="toc-text">短作业优先算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">优先级调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E7%B1%BB"><span class="toc-text">优先级分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%BE%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-text">优先级设置原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E9%A5%A5%E9%A5%BF%E7%8E%B0%E8%B1%A1"><span class="toc-text">产生饥饿现象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E6%8A%A2%E5%8D%A0%E5%BC%8F%E7%9A%84%EF%BC%8C%E4%B9%9F%E6%9C%89%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E7%9A%84"><span class="toc-text">有抢占式的，也有非抢占式的</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">高响应比调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E7%AE%97%E6%B3%95"><span class="toc-text">时间片轮转算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E8%9E%8D%E5%90%88%E5%89%8D%E9%9D%A2%E5%87%A0%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">多级反馈队列调度算法（融合前面几种算法）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3"><span class="toc-text">实现思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E2%80%9C%E9%A5%A5%E9%A5%BF%E2%80%9C%E7%8E%B0%E8%B1%A1"><span class="toc-text">产生“饥饿“现象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F"><span class="toc-text">抢占式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="toc-text">临界资源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B"><span class="toc-text">临界资源的访问过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-text">同步</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%81%B5%E5%BE%AA%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">遵循的原则</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-text">互斥</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-text">实现临界区互斥的基本方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">软件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95"><span class="toc-text">单标志法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="toc-text">双标志先检查法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="toc-text">双标志后检查法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9A%AE%E7%89%B9%E6%A3%AE%E7%AE%97%E6%B3%95"><span class="toc-text">皮特森算法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">硬件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%B3%95"><span class="toc-text">中断屏蔽法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%8C%87%E4%BB%A4%E6%B3%95"><span class="toc-text">硬件指令法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%BD%A2%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">整形信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">记录型信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5"><span class="toc-text">利用信号量实现同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5"><span class="toc-text">利用信号量实现互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-text">利用信号量实现前驱关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-text">管程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%88%90"><span class="toc-text">组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-text">基本特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">死锁的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">死锁的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">死锁产生的原因</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">死锁产生的必要条件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-text">死锁的处理策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-text">死锁预防</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">避免死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E5%8F%8A%E8%A7%A3%E9%99%A4"><span class="toc-text">死锁的检测及解除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2-1"><span class="toc-text">死锁预防</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6"><span class="toc-text">破坏互斥条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E4%B8%8D%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6"><span class="toc-text">破坏不剥夺条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E8%AF%B7%E6%B1%82%E5%B9%B6%E4%BF%9D%E6%8C%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">破坏请求并保持条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="toc-text">破坏循环等待条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-text">死锁避免</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81"><span class="toc-text">系统安全状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-text">银行家算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="toc-text">死锁的检测和解除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-text">资源分配图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%AE%9A%E7%90%86"><span class="toc-text">死锁定理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4"><span class="toc-text">死锁解除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E3%80%81%E9%A5%A5%E9%A5%BF%E3%80%81%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">死锁、饥饿、死循环的区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">三、内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5"><span class="toc-text">内存管理概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E8%A6%81%E6%B1%82"><span class="toc-text">内存管理的基本原理和要求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">内存管理的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-text">程序的装入和链接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-text">创建步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">链接的类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A3%85%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">装入模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5"><span class="toc-text">绝对装入</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A3%85%E5%85%A5%EF%BC%88%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%EF%BC%89"><span class="toc-text">可重定位装入（静态重定位）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A3%85%E5%85%A5%EF%BC%88%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%EF%BC%89"><span class="toc-text">动态运行时装入（动态重定位）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-text">逻辑地址空间与物理地址空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="toc-text">内存保护</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-text">覆盖与交换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96"><span class="toc-text">覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2"><span class="toc-text">交换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E6%83%B3"><span class="toc-text">思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8D%A2%E5%87%BA"><span class="toc-text">换出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8D%A2%E5%85%A5"><span class="toc-text">换入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-text">结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">交换存在的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-text">单一连续分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-text">固定分区分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%8D%E7%B1%BB"><span class="toc-text">种类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-4"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-text">动态分区分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-5"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-4"><span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">动态分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-text">首次适应算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-text">最佳适应算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%88%E6%9C%80%E5%A4%A7%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">最坏适应算法（最大适应算法）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%88%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">邻近适应算法（首次适应算法）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">非连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">基本分页存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-text">设计思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">分页存储的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%92%8C%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F"><span class="toc-text">页面和页面大小</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-text">地址结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="toc-text">页表</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-text">基本地址变换机构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F"><span class="toc-text">计算方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">分页管理存在的问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%84%E6%88%90-1"><span class="toc-text">组成</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-text">具有快表的地址变换机构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E8%AE%BF%E5%AD%98%E6%AC%A1%E6%95%B0"><span class="toc-text">访问一个逻辑地址的访存次数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-text">变换过程</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-text">两级页表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">基本分段存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E5%8F%91%E7%82%B9"><span class="toc-text">出发点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-text">分段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8"><span class="toc-text">段表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84%EF%BC%88%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="toc-text">地址变换机构（变换过程）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4"><span class="toc-text">段的共享与保护</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB-1"><span class="toc-text">共享</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">保护机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">段页式管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B3-1"><span class="toc-text">思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84-1"><span class="toc-text">地址结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-text">实现地址变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="toc-text">地址变换方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E4%B8%8E%E5%88%86%E9%A1%B5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">分段与分页的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E4%B8%8E%E5%88%86%E9%A1%B5%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">分段与分页优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86"><span class="toc-text">分页管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E7%AE%A1%E7%90%86"><span class="toc-text">分段管理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">虚拟内存的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">传统存储管理方式的特征</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E6%80%A7"><span class="toc-text">一次性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A9%BB%E7%95%99%E6%80%A7"><span class="toc-text">驻留性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-text">局部性原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-text">时间局部性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-text">空间局部性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-text">虚拟存储器的定义和特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-text">特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">虚拟内存技术的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81"><span class="toc-text">硬件支持</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">请求分页管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="toc-text">页表机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84"><span class="toc-text">缺页中断机构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-4"><span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-text">地址变换机构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">易混知识点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-OPT"><span class="toc-text">最佳置换算法 ( OPT )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-FIFO"><span class="toc-text">先进先出页面置换算法(FIFO)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-6"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-5"><span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Belady-%E5%BC%82%E5%B8%B8"><span class="toc-text">Belady 异常</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8-LRU-%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">最近最久未使用( LRU ) 置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-7"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-6"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9F-CLOCK-%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">时钟(CLOCK)置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-8"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-7"><span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E5%9E%8B-CLOCK-%E7%AE%97%E6%B3%95"><span class="toc-text">改进型 CLOCK 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E8%BF%87%E7%A8%8B"><span class="toc-text">扫描过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-9"><span class="toc-text">优点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">页面分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0"><span class="toc-text">考虑因素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E9%85%8D%E5%B1%80%E9%83%A8%E7%BD%AE%E6%8D%A2"><span class="toc-text">固定分配局部置换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E9%85%8D%E5%85%A8%E5%B1%80%E7%BD%AE%E6%8D%A2"><span class="toc-text">可变分配全局置换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E9%85%8D%E5%B1%80%E9%83%A8%E7%BD%AE%E6%8D%A2"><span class="toc-text">可变分配局部置换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-text">调入页面的时机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E8%B0%83%E9%A1%B5%E7%AD%96%E7%95%A5"><span class="toc-text">预调页策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%E7%AD%96%E7%95%A5"><span class="toc-text">请求调页策略</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E4%BD%95%E5%A4%84%E8%B0%83%E5%85%A5%E9%A1%B5"><span class="toc-text">从何处调入页</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8"><span class="toc-text">抖动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-text">原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-text">工作集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-1"><span class="toc-text">文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-text">4.1 文件系统基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">文件的相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%AE%9A%E4%B9%89"><span class="toc-text">相关定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">文件的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B9"><span class="toc-text">数据项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95"><span class="toc-text">记录</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-text">文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">文件的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">文件的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-text">创建文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-text">写文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-text">读文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E4%BD%8D%EF%BC%88%E6%96%87%E4%BB%B6%E5%AF%BB%E5%9D%80%EF%BC%89"><span class="toc-text">文件重定位（文件寻址）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-text">删除文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%AA%E6%96%AD%E6%96%87%E4%BB%B6"><span class="toc-text">截断文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="toc-text">文件的打开与关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#open-%E8%AF%B7%E6%B1%82"><span class="toc-text">open 请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B3%E8%81%94%E4%BF%A1%E6%81%AF"><span class="toc-text">文件关联信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-text">文件的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6"><span class="toc-text">无结构文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%EF%BC%88%E8%AE%B0%E5%BD%95%E5%BC%8F%E6%96%87%E4%BB%B6%EF%BC%89"><span class="toc-text">有结构文件（记录式文件）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-text">顺序文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-text">索引文件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E9%95%BF%E8%AE%B0%E5%BD%95%E6%96%87%E4%BB%B6"><span class="toc-text">定长记录文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E8%AE%B0%E5%BD%95%E6%96%87%E4%BB%B6"><span class="toc-text">变长记录文件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-text">索引顺序文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%96%87%E4%BB%B6%E6%88%96%E6%95%A3%E5%88%97%E6%96%87%E4%BB%B6"><span class="toc-text">直接文件或散列文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">目录结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9"><span class="toc-text">文件控制块和索引结点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97-FCB"><span class="toc-text">文件控制块 ( FCB )</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E4%BF%A1%E6%81%AF"><span class="toc-text">包含信息</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9"><span class="toc-text">索引结点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="toc-text">磁盘索引节点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E5%90%8E%E5%86%85%E5%AD%98%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E5%A2%9E%E5%8A%A0%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">文件打开后内存索引节点增加的内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-1"><span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB"><span class="toc-text">目录结构分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">单机目录结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">两级目录结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">多级目录结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">无环图目录结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-text">文件共享</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%EF%BC%88%E7%A1%AC%E9%93%BE%E6%8E%A5%EF%BC%89"><span class="toc-text">基于索引节点的共享方式（硬链接）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%AC%A6%E5%8F%B7%E9%93%BE%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%EF%BC%88%E8%BD%AF%E9%93%BE%E6%8E%A5-%EF%BC%89"><span class="toc-text">利用符号链实现文件共享（软链接 ）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-text">文件保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-1"><span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">访问类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-text">访问控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E8%BF%9B%E8%A1%8C%E6%8E%A7%E5%88%B6"><span class="toc-text">根据用户身份进行控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B2%BE%E7%AE%80%E8%AE%BF%E9%97%AE%E5%88%97%E8%A1%A8"><span class="toc-text">精简访问列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%A3%E4%BB%A4"><span class="toc-text">口令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%86%E7%A0%81"><span class="toc-text">密码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.2 文件系统的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-text">文件层结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">目录实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%88%97%E8%A1%A8"><span class="toc-text">线性列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-text">文件实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">文件的分配方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-text">连续分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D"><span class="toc-text">链接分配</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5"><span class="toc-text">隐式链接</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E9%93%BE%E6%8E%A5"><span class="toc-text">显示链接</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="toc-text">索引分配</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-text">优化机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-text">文件存储空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E5%9D%97%E7%AE%A1%E7%90%86"><span class="toc-text">空闲块管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%8D%E7%A4%BA%E5%9B%BE"><span class="toc-text">位示图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-text">成组链接法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BB%84%E7%BB%87%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="toc-text">磁盘组织与管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="toc-text">磁盘结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%88%86%E7%B1%BB"><span class="toc-text">磁盘分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">磁盘调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%97%B6%E9%97%B4%E7%BB%84%E6%88%90"><span class="toc-text">读写时间组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-1"><span class="toc-text">磁盘调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E5%8E%BB-FCFS"><span class="toc-text">先来先服务算去 (FCFS )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E6%89%BE%E6%97%B6%E9%97%B4%E6%9C%89%E9%99%90%E7%AE%97%E6%B3%95-SSTF"><span class="toc-text">最短寻找时间有限算法(SSTF)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F-SCAN-%E7%AE%97%E6%B3%95"><span class="toc-text">扫描(SCAN) 算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95-C-SCAN"><span class="toc-text">循环扫描算法 ( C-SCAN)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LOOK-%E4%B8%8E-C-LOOK-%E7%AE%97%E6%B3%95"><span class="toc-text">LOOK 与 C-LOOK 算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E7%9B%98%E9%9D%A2%E4%BA%A4%E6%9B%BF%E7%BC%96%E5%8F%B7"><span class="toc-text">对盘面交替编号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-text">磁盘的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">磁盘初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%8E%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">低级格式化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E5%9D%97"><span class="toc-text">引导块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9D%8F%E5%9D%97"><span class="toc-text">坏块</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">处理方式</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88IO%EF%BC%89%E7%AE%A1%E7%90%86"><span class="toc-text">输入输出（IO）管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-text">IO 管理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-0-%E8%AE%BE%E5%A4%87"><span class="toc-text">I&#x2F; 0 设备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E7%9A%84%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87"><span class="toc-text">人机交互的外部设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87"><span class="toc-text">存储设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E8%AE%BE%E5%A4%87"><span class="toc-text">网络通信设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87%E5%88%86%E7%B1%BB"><span class="toc-text">传输速率分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2%E5%8D%95%E4%BD%8D%E5%88%86%E7%B1%BB"><span class="toc-text">信息交换单位分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87"><span class="toc-text">块设备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87"><span class="toc-text">字符设备</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-0-%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">I&#x2F;0 控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">程序直接控制方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">中断驱动方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA-%E6%96%B9%E5%BC%8F"><span class="toc-text">DMA 方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-5"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">寄存器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">通道控制方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA-%E4%B8%8E%E9%80%9A%E9%81%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">DMA 与通道的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">I&#x2F;O 子系统的层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E5%88%92%E5%88%86"><span class="toc-text">层次划分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6"><span class="toc-text">设备独立性软件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%90%8D%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">使用逻辑设备名的好处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-text">主要功能</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">设备驱动程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-text">中断处理程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87"><span class="toc-text">硬件设备</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">设备控制的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">设备控制器的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8E-CPU-%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-text">设备控制器与 CPU 的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%BA%BF"><span class="toc-text">信号线</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-text">设备控制器与设备的接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91"><span class="toc-text">IO 控制逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-text">IO 核心子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-text">IO 子系统概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-%E8%B0%83%E5%BA%A6%E6%A6%82%E5%BF%B5"><span class="toc-text">IO 调度概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">高速缓存与缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-text">磁盘高速缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="toc-text">在内存中的两种形式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-text">引入缓冲区的目的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">实现方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB-1"><span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BC%93%E5%86%B2"><span class="toc-text">单缓冲</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-text">双缓冲</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2"><span class="toc-text">循环缓冲</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-text">缓冲池</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-1"><span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-text">设备分配与回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="toc-text">设备类型分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">设备分配的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-text">设备分配的策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">分配方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%99%E6%80%81"><span class="toc-text">静态</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%A8%E6%80%81"><span class="toc-text">动态</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">设备分配算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-%E8%B0%83%E5%BA%A6"><span class="toc-text">IO 调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D"><span class="toc-text">设备分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">设备分配的安全性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">安全分配方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">不安全分配方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%90%8D%E5%88%B0%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%90%8D%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-text">逻辑设备名到物理设备名的映射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84"><span class="toc-text">目的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-1"><span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E6%96%B9%E5%BC%8F"><span class="toc-text">建立方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPOOLING-%E6%8A%80%E6%9C%AF%EF%BC%88%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF%EF%BC%89"><span class="toc-text">SPOOLING 技术（假脱机技术）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%BA%95%E5%92%8C%E8%BE%93%E5%87%BA%E4%BA%95"><span class="toc-text">输入井和输出井</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">输入缓冲区和输出缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BE%93%E5%87%BA%E8%BF%9B%E7%A8%8B"><span class="toc-text">输入进程和输出进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-6"><span class="toc-text">特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AF%B9%E6%AF%94"><span class="toc-text">缓存与缓冲区对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-text">相同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C"><span class="toc-text">不同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE"><span class="toc-text">存放数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84-1"><span class="toc-text">目的</span></a></li></ol></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="Hide"  title="Show or Hide Table of Contents">

    <script>
        yiliaConfig.toc = ["Hide", "Show", !!"false"];
    </script>





    <div class="scroll" id="post-nav-button">
        
            <a href="/docs/2021/12/08/git%E4%BD%BF%E7%94%A8/" title="Pre: git使用">
                <i class="iconfont icon-jiantouzuo"></i>
            </a>
        
        <a title="Mini Archives"><i class="iconfont icon-home"></i></a>
        
            <a href="/docs/2021/11/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%83%8C%E8%AF%B5/" title="Next: 操作系统背诵">
                <i class="iconfont icon-jiantouyou"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/docs/2023/03/12/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96AMD,CMD,ES6%20MODULE/">前端模块化AMD,CMD,ES6 MODULE</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2023/03/11/Symbol%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89%EF%BC%8Cyield,%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0/">Symbol（迭代器），yield,生成器函数</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2023/03/05/%E7%96%91%E9%97%AE/">疑问</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2023/03/04/%E5%BE%85%E6%95%B4%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9/">待整理知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2023/02/17/%E8%B7%A8%E5%9F%9F/">跨域</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2023/02/16/nginx/">nginx</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2023/02/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">计算机组成思维导图</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">计算机网络思维导图</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">操作系统思维导图</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">数据结构思维导图</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/02/19/%E6%9C%89%E7%82%B9%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0/">有点问题学习</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/02/13/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">实用工具</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/02/13/less%E4%BD%BF%E7%94%A8/">less使用</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/02/07/vscode/">vscode</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/28/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/">异步与同步</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/%E5%87%BD%E6%95%B0%E9%9B%86%E5%90%88/">函数集合</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">个人总结</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/%E6%AF%94%E8%BE%83%E5%81%8F/">比较偏</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/xss%E5%92%8Ccsrf%20%E4%BB%8B%E7%BB%8D/">xss和csrf 介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%EF%BC%88%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%EF%BC%89/">打包工具（构建工具）</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/vue%E7%90%86%E8%AE%BA/">vue理论</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/node/">node</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/js%E7%90%86%E8%AE%BA/">js理论</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/jS/">jS</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/jquery/">jquery</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/http/">http</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/html%E7%90%86%E8%AE%BA/">html理论</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/html-css/">html-css</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/css%E5%B8%83%E5%B1%80/">css布局</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/fetch%E5%92%8Caxios%E5%92%8Cneedle/">fetch和axios和needle</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/ES6/">ES6</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/DOM/">DOM</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/css%E7%90%86%E8%AE%BA/">css理论</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/css3/">css3</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/23/BOM/">BOM</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/02/npm%EF%BC%8Cyarn%20,pnpm%E7%AD%89%E7%9B%B8%E5%85%B3/">npm，yarn ,pnpm等相关</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/02/hexo%E4%BD%BF%E7%94%A8/">hexo使用</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/02/%E8%AF%AD%E9%9B%80%E4%BD%BF%E7%94%A8/">语雀使用</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/01/win11%E4%BD%BF%E7%94%A8/">win11使用</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2022/01/01/%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%20%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85/">学习内容 要做的事情</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2021/12/08/git%E4%BD%BF%E7%94%A8/">git使用</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2021/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">计算机操作系统</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2021/11/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%83%8C%E8%AF%B5/">操作系统背诵</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2021/11/14/%E4%BD%9C%E6%96%87%E8%8C%83%E6%96%87/">作文范文</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2021/11/14/%E4%BD%9C%E6%96%87%E6%A8%A1%E6%9D%BF/">作文模板</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2021/11/14/%E8%8B%B1%E8%AF%AD%E4%BD%9C%E6%96%87%E7%A7%AF%E7%B4%AF/">英语作文积累</a></li><li class="post-list-item"><a class="post-list-link" href="/docs/2021/09/16/%F0%9F%92%A1%201%20%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%AC%E8%AF%AD%E9%9B%80%E6%96%87%E6%A1%A3/">💡 1 分钟玩转语雀文档</a></li></ul>




    <script>
        ""
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="iconfont icon-copyright"></i> 
                2023 John Doe
            </div>
        </div>
    </div>
</footer>
    </div>
    
<script data-main="/docs/js/main.js" src="/docs/plugins/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = "5";
                var backgroundimg = "url(/docs//background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>

<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="iconfont icon-shangjiantou"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="iconfont icon-xiajiantou"></i></a>
</div>
  </div>
</body>
</html>