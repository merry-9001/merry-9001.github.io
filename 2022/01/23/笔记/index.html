<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="John Doe" />
<meta name="referrer" content="no-referrer" />

<meta name="description" content="Vue 部分相关的面试题vue 传值‘ 1 父 -&gt;子 传值   使用 props 接受 子组件 12345 props: &amp;#123;   dialog: Object,   formData: Object &amp;#125;,this.$emit(&quot;func&quot;, this.msg);  父组件 12345678910  &lt;PersonDialog :dialog&#x3D;&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="笔记">
<meta property="og:url" content="http://example.com/2022/01/23/%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="后知后觉的个人主页">
<meta property="og:description" content="Vue 部分相关的面试题vue 传值‘ 1 父 -&gt;子 传值   使用 props 接受 子组件 12345 props: &amp;#123;   dialog: Object,   formData: Object &amp;#125;,this.$emit(&quot;func&quot;, this.msg);  父组件 12345678910  &lt;PersonDialog :dialog&#x3D;&amp;">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-01-23T08:11:11.000Z">
<meta property="article:modified_time" content="2022-04-28T02:37:35.858Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="前端知识">
<meta name="twitter:card" content="summary">

<link rel="shortcut icon" href="/img/favicon.ico">
<link href="/css/bootstrap.css" rel="stylesheet">
<link href="/css/person.css"  rel="stylesheet">
<link href="//at.alicdn.com/t/font_2822169_7n9pu9ptxz8.css" rel="stylesheet">

    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">



    <script src="/plugins/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link href="/css/style.css?v=1" rel="stylesheet">

<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>
    笔记 | 
    后知后觉的个人主页
</title>

<script src="/plugins/jquery.min.js"></script>
<script src="/plugins/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: "true",
        isHome: "false",
        isPost: "true",
        isArchive: "false",
        isTag: "false",
        isCategory: "false",
        fancybox_js: "/plugins/jquery.fancybox.min.js",
        scrollreveal: "/plugins/scrollreveal.min.js",
        search: ""
    }
</script>



    <script> yiliaConfig.rootUrl = "\/";</script>


<meta name="generator" content="Hexo 6.0.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/index.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>

        

        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/tags">标签云</a></li>
                        
                            <li><a href="/about">关于我</a></li>
                        
                        </ul>
                    </nav>
                </section>
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger hide"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/index.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/tags">标签云</a></li>
                
                    <li><a href="/about">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me"/>
</nav>
      <div class="body-wrap"><div class="post"></div>
<article id="post-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/01/23/%E7%AC%94%E8%AE%B0/" class="article-date">
      <time datetime="2022-01-23T08:11:11.000Z" itemprop="datePublished">2022-01-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      笔记
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/" rel="tag">前端知识</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Vue-部分相关的面试题"><a href="#Vue-部分相关的面试题" class="headerlink" title="Vue 部分相关的面试题"></a>Vue 部分相关的面试题</h1><p>vue 传值‘</p>
<p>1 父 -&gt;子 传值   使用 props 接受</p>
<p>子组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> props: &#123;</span><br><span class="line">   dialog: Object,</span><br><span class="line">   formData: Object</span><br><span class="line"> &#125;,</span><br><span class="line">this.$emit(&quot;func&quot;, this.msg);</span><br></pre></td></tr></table></figure>

<p>父组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  &lt;PersonDialog :dialog=&quot;dialog&quot; :formData=&quot;formData&quot; @func=&quot;getMsgFormSon&quot; @update=&quot;getPerson&quot;&gt;&lt;/PersonDialog&gt;</span><br><span class="line">     dialog: &#123;</span><br><span class="line">       show: false,</span><br><span class="line">       title: &quot;&quot;,</span><br><span class="line">       option: &quot;&quot;</span><br><span class="line">     &#125;,</span><br><span class="line"></span><br><span class="line">getMsgFormSon(data) &#123;</span><br><span class="line">      this.formData.project_src + data;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>

<p>2 子-&gt;父 传值     父亲写事件函数   子 $emit 触发 传值</p>
<p>3 兄弟传值  $bus 中转站</p>
<p>4 如果组件之间 关系很远 是很多组件都要用的值  <strong>vuex</strong></p>
<p><strong>vuex</strong>   <strong>就是一个全局状态数据管理</strong> 简单来说 他的数据类似全局变量 哪个组件都可以使用</p>
<p><strong>在项目中使用 vuex</strong></p>
<ol>
<li> 下载 vuex 包 并导入 use 一下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 需要 new 一下 写上全局数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// store</span><br><span class="line">new Vuex.Store(&#123;</span><br><span class="line">state: &#123;</span><br><span class="line">  count:1 //这个count 就是全局的数据</span><br><span class="line">&#125;,</span><br><span class="line">mutations: &#123;</span><br><span class="line">&#125;,</span><br><span class="line">actions: &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li> 需要挂载到 new  vue 上</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>这个步骤是写死的   你可以记一下 下载使用脚手架直接就可以选 vuex</strong></p>
<p><strong>他的使用逻辑是什么？</strong></p>
<p>在 store 里面的   state   写的数据   是全局数据   所有组件都可以使用</p>
<p><strong>使用逻辑</strong></p>
<p><strong>操作全局 vuex 的 state 数据</strong></p>
<p>正常情况   必须  dispatch (action)—&gt;action 去 commit 触发 mutation–》mutation 里面才能修改 state 全局数据</p>
<p>action—&gt;mutation—&gt;修改 state</p>
<p>其他情况 你也可以跳过 action   去   直接 commit mutation–》修改 state 全局数据</p>
<h2 id="vuex-怎么合理规范管理数据-及-mutations-和-actions-区别"><a href="#vuex-怎么合理规范管理数据-及-mutations-和-actions-区别" class="headerlink" title="vuex 怎么合理规范管理数据,及 mutations 和 actions 区别"></a>vuex 怎么合理规范管理数据,及 mutations 和 actions 区别</h2><blockquote>
<p>不同于 redux 只有一个 action, vuex 单独拎出了一个 mutations,   它认为 更新数据必须是同步的, 也就是只要调用了提交数据方法, 在 mutation 里面才可以修改数据</p>
</blockquote>
<blockquote>
<p>那么如果我们想做 异步请求,怎么做?   这里 vuex 提供了专门做异步请求的模块,action, 当然 action 中也可以做同步操作, 只不过 分工更加明确, 所有的数据操作 不论是同步还是异步 都可以在 action 中完成,</p>
</blockquote>
<blockquote>
<p>mutation 只负责接收状态, 同步完成 <strong><code>数据快照</code></strong></p>
</blockquote>
<blockquote>
<p>所以可以认为</p>
</blockquote>
<blockquote>
<p>state =&gt; 负责存储状态</p>
</blockquote>
<blockquote>
<p>mutations =&gt; 负责同步更新状态</p>
</blockquote>
<blockquote>
<p><strong>actions =&gt; 负责获取 处理数据（如果有异步操作必须在 action 处理 再到 mutation）</strong>, 提交到 mutation 进行状态更新</p>
</blockquote>
<h2 id="vuex-模块化-module-管理-使用的时候有注意事项"><a href="#vuex-模块化-module-管理-使用的时候有注意事项" class="headerlink" title="vuex 模块化 module 管理,使用的时候有注意事项"></a>vuex 模块化 module 管理,使用的时候有注意事项</h2><blockquote>
<p>分析: 此题考查 当 vuex 维护的数据越来越复杂的时候, 模块化的解决方案</p>
</blockquote>
<blockquote>
<p><strong><code>解析</code></strong>:使用单一的状态树，应用的所有状态都会**<code>集中在一个比较大的对象</code><strong>上面，随着项目需求的不断增加，状态树也会变得越来越臃肿，增加了状态树维护的复杂度,而且代码变得沉长；因此我们需要</strong><code>modules(模块化)</code><strong>来为我们的状态树</strong><code>分隔</code>**成不同的模块，每个模块拥有自己的 state，getters，mutations，actions；而且允许每个 module 里面嵌套子 module；如下：</p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store</span><br></pre></td></tr></table></figure>
</blockquote>
<pre><code>├── index.js          # 我们组装模块并导出 store 的地方
├── actions.js        # 根级别的 action
├── mutations.js      # 根级别的 mutation
├── state.js          # 根级别的 state
└── modules
    ├── module1.js   # 模块1的state树
    └── module2.js   # 模块2的state树
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那么 组件中怎么使用子模块的action 和 mutations</span><br><span class="line"></span><br><span class="line">你写一遍 步骤基本是死的 熟悉就好了</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">// 你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文</span><br><span class="line"> methods:&#123;</span><br><span class="line">     ...mapMutations(&#x27;m1&#x27;, [&#x27;loginMutation&#x27;]),</span><br><span class="line">     add()&#123;</span><br><span class="line">       console.log(&#x27;add&#x27;,this)</span><br><span class="line">      //  this.$store.commit(&quot;m1/loginMutation&quot;)</span><br><span class="line">      // 或者下面的  先mapMutations 相当于帮你写了commit</span><br><span class="line">      // this.loginMutation()</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">     // 这句话的意思是 直接 解构出 全局 m1模块下的 loginMutation</span><br><span class="line">    // 把loginMutation 放到this上 并且帮你写好了 commit</span><br><span class="line">    // 相当于帮你简化了代码</span><br><span class="line">     ...mapMutations(&#x27;m1&#x27;, [&#x27;loginMutation&#x27;]),</span><br><span class="line">       //不是modules的直接写  ...mapMutations( [&#x27;loginMutaton])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此题具体考查 Vuex 虽然是一个公共状态, 但是公共状态还可以切分成若干个子状态模块, 也就是 moduels,</p>
</blockquote>
<blockquote>
<p>解决当我们的状态树过于庞大和复杂时的一种解决方案.   但是笔者认为, 一旦用了 vuex, 几乎 就认定该项目是较为复杂的</p>
</blockquote>
<h2 id="封装-Vue-组件的步骤"><a href="#封装-Vue-组件的步骤" class="headerlink" title="封装 Vue 组件的步骤"></a>封装 Vue 组件的步骤</h2><p>组件是什么？组件是一段功能代码  —大白话 就是一段 html +js +css   你可以重复使用</p>
<p>封装轮播图</p>
<p>1 新建 vue 组件</p>
<p>2 Vue.component 注册组件</p>
<p>3   在其他组件使用 标签名</p>
<p>参数： 可以传入数据 使用 props 接受 比如 数组 定时器时间等</p>
<blockquote>
<p>分析: 本题考查 对于 Vue 组件化开发的熟练程度</p>
</blockquote>
<blockquote>
<p><strong><code>解析</code></strong>: 首先明确 组件是本质是什么?</p>
</blockquote>
<blockquote>
<p>组件就是一个单位的 HTML 结构 + 数据逻辑 + 样式的 操作单元</p>
</blockquote>
<blockquote>
<p>Vue 的组件 继承自 Vue 对象, Vue 对象中的所有的属性和方法,组件可自动继承.</p>
</blockquote>
<blockquote>
<p>组件的要素  template  =&gt;   作为页面的模板结构</p>
</blockquote>
<blockquote>
<p>script  =&gt; 作为数据及逻辑的部分</p>
</blockquote>
<blockquote>
<p>style  =&gt; 作为该组件部分的样式部分</p>
</blockquote>
<p>要封装一个组件,首先要明确该组件要做的具体业务和需求,   什么样的体验特征, 完成什么样的交互, 处理什么样的数据</p>
<blockquote>
<p>明确上述要求之后, 着手模板的结构设计及搭建,也就是 常说的 html 结构部分,   先完成 静态的 html 结构</p>
</blockquote>
<blockquote>
<p>结构完成, 着手数据结构的设计及开发, 数据结构一般存储于组件的 data 属性 或者 vuex 状态共享的数据结构</p>
</blockquote>
<blockquote>
<p>数据设计完成/ 结构完成   接下来 完成数据和模块的结合 , 利用 vuejs 中指令和 插值表达式的特性 将静态结构 <strong><code>动态化</code></strong></p>
</blockquote>
<blockquote>
<p>展现的部分完成, 接下来完成**<code>交互部分</code>**,即利用 组件的生命周期的钩子函数 和 事件驱动 来完成 逻辑及数据的处理与操作</p>
</blockquote>
<p>最后组件完成,进行测试及使用</p>
<p>常用的组件属性 =&gt; data/ methods/filters/ components/watch/created/mounted/beforeDestroy/computed/props</p>
<p>常用组件指令: v-if/v-on/v-bind/v-model/v-text/v-once</p>
<h2 id="Vue-中的-data-是以函数的形式还是对象的形式表示"><a href="#Vue-中的-data-是以函数的形式还是对象的形式表示" class="headerlink" title="Vue 中的 data 是以函数的形式还是对象的形式表示"></a>Vue 中的 data 是以函数的形式还是对象的形式表示</h2><blockquote>
<p>分析: 此题考查 data 的存在形式</p>
</blockquote>
<blockquote>
<p><strong><code>解析</code></strong>: 我们在初步学习 Vue 实例化的时候写的代码时这个样子</p>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br></pre></td></tr></table></figure>
</blockquote>
<pre><code>el: &#39;#app&#39;,
data: &#123;
    name: &#39;hello world&#39;
&#125;
</code></pre>
<p>})</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 上面代码中的data 是一个对象, 但是我们在开发组件的时候要求data必须是一个带返回值的函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name: &#x27;张三&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么组件要求必须是带返回值的函数?   因为 我们的组件在实例化的时候, 会直接将 data 数据作用在视图上,</p>
</blockquote>
<blockquote>
<p>对组件实例化, 会导致我们组件的 data 数据进行共享, 好比   现在有两辆新车, 你一踩油门, 不光你的车往前车,另辆车也和你一样往前冲!   这显然不符合我们的程序设计要求, 我们希望组件内部的数据是相互独立的,且互不响应,所以 采用   <strong><code>return &#123;&#125;</code></strong>   每个组件实例都返回新对象实例的形式,保证每个组件实例的唯一性</p>
</blockquote>
<h2 id="使用-Proxy-代理跨域"><a href="#使用-Proxy-代理跨域" class="headerlink" title="使用 Proxy 代理跨域"></a>使用 Proxy 代理跨域</h2><p>什么是跨域？</p>
<p>域名 协议 ip 地址 端口 任何一个不一样 就跨域</p>
<p>解决跨域？</p>
<p>1 jsonp   —使用 script 的 src 发送   只能 get 请求</p>
<p>2 cors 后台设置允许跨域    <strong>需要后台设置</strong> 允许跨域</p>
<p>所有后台语言 都可以设置</p>
<p>3   服务器代理</p>
<p><strong>重点 现在 前端 vue 框架 是可以自己设置 服务器代理的</strong>  proxy</p>
<p><strong>配置就行</strong></p>
<p><strong>vue 在 vue.config.js   可以配置重写 webpack</strong></p>
<blockquote>
<p>分析: 本题考查如何解决跨域问题</p>
</blockquote>
<blockquote>
<p>解析: 解决跨域问题的方式有几种,</p>
</blockquote>
<blockquote>
<p><strong>1 一种是服务端设置</strong>  , 但这种方式依赖服务端的设置,在前后分离的场景下 ,不太方便</p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin：*</span><br><span class="line">Access-Control-Allow-Methods：&quot;POST, GET, OPTIONS, DELETE&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; **2 还有一种jsonp形式**, 可以利用script标签 的特性解决同源策略带来的跨域问题,但这是这种方案对于请求的类型有限制,只能get</span><br><span class="line"></span><br><span class="line">&gt; **3 还有一种就可以在开发环境(本地调试)期间,进行代理**, 说白了 就是通过 在本地通过nodejs 启动一个微型服务,</span><br><span class="line"></span><br><span class="line">&gt; 然后我们先请求我们的微型服务, 微型服务是服务端, 服务端**`代我们`**去请求我们想要的跨域地址, 因为服务端是不受**`同源策略`**的限制的, 具体到开发中,打包工具webpack集成了代理的功能,可以采用配置webpack的方式进行解决, 但是这种仅限于 本地开发期间, **等项目上线时,还是需要另择代理 nginx**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下为webpack配置代理的配置</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">// vue.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 修改的配置</span><br><span class="line">  devServer: &#123;</span><br><span class="line">      proxy: &#123;</span><br><span class="line">          &#x27;/api&#x27;: &#123;</span><br><span class="line">              target: &#x27;http://122.51.238.153&#x27;,</span><br><span class="line">              changeOrigin: true,</span><br><span class="line">              pathRewrite: &#123;</span><br><span class="line">                &#x27;^/api&#x27;: &#x27;&#x27;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**<code>target</code>**：接口域名；</p>
<p>**<code>changeOrigin</code>**： 如果设置为<code>true</code>,那么本地会虚拟一个服务端接收你的请求并代你发送该请求；</p>
<p>**<code>pathRewrite</code>**：如果接口中是没有 api 的，那就直接置空（如上）如果接口中有 api，就需要写成{‘^/api’:‘’}</p>
<p><strong>上线了如果还有跨域 可以让后台设置允许跨域</strong></p>
<h2 id="Vue-中的-watch-如何深度监听某个对象"><a href="#Vue-中的-watch-如何深度监听某个对象" class="headerlink" title="Vue 中的 watch 如何深度监听某个对象"></a>Vue 中的 watch 如何深度监听某个对象</h2><blockquote>
<p>分析: 此题考查 Vue 的选项 watch 的应用方式</p>
</blockquote>
<blockquote>
<p>解析:  watch 最基本的用法是</p>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br></pre></td></tr></table></figure>
</blockquote>
<pre><code>data () &#123;
    return &#123;
        name: &#39;张三&#39;
    &#125;
&#125;,
watch: &#123;
    // name 函数 是对应那个数据名字
    name (newValue, oldValue) &#123;
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 上面代码中: 有个原则监听谁,写谁的名字,然后是对应的执行函数, 第一个参数为最新的改变值,第二个值为上一次改变的值, 注意: 除了监听 data,也可以监听**`计算属性`** 或者一个 函数的计算结果</span><br><span class="line"></span><br><span class="line">&gt; 那怎么深度监听对象 ,两种方式</span><br><span class="line"></span><br><span class="line">&gt; 1. 字符串嵌套方式</span><br><span class="line"></span><br><span class="line">&gt; ```javascript</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">           a: &#123;</span><br><span class="line">               b: &#123;</span><br><span class="line">                   c :&#x27;张三&#x27;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        //想监听 c  此时 数据 是 a.b.c  比较深   深度监听</span><br><span class="line">        &quot;a.b.c&quot;: function (newValue, oldValue) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="2">
<li> 启用深度监听方式</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">           <span class="attr">a</span>: &#123;</span><br><span class="line">               <span class="attr">b</span>: &#123;</span><br><span class="line">                   <span class="attr">c</span> :<span class="string">&#x27;张三&#x27;</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">        <span class="attr">a</span>: &#123;</span><br><span class="line">            <span class="attr">deep</span>: <span class="literal">true</span> <span class="comment">// deep 为true  意味着开启了深度监听 a对象里面任何数据变化都会触发handler函数,</span></span><br><span class="line">            <span class="function"><span class="title">handler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="comment">// handler是一个固定写法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vue-keep-alive-使用"><a href="#Vue-keep-alive-使用" class="headerlink" title="Vue keep-alive 使用"></a>Vue keep-alive 使用</h2><blockquote>
<p>分析: 此题考查 Vue 中组件缓存的使用</p>
</blockquote>
<blockquote>
<p><strong>keep-alive  vue 原生自带   用来缓存组件的</strong></p>
</blockquote>
<blockquote>
<p>解析:  keep-alive 是 Vue 提供的一个全局组件, Vue 的组件是有销毁机制的,比如条件渲染, 路由跳转时 组件都会经历**<code>销毁</code>**, 再次回到页面时,又会回到 <strong><code>重生</code></strong>, 这一过程保证了生命周期钩子函数各个过程都会在这一生命周期中执行.</p>
</blockquote>
<blockquote>
<p>但是,我们辛辛苦苦获取的数据 滑动的页面 会因为组件的销毁 重生 而 <strong><code>归零</code></strong>,这影响了交互的体验, 所以 keep-alvie 出现了, 可以帮助我们缓存想要缓存的组件实例, 只用用 keep-alive **<code>包裹</code>**你想要缓存的组件实例, 这个时候, 组件创建之后,就不会再进行 销毁, 组件数据和状态得以保存</p>
</blockquote>
<blockquote>
<p>但是,没有了销毁,也就失去了重生的环节, 我们失去了 原有的钩子函数, 所以 keep-alive 包裹的组件 都获取了另外<strong>两个事件 –如果缓存组件需要重新获取数据</strong></p>
</blockquote>
<blockquote>
<p>唤醒 activated 重新唤醒休眠组件实例时 执行</p>
</blockquote>
<blockquote>
<p>休眠 deactivated 组件实例进入休眠状态时执行</p>
</blockquote>
<p>但是我们不能缓存所有的组件实例, 如果是针对 组件容器 router-view 这个组件进行的缓存, 一般的策略是在路由的元信息 meta 对象中设置是否缓存的标记,   然后根据标记决定是否进行缓存</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 里面是当需要缓存时   显示组件的 router-view--&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">router-view</span>  <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.isAlive&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line">   &lt;!-- 外面是不需要缓存时 --&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">router-view</span>  <span class="attr">v-if</span>=<span class="string">&quot;!$route.meta.isAlive&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>还有需要注意的问题是:   被缓存的组件中如果还有子组件, 那么子组件也会一并拥有 激活和唤醒事件,并且这些事件会在同时执行</p>
<h2 id="vue-的双向数据绑定原理是什么"><a href="#vue-的双向数据绑定原理是什么" class="headerlink" title="vue 的双向数据绑定原理是什么"></a>vue 的双向数据绑定原理是什么</h2><blockquote>
<p>分析 :此题考查 Vue 的 MVVM 原理</p>
</blockquote>
<blockquote>
<p><strong><code>解答</code></strong>:  Vue 的双向绑定原理其实就是 MVVM 的实现原理, Vuejs 官网已经说明, 实际就是通过 Object.defineProperty 方法 完成了对于 Vue 实例中数据的 <strong><code>劫持</code></strong>, 通过对于 data 中数据 set 的监听,</p>
</blockquote>
<blockquote>
<p>然后通过**<code>观察者模式</code>**, 通知 对应的绑定节点 进行节点数据更新, 完成数据驱动视图的更新</p>
</blockquote>
<blockquote>
<p>同理, 通过对于节点的表单值改变事件的监听,   执行对于数据的修改</p>
</blockquote>
<p>简单概述 : 通过 Object.defineProperty 完成对于数据的劫持, 通过观察者模式, 完成对于节点的数据更新</p>
<h2 id="页面刷新了之后-vuex-中的数据消失怎么解决"><a href="#页面刷新了之后-vuex-中的数据消失怎么解决" class="headerlink" title="页面刷新了之后 vuex 中的数据消失怎么解决"></a>页面刷新了之后 vuex 中的数据消失怎么解决</h2><blockquote>
<p>分析:此题考查 如果将 vuex 数据进行本地持久化</p>
</blockquote>
<blockquote>
<p><strong><code>解析</code></strong>: vuex 数据位于内存, 页面的刷新重置会导致数据的**<code>归零</code>**,也就是所谓的消失,   本地持久化可以解决这个问题.本地持久化用到的技术也就是 本次存储 sesstionStorage 或者 localStorage ,</p>
</blockquote>
<blockquote>
<p>如果需要保持的更长久 ,浏览器关掉 再打开依然存有数据,需要使用后者</p>
</blockquote>
<blockquote>
<p>实施方案:  state 的持久化 也就是分别需要在 state 数据初始化 /更新 的时候 进行读取和设置本地存储操作</p>
</blockquote>
<blockquote>
<p>代码如下</p>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.store(&#123;</span><br><span class="line">   <span class="attr">state</span>: &#123;</span><br></pre></td></tr></table></figure>
</blockquote>
<pre><code>   user: localStorge.getItem(&#39;user&#39;)  // 初始化时读取 本地存储
</code></pre>
<p>},<br>mutations: {<br>updateUser (state, payload) {<br>state.user = payload.user<br>localStoregae.setItem(‘user’,payload.user) // 数据更新时 设置本地存储<br>}<br>}<br>})</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## vue做服务端渲染</span><br><span class="line"></span><br><span class="line">nuxt.js    vue语法版本的  服务器渲染(ssr) 框架</span><br><span class="line"></span><br><span class="line">&gt; 分析: 为什么要做服务端渲染, 首先要明白 服务端渲染解决什么问题</span><br><span class="line"></span><br><span class="line">&gt; **`解析`**: vuejs 官网说的很明白, 要做服务端渲染首先必须是有对应的需求,即对 实时到达时间(页面访问时间)的绝对需求.  如果只是简单的一个管理系统, 区区几百毫秒的优化 显得十分小题大做.</span><br><span class="line"></span><br><span class="line">&gt; 服务端渲染这里 有一个成熟优秀的框架 nuxt.js , 正如next.js对于react,nuxt是vue服务端渲染的优秀解决方案</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; nuxt的出现可以让渲染内容完全服务端化,解决seo不够友好, 首屏渲染速度不够迅速的问题,</span><br><span class="line"></span><br><span class="line">&gt; 但是这里需要注意: 并不是所有页面都需要服务端渲染, 因为服务端渲染比重多大 对于服务器的访问处理能力 要求也会急剧增大</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>步骤 这个 nuxt 脚手架 不需要 安装 nodejs 默认自带了<br>1 脚手架 npx create-nuxt-app &lt;项目名&gt;<br>2 进入项目 yarn dev 启动开发</p>
<p>上线<br>yarn build<br>yarn start</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**普通vue项目  打开地址查看源代码   是空**  他主要是用切换的时候才会有内容</span><br><span class="line"></span><br><span class="line">**nuxt.js项目  查看源代码 他是已经渲染好了很多html了**</span><br><span class="line"></span><br><span class="line">1 这个和seo 搜索引擎 比如百度 他会去 找到所有网站 挨个看你的网站内容 有没有 好不好--爬虫</span><br><span class="line"></span><br><span class="line">如果普通vue  项目 是 空的  那么 就没有内容  seo不行 网站就很垃圾</span><br><span class="line"></span><br><span class="line">如果nuxt.js项目  有内容  就比较好 利于seo</span><br><span class="line"></span><br><span class="line">2  普通vue项目  内容打包到js了  那个js会很大  首页就显示很慢</span><br><span class="line"></span><br><span class="line">如果nuxt.js项目  只是一些 js 其他的他服务器端就渲染好了   稍微快</span><br><span class="line"></span><br><span class="line">vue单页面应用渲染是从服务器获取所需js，在客户端将其解析生成html挂载于</span><br><span class="line"></span><br><span class="line">id为app的DOM元素上，这样会存在两大问题。</span><br><span class="line"></span><br><span class="line">1. 由于资源请求量大，造成网站首屏加载缓慢，不利于用户体验。</span><br><span class="line">2. 由于页面内容通过js插入，对于内容性网站来说，搜索引擎无法抓取网站内容，不利于SEO。</span><br><span class="line"></span><br><span class="line">Nuxt.js 是一个基于Vue.js的通用应用框架，预设了利用Vue.js开发服务端渲染的应用所需要的各种配置。可以将html在服务端渲染，合成完整的html文件再输出到浏览器。</span><br><span class="line"></span><br><span class="line">**除此之外，nuxt与vue还有一些其他方面的区别。**</span><br><span class="line"></span><br><span class="line">1.</span><br><span class="line">**路由**</span><br><span class="line"></span><br><span class="line">nuxt按照 pages 文件夹的目录结构自动生成路由</span><br><span class="line"></span><br><span class="line">[http://localhost:3000/user/reg](http://localhost:3000/user/reg)  相当于 去访问  pages文件夹 下的  user文件夹 下的 reg.vue</span><br><span class="line"></span><br><span class="line">vue需在 src/router/index.js 手动配置路由</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">**入口页面**</span><br><span class="line"></span><br><span class="line">nuxt页面入口为 layouts/default.vue</span><br><span class="line"></span><br><span class="line">vue页面入口为 src/App.vue</span><br><span class="line"></span><br><span class="line">3.</span><br><span class="line">nuxt 类似  router-view   nuxt-link  类似 router-link</span><br><span class="line"></span><br><span class="line">4.</span><br><span class="line">**webpack配置**</span><br><span class="line"></span><br><span class="line">nuxt内置webpack，允许根据服务端需求，在 nuxt.config.js 中的build属性自定义构建webpack的配置，覆盖默认配置</span><br><span class="line"></span><br><span class="line">vue关于webpack的配置存放在build文件夹下</span><br><span class="line"></span><br><span class="line">5.</span><br><span class="line">**asyncData 里面发送ajax 这个东西跟生命周期这些都是平级的**</span><br><span class="line"></span><br><span class="line">要理解asyncData方法执行时，其实是在服务端完成的，这个数据是在服务端渲染好了的</span><br></pre></td></tr></table></figure>

<p>unxtjs 的 ajax，你先别往你那个异步上去思考，其实这里面所有的 ajax 最后都会形成页面。你别想着，我一点按钮，调用一个方法，然后再 ajax 去加载数据。因为我们最后全部都会生成静态，所以任何的获取数据的操作，最后都会变成页面的跳转。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">所以，官方给了一套写法，你必须按照这个去写，</span><br><span class="line"></span><br><span class="line">并且这里的ajax会再页面渲染之前就执行。这个东西跟生命周期这些都是平级的。</span><br><span class="line"></span><br><span class="line">1 cnpm install @nuxtjs/axios --save</span><br><span class="line"></span><br><span class="line">2 .plugins目录新建axios.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>import * as axios from ‘axios’<br>let options ={}<br>//需要全路径才能工作<br>if(process.server){<br>　　 options.baseURL=http://${process.env.HOST || ‘localhost’}:${process.env.PORT || 3000}/api<br>}<br>export default axios.create(options)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3.Nuxt.config.js增加axios配置</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>modules:[</p>
<p>‘@nuxtjs/axios’</p>
<p>],</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4 使用 asyncData 里面发送ajax 这个东西跟生命周期这些都是平级的 在页面渲染之前</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>export default {</p>
<p>async asyncData({app}){</p>
<p>let res =await app.$axios({</p>
<pre><code>      headers: &#123; &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39; &#125;,
      method: &#39;get&#39;,
      url: `http://test.yms.cn/testjson.asp`,
      data: &#39;&#39;
    　　&#125;)
    // app.$axios
    　　console.log(&#39;res&#39;,res.data)
    　　return&#123;
    　      　testData:res.data.title
    　　&#125;
&#125;,
created()&#123;
  console.log(&#39;nuxt reg组件&#39;)

&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## vue-router传参</span><br><span class="line"></span><br><span class="line">&gt; 分析:考查vue-router的传值方式</span><br><span class="line"></span><br><span class="line">&gt; **`解析`**  vue-router 传值 可以通过 地址传值</span><br><span class="line"></span><br><span class="line">&gt; 最简单的就是url传值, url传值又两种, params 和 query参数传值</span><br><span class="line"></span><br><span class="line">&gt; params传值 是指的动态路由传值</span><br><span class="line"></span><br><span class="line">&gt; ```vue</span><br><span class="line">&#123;  path: &#x27;/user/:id&#x27; &#125;  // 定义一个路由参数</span><br><span class="line">&lt;router-link to=&quot;/user/123&quot;&gt;&lt;/router-link&gt;  // 传值</span><br><span class="line">/user/123</span><br><span class="line">&#x27;/user/:id&#x27;  ---123 就是 id</span><br><span class="line">this.$route.params.id   // 取值 专门获取 :id 这种参数 params 参数</span><br></pre></td></tr></table></figure>

<blockquote>
<p>query 传值,指通过?后面的拼接参数传值</p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: &#x27;/user&#x27; &#125; // 定义一个路由参数</span><br><span class="line">&lt;router-link to=&quot;/user?id=123&amp;name=zs&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">// 传值 this.$route.query.id // 取值 获取 ?后面的参数 query参数 查询字符</span><br><span class="line">this.$route.query.name --- zs</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 前端鉴权一般思路</span><br><span class="line"></span><br><span class="line">以前讲过  我们可以 在axios的  请求拦截器 里面 配置 token</span><br><span class="line"></span><br><span class="line">**1 有些axios请求 需要token  我们 是可以 配置请求拦截器**</span><br><span class="line"></span><br><span class="line">**2 有些页面 需要登录才能看  我们也可以用路由导航守卫 router.beforeEach  判断 token**</span><br><span class="line"></span><br><span class="line">3 新情况？侧边栏 有很多 那么 后台侧边栏 有不同的人登录 难道我们要 每个人都可以看全部侧边栏吗？</span><br><span class="line"></span><br><span class="line">    比如 总经理 看的侧边栏很多 权限大 能操作很多页面</span><br><span class="line"></span><br><span class="line">             普通员工  就只能看两个侧边栏 因为他的权限低</span><br><span class="line"></span><br><span class="line">**这个时候就涉及到  如果不同的人登录 权限职位不一样  应该给他展示 不同的侧边栏**</span><br><span class="line"></span><br><span class="line">这个时候 侧边栏 一般是路由相关的页面  是需要循环生成的</span><br><span class="line"></span><br><span class="line">不同的人 路由数组不一样  那么 循环生成的侧边栏 就不一样了</span><br><span class="line"></span><br><span class="line">这样就可以控制侧边栏 显示</span><br><span class="line"></span><br><span class="line">思路是  在公司会这样干？</span><br><span class="line"></span><br><span class="line">&gt; 分析: 考查前后分离的鉴权思路</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**`解析`**: 首先要明白 为什么要在前端鉴权? 因为传统项目都是在后端鉴权, 然后通过进行拦截 跳转 对应操作</span><br><span class="line"></span><br><span class="line">因为 我们做的并不是传统的项目,而是前后分离项目,也就是前端项目和后端服务进行了**`剥离`**, 后端没有办法用session来存储你任意一个前端项目域名下的身份信息, 所以jwt 鉴权模式应运而生.</span><br><span class="line"></span><br><span class="line">    也就是后端不再提供会话的身份存储,而是通过一个鉴权接口将用户的身份,登录时间,请求端口,协议头..等等信息 组装成一个加密的串 返给前端请求,  前端拿到了这个串,就可以认为自己登录成功</span><br><span class="line"></span><br><span class="line">那么这个**`加密串`**就成了 前端用户是否登录的成功标志, 这就是我们的token , 那么在接下来的接口请求中,我们几乎都要携带这个加密串,因为它是**`唯一`**能**`证明我们身份`**的信息.</span><br><span class="line"></span><br><span class="line">为了方便,我们会一般在请求工具 axios(举例)的拦截器中**`统一注入token`**, 减少代码的重复</span><br><span class="line"></span><br><span class="line">token 同时具有时效性,我们也需要在此时对token过期进行处理,一旦出现过期的请求码, 就需要进行 换取新token 或者重新登录的解决方案</span><br><span class="line"></span><br><span class="line">除此之外,我们还需要依据**`有无加密串`** 在前端对于某些页面的访问进行限制, 这个会用到我们的Vue-Router中的导航守卫.</span><br><span class="line"></span><br><span class="line">**vue 单页项目涉及到多角色用户权限问题，不同的角色用户拥有不同的功能权限， 不同的功能权限对应的不同的页面**</span><br><span class="line"></span><br><span class="line">一开始 有一些 默认的路由</span><br><span class="line"></span><br><span class="line">登录后 比如你是总经理  后台会返回给前端 总经理能看见的 路由页面地址 数组</span><br><span class="line"></span><br><span class="line">前端在router.beforeEach 路由导航守卫里面 拿到返回的地址  使用 **router.addRouter** 动态加上 这个项目路由就好了</span><br><span class="line"></span><br><span class="line">routes= 后台返回的 符合条件的 路由数据 类似我们自己写的那个path 等等</span><br><span class="line"></span><br><span class="line">this.$router.addRoutes(routes)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>// 路由导航守卫<br>router.beforeEach((to, from, next) =&gt; {<br>　　　　//判断 user 信息是否已经获取 我已经登录了<br>// 登录后就 把 后台给我的路由数组 addRouter 就行<br>if (token) {<br>　　　　　　　　//根据用户的角色类型来生成对应的新路由<br>// 在这里要用 登录时候后台返回的 路由数组<br>// 建议大家 把那个数组 写在 vuex 里面<br>// 从 vuex 拿出 登录时候存的 newRouter<br>// 1 你提前写好 会有所有人能看的 一些 默认的路由<br>// 2 不同的 登录后 对应的路由 再追加<br>// this.$store.state.newRouter<br>// const newRouter = [{path:”/xxx” …} ..]<br>//将新路由添加到路由中<br>// router.addRoutes vue 带的专门用来追加路由的<br>//　 router.addRoutes(newRouter)<br>　　　　　　　//为了正确渲染导航,将对应的新的路由添加到 vuex 中<br>// 渲染对应的侧边栏<br>}<br>})</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 如果只是前端怎么做？</span><br><span class="line"></span><br><span class="line">如果是前端 就 先写一个全的所有的路由数组</span><br><span class="line"></span><br><span class="line">登录之后 后台 返回  当前的登录人的 数据 比如 路由列表或者这个人的权限</span><br><span class="line"></span><br><span class="line">前端拿到路由列表去循环和你那个全的路由对比拿到相关的在addRouter添加就行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## vue数据流 和 react数据流  ---单独的概念 数据流</span><br><span class="line"></span><br><span class="line">面试问 vue数据流  他不是问你双向绑定 你应该说</span><br><span class="line"></span><br><span class="line">**vue  react 数据流 是单向 的   父--&gt;  子  vue还有一个概念 是 v-model**</span><br><span class="line"></span><br><span class="line">在**vue** **React**中**数据流**向是**单向**的，**由父节点流向子节点**，如果父节点的props发生了改变，那么React会递归遍历整个组件</span><br><span class="line"></span><br><span class="line">**父组件通过绑定 props 的方式，将数据传递给子组件，但是子组件自己并没有权利修改这些数据，如果要修改，只能把修改这一个行为通过 event 的方式报告给父组件，由父组件本身决定改如何处理数据。**</span><br><span class="line"></span><br><span class="line">**vue 另一个概念 v-model双向数据   无论数据改变，或是用户操作，都能带来互相的变动，自动更新。**</span><br><span class="line"></span><br><span class="line">v-model 一般用在 表单元素  核心 是 他帮助我们  绑定value  + oniput 文本框值改变的事件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 如何在组件中监听Vuex的数据变化</span><br><span class="line"></span><br><span class="line">&gt; 分析:   此题考查Vuex的应用及 Vue内部的监听数据变化的机制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; **`解答`**:  首先确定 Vuex是为了解决什么问题而出现的 ?  Vuex是为了解决组件间状态共享而出现的一个框架.</span><br><span class="line"></span><br><span class="line">&gt; 其中有几个要素 是组成Vuex的关键,  state(状态)  mutations  actions  ,</span><br><span class="line"></span><br><span class="line">&gt; state 表示 需要共享的状态数据</span><br><span class="line"></span><br><span class="line">&gt; mutations  表示 更改 state的方法集合  只能是同步更新 不能写ajax等异步请求</span><br><span class="line"></span><br><span class="line">&gt; actions  如果需要做异步请求  可以在actions中发起 然后提交给 mutations mutation再做同步更新</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">也就是 state 负责管理状态 ,  mutation负责同步更新状态 action负责 异步获取数据 同提交给mutation</span><br><span class="line"></span><br><span class="line">&gt; 所以 组件监听Vuex数据变化 就是 监听 Vuex中state的变化,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**`第一种方案`**  我们可以在组件中通过组件的 **watch方法来做**, 因为组件可以将state数据映射到 组件的计算属性上,</span><br><span class="line"></span><br><span class="line">然后 监听 映射的计算属性即可 代码如下</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">// vuex中的state数据</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">//  A组件中映射 state数据到计算属性</span><br><span class="line">  computed: &#123;</span><br><span class="line">   //  this.$store.state.count</span><br><span class="line">  // mapState       把全局  count 变成 可以直接使用的 数据</span><br><span class="line">    ...mapState([&#x27;count&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">// A组件监听 count计算属性的变化</span><br><span class="line">   watch: &#123;</span><br><span class="line">     // watch 可以监听 data 数据 也可以监听 全局 vuex数据</span><br><span class="line">    count () &#123;</span><br><span class="line">      // 用本身的数据进行一下计数</span><br><span class="line">      this.changeCount++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>第二种方案</code></strong>   vuex 中 store 对象本身提供了**<code>watch</code>**函数 ,可以利用该函数进行监听</p>
<ul>
<li><strong>watch(fn: Function, callback: Function, options?: Object): Function</strong></li>
</ul>
<p>响应式地侦听 <code>fn</code> 的返回值，当值改变时调用回调函数。<code>fn</code> 接收 store 的 state 作为第一个参数，其 getter 作为第二个参数。最后接收一个可选的对象参数表示 Vue 的 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#vm-watch"><code>vm.$watch</code></a> 方法的参数。</p>
<p>代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="built_in">this</span>.$store.watch(<span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.count</span><br><span class="line">  &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.changeCount++</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上代码 均在示例有体现</p>
</blockquote>
<h2 id="Vue-单页面和多页面的使用"><a href="#Vue-单页面和多页面的使用" class="headerlink" title="Vue 单页面和多页面的使用"></a>Vue 单页面和多页面的使用</h2><p>配置多入口文件</p>
<p>Vue 单页面   只有一个页面 index.html 在里面 切换不同的组件</p>
<p>我想配置多页面？ 有多个页面   写死的步骤   只需要 配置 vue.config.js 和对应好文件夹 就行</p>
<p>morepage</p>
<p>&lt;&gt;</p>
<blockquote>
<p>分析: 首先分析,单页面应用和 多页面应用的根本区别</p>
</blockquote>
<blockquote>
<p><strong><code>解答</code></strong>:   单页面即所有的模块统统置于一个 html 文件之上,切换模块,不会重新对 html 文件和资源进行再次请求,服务器不会对我们**<code>换页面</code>**的动作 产生任何反应, 所以我们感觉不到任何的刷新动作,速度和体验很畅快</p>
</blockquote>
<blockquote>
<p>多页面应用 即多个 html 页面 共同的使用, 可以认为一个页面即一个模块,但是不排除 多个单页应用混合到一起的组合情况 ,   多页面切换一定会造成 页面资源的重新加载, 这也就意味着 如果 多页面之间切换,一定会造成很数据的**<code>重置</code>**</p>
</blockquote>
<blockquote>
<p>一个项目分成很多 小 vue 项目 你去其实也可以直接创建两个项目</p>
</blockquote>
<p>2   配置 多入口页面<strong>在 vue.config.js 里写上这些</strong> 重点是入口选择对应页面的 main.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//vue.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      // page 的入口</span><br><span class="line">      entry: &quot;src/views/index/main.js&quot;,</span><br><span class="line">      // 模板来源</span><br><span class="line">      template: &quot;public/index.html&quot;,</span><br><span class="line">      // 在 dist/index.html 的输出</span><br><span class="line">      filename: &quot;index.html&quot;,</span><br><span class="line">      // 当使用 title 选项时，</span><br><span class="line">      // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span><br><span class="line">      title: &quot;Index Page&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ui: &#123;</span><br><span class="line">      // page 的入口</span><br><span class="line">      entry: &quot;src/views/ui/main.js&quot;,</span><br><span class="line">      // 模板来源</span><br><span class="line">      template: &quot;public/ui.html&quot;,</span><br><span class="line">      // 在 dist/ui.html 的输出</span><br><span class="line">      filename: &quot;ui.html&quot;,</span><br><span class="line">      // 当使用 title 选项时，</span><br><span class="line">      // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span><br><span class="line">      title: &quot;ui Page&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4  main.js 不同的入口 对应上自己的 根组件和 页面元素</p>
<p>5   通过 a 标签跳转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    ui页面啊啊啊</span><br><span class="line">    &lt;a href=&quot;home.html&quot;&gt;去home页面&lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure>

      
    </div>
    
  </div>
  
    
    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2022/01/23/%E7%AC%94%E8%AF%95%E9%A2%98/">
                    笔试题
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2022/01/23/%E6%AF%94%E8%BE%83%E5%81%8F/">
                    比较偏
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-%E9%83%A8%E5%88%86%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">Vue 部分相关的面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex-%E6%80%8E%E4%B9%88%E5%90%88%E7%90%86%E8%A7%84%E8%8C%83%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE-%E5%8F%8A-mutations-%E5%92%8C-actions-%E5%8C%BA%E5%88%AB"><span class="toc-text">vuex 怎么合理规范管理数据,及 mutations 和 actions 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex-%E6%A8%A1%E5%9D%97%E5%8C%96-module-%E7%AE%A1%E7%90%86-%E4%BD%BF%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E6%9C%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">vuex 模块化 module 管理,使用的时候有注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85-Vue-%E7%BB%84%E4%BB%B6%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-text">封装 Vue 组件的步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84-data-%E6%98%AF%E4%BB%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%BF%98%E6%98%AF%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="toc-text">Vue 中的 data 是以函数的形式还是对象的形式表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Proxy-%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F"><span class="toc-text">使用 Proxy 代理跨域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84-watch-%E5%A6%82%E4%BD%95%E6%B7%B1%E5%BA%A6%E7%9B%91%E5%90%AC%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-text">Vue 中的 watch 如何深度监听某个对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-keep-alive-%E4%BD%BF%E7%94%A8"><span class="toc-text">Vue keep-alive 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E7%9A%84%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">vue 的双向数据绑定原理是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E4%BA%86%E4%B9%8B%E5%90%8E-vuex-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B6%88%E5%A4%B1%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-text">页面刷新了之后 vuex 中的数据消失怎么解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%92%8C%E5%A4%9A%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Vue 单页面和多页面的使用</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="Hide"  title="Show or Hide Table of Contents">

    <script>
        yiliaConfig.toc = ["Hide", "Show", !!"false"];
    </script>





    <div class="scroll" id="post-nav-button">
        
            <a href="/2022/01/23/%E7%AC%94%E8%AF%95%E9%A2%98/" title="Pre: 笔试题">
                <i class="iconfont icon-jiantouzuo"></i>
            </a>
        
        <a title="Mini Archives"><i class="iconfont icon-home"></i></a>
        
            <a href="/2022/01/23/%E6%AF%94%E8%BE%83%E5%81%8F/" title="Next: 比较偏">
                <i class="iconfont icon-jiantouyou"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">计算机组成思维导图</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">计算机网络思维导图</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">操作系统思维导图</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">数据结构思维导图</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/19/%E6%9C%89%E7%82%B9%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0/">有点问题学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/13/%E7%BD%91%E5%9D%80!%E6%B5%8F%E8%A7%88%E5%99%A8/">网址/浏览器/</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/13/vue%E4%BD%BF%E7%94%A8/">vue使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/13/less%E4%BD%BF%E7%94%A8/">less使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/07/vscode/">vscode</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/28/promise/">promise</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89/">算法题（重要）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89/">面试准备（重要）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E5%90%84%E7%B1%BB%E5%87%BD%E6%95%B0/">各类函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89/">个人总结（重要）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E7%AC%94%E8%AF%95%E9%A2%98/">笔试题</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E7%AC%94%E8%AE%B0/">笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E6%AF%94%E8%BE%83%E5%81%8F/">比较偏</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/xss%E5%92%8Ccsrf%20%E4%BB%8B%E7%BB%8D/">xss和csrf 介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/webpack/">webpack</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/vue%E7%90%86%E8%AE%BA/">vue理论</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/node/">node</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/js%E7%90%86%E8%AE%BA/">js理论</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/jS/">jS</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/jquery/">jquery</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/http/">http</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/html%E7%90%86%E8%AE%BA/">html理论</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/html-css/">html-css</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/flex%E5%B8%83%E5%B1%80/">flex布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/fetch%E5%92%8Caxios%E5%92%8Cneedle/">fetch和axios和needle</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/ES6/">ES6</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/DOM/">DOM</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/css%E7%90%86%E8%AE%BA/">css理论</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/css3/">css3</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/BOM/">BOM</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/02/npm/">npm</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/02/hexo%E4%BD%BF%E7%94%A8/">hexo使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/02/%E8%AF%AD%E9%9B%80%E4%BD%BF%E7%94%A8/">语雀使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/01/win11%E4%BD%BF%E7%94%A8/">win11使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/01/%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%20%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85/">学习内容 要做的事情</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/08/git%E4%BD%BF%E7%94%A8/">git使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">计算机操作系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%83%8C%E8%AF%B5/">操作系统背诵</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/14/%E4%BD%9C%E6%96%87%E8%8C%83%E6%96%87/">作文范文</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/14/%E4%BD%9C%E6%96%87%E6%A8%A1%E6%9D%BF/">作文模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/14/%E8%8B%B1%E8%AF%AD%E4%BD%9C%E6%96%87%E7%A7%AF%E7%B4%AF/">英语作文积累</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/16/%F0%9F%92%A1%201%20%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%AC%E8%AF%AD%E9%9B%80%E6%96%87%E6%A1%A3/">💡 1 分钟玩转语雀文档</a></li></ul>




    <script>
        ""
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="iconfont icon-copyright"></i> 
                2021-2022 John Doe
            </div>
        </div>
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="/plugins/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = "5";
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>

<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="iconfont icon-shangjiantou"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="iconfont icon-xiajiantou"></i></a>
</div>
  </div>
</body>
</html>