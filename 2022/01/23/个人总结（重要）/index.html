<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="John Doe" />
<meta name="referrer" content="no-referrer" />

<meta name="description" content="es5 和 es6 的继承有什么区别  class 类内部定义的所有方法都是不可枚举的。这点和 ES5 行为不一致。  类和模块的内部默认使用严格模式，所以不需要使用 use strict 指定运行模式。  类必须使用 new 来调用，否则会报错。  类内部不存在变量提升，这一点与 ES5 完全不同。  事件循环机制 （Event Loop）事件循环机制从整体上告诉了我们 JavaScript 代">
<meta property="og:type" content="article">
<meta property="og:title" content="个人总结（重要）">
<meta property="og:url" content="http://example.com/2022/01/23/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89/index.html">
<meta property="og:site_name" content="后知后觉的个人主页">
<meta property="og:description" content="es5 和 es6 的继承有什么区别  class 类内部定义的所有方法都是不可枚举的。这点和 ES5 行为不一致。  类和模块的内部默认使用严格模式，所以不需要使用 use strict 指定运行模式。  类必须使用 new 来调用，否则会报错。  类内部不存在变量提升，这一点与 ES5 完全不同。  事件循环机制 （Event Loop）事件循环机制从整体上告诉了我们 JavaScript 代">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162054267-1200211276.png#id=GipjJ&originHeight=148&originWidth=444&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162110117-1744170661.png#id=sgwi9&originHeight=192&originWidth=414&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162054267-1200211276.png#id=l6Ti7&originHeight=148&originWidth=444&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162125772-1830945749.png#id=OENBt&originHeight=176&originWidth=414&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162054267-1200211276.png#id=SmMNi&originHeight=148&originWidth=444&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162137084-1234623120.png#id=Xl0tK&originHeight=157&originWidth=434&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200710192655748.png#id=zCScC&originHeight=250&originWidth=117&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020071019423921.png#id=HYEli&originHeight=169&originWidth=180&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202007101949243.png#id=AEQ9L&originHeight=164&originWidth=234&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200710202315846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z5bHh5MDAw,size_16,color_FFFFFF,t_70#id=Oo95o&originHeight=246&originWidth=1365&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200710202336549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z5bHh5MDAw,size_16,color_FFFFFF,t_70#id=TJLIJ&originHeight=259&originWidth=1365&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://t12.baidu.com/it/u=1154946920,956464023&fm=173&app=25&f=JPG?w=600&h=428&s=B29457CAD2AC8F4F54F8B50B0300E0C1#id=siNp8&originHeight=428&originWidth=600&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://t11.baidu.com/it/u=398540911,2791133765&fm=173&app=25&f=JPG?w=600&h=163&s=AA9001CBD1D488735E509C0E030070C1#id=Wb8yR&originHeight=163&originWidth=600&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://t10.baidu.com/it/u=2156837736,2073091767&fm=173&app=25&f=JPG?w=600&h=263&s=80504730139278690654C1DA0000C0B5#id=NZW2q&originHeight=263&originWidth=600&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://g.yuque.com/gr/latex?route%E5%92%8C#card=math&code=route%E5%92%8C&id=lPUzN">
<meta property="og:image" content="https://segmentfault.com/img/bV9lca?w=1200&h=750#id=QoCKb&originHeight=458&originWidth=732&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://segmentfault.com/img/bVbqG3f?w=980&h=346#id=hNjdp&originHeight=258&originWidth=732&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://segmentfault.com/img/bVbqG3t?w=895&h=454#id=mJh6E&originHeight=371&originWidth=732&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://segmentfault.com/img/bVbqG4M?w=847&h=194#id=r8wNK&originHeight=168&originWidth=732&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://g.yuque.com/gr/latex?nextTick%E7%9A%84%E4%BD%BF%E7%94%A8**%0A%E7%AD%94%EF%BC%9A%E5%BD%93%E4%BD%A0%E4%BF%AE%E6%94%B9%E4%BA%86data%E7%9A%84%E5%80%BC%E7%84%B6%E5%90%8E%E9%A9%AC%E4%B8%8A%E8%8E%B7%E5%8F%96%E8%BF%99%E4%B8%AAdom%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC%EF%BC%8C%E6%98%AF%E4%B8%8D%E8%83%BD%E8%8E%B7%E5%8F%96%E5%88%B0%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E5%80%BC%EF%BC%8C%0A%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8#card=math&code=nextTick%E7%9A%84%E4%BD%BF%E7%94%A8%2A%2A%0A%E7%AD%94%EF%BC%9A%E5%BD%93%E4%BD%A0%E4%BF%AE%E6%94%B9%E4%BA%86data%E7%9A%84%E5%80%BC%E7%84%B6%E5%90%8E%E9%A9%AC%E4%B8%8A%E8%8E%B7%E5%8F%96%E8%BF%99%E4%B8%AAdom%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC%EF%BC%8C%E6%98%AF%E4%B8%8D%E8%83%BD%E8%8E%B7%E5%8F%96%E5%88%B0%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E5%80%BC%EF%BC%8C%0A%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8&id=ACApx">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12665637-4c16334926b37570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/478/format/webp#id=I9r51&originHeight=157&originWidth=478&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12665637-81e13b602907e736.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/655/format/webp#id=WQunO&originHeight=162&originWidth=655&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://g.yuque.com/gr/latex?route.query.name%E5%92%8Cthis.#card=math&code=route.query.name%E5%92%8Cthis.&id=LWl6u">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/52af2165-aa3b-41ea-acdf-4c3fb7ba3b27.png#id=G1CxA&originHeight=168&originWidth=669&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/51d40eb1-3e74-4e27-9583-b3b50f332510.png#id=GSkMx&originHeight=224&originWidth=406&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/b548b239-eb00-447d-be60-29c1c3b3ce9b.png#id=lBkOy&originHeight=137&originWidth=551&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/54802412-70df-4c69-8adb-cea9c52b2b09.png#id=axFkz&originHeight=478&originWidth=504&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/ac4fc806-f29a-44e2-bcf0-95b28c401790.png#id=bVnSe&originHeight=143&originWidth=371&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/6e7f7867-9422-4238-a23b-d463e1f799d5.png#id=h2cBS&originHeight=211&originWidth=369&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/a147d491-68bd-45d7-8403-6c25ce99201e.png#id=Yhr34&originHeight=351&originWidth=690&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/a8e61566-e44e-4a92-95e0-c872cf9a2cbb.png#id=YWP7R&originHeight=334&originWidth=736&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/f56570d0-2ec4-4970-8ba5-c1bf2b8abf2d.png#id=dpdtd&originHeight=255&originWidth=669&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/e93f193c-3bf2-41ef-b300-e199a8a60d27.png#id=iKGWi&originHeight=186&originWidth=376&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/83a9003a-434c-4f11-a7d6-6ce2f5965106.png#id=RvY9l&originHeight=509&originWidth=925&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/a36f5b9e-2e06-4593-9c77-a50d798bc8ea.png#id=cskGk&originHeight=461&originWidth=738&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/90ebfadd-e79a-4837-9873-5cbb0cd1b0f2.png#id=ArlxW&originHeight=473&originWidth=760&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/2e0393c9-cc86-4a20-905e-3f80154f4f2f.png#id=eIGSY&originHeight=299&originWidth=727&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/0d2066b5-e10e-4562-b5f7-eef9ff2e9a02.png#id=aut2p&originHeight=321&originWidth=904&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/980c6de1-f378-48c3-90a5-6d865b46881f.png#id=gOkw2&originHeight=398&originWidth=814&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/cce6a3d6-e055-43ea-9687-e3f1fa6854cf.png#id=NnCyJ&originHeight=294&originWidth=717&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/5130e68e-74c7-4b1a-9a12-7f5e7f5ceb6d.png#id=JIokE&originHeight=210&originWidth=586&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/bdb50caf-0484-47b9-a3ed-ec0aa9d38e67.png#id=DdZdp&originHeight=205&originWidth=339&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://www.igeekbar.com/igeekbar/networks/uploadimgthumb/8dd4193f-f723-4597-9633-1c789fbf474b.png#id=bpRfr&originHeight=304&originWidth=885&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/c7ba0acc-7305-4a55-9790-6bc637922989.png#id=FxjMm&originHeight=143&originWidth=604&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/1cd4281f-4170-40e4-8bfa-cc0050af9a53.png#id=cfqLQ&originHeight=118&originWidth=559&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/238a0267-dbd8-4dd3-8598-b09895b5694e.png#id=KHqLV&originHeight=123&originWidth=783&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="http://igeekbar.com/igeekbar/networks/uploadimgthumb/da1c5b48-42db-4d5f-8a24-19389fa858f0.png#id=tXUqB&originHeight=476&originWidth=586&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://segmentfault.com/img/bVbCvL6#id=E23HW&originHeight=115&originWidth=227&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://segmentfault.com/img/bVbCvMB#id=z6g0W&originHeight=441&originWidth=683&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://segmentfault.com/img/bVbCvSi#id=oSIqa&originHeight=134&originWidth=216&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://segmentfault.com/img/bVbCvRV#id=kTLO8&originHeight=437&originWidth=542&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://segmentfault.com/img/bVbCvZS#id=HTc7j&originHeight=374&originWidth=525&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="article:published_time" content="2022-01-23T08:11:20.000Z">
<meta property="article:modified_time" content="2023-02-03T11:13:20.915Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162054267-1200211276.png#id=GipjJ&originHeight=148&originWidth=444&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">

<link rel="shortcut icon" href="/img/favicon.ico">
<link href="/css/bootstrap.css" rel="stylesheet">
<link href="/css/person.css"  rel="stylesheet">
<link href="//at.alicdn.com/t/font_2822169_7n9pu9ptxz8.css" rel="stylesheet">

    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">



    <script src="/plugins/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link href="/css/style.css?v=1" rel="stylesheet">

<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>
    个人总结（重要） | 
    后知后觉的个人主页
</title>

<script src="/plugins/jquery.min.js"></script>
<script src="/plugins/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: "true",
        isHome: "false",
        isPost: "true",
        isArchive: "false",
        isTag: "false",
        isCategory: "false",
        fancybox_js: "/plugins/jquery.fancybox.min.js",
        scrollreveal: "/plugins/scrollreveal.min.js",
        search: ""
    }
</script>



    <script> yiliaConfig.rootUrl = "\/";</script>


<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/index.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>

        

        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/tags">标签云</a></li>
                        
                            <li><a href="/about">关于我</a></li>
                        
                        </ul>
                    </nav>
                </section>
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger hide"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/index.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/tags">标签云</a></li>
                
                    <li><a href="/about">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me"/>
</nav>
      <div class="body-wrap"><div class="post"></div>
<article id="post-个人总结（重要）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/01/23/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89/" class="article-date">
      <time datetime="2022-01-23T08:11:20.000Z" itemprop="datePublished">2022-01-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      个人总结（重要）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="es5-和-es6-的继承有什么区别"><a href="#es5-和-es6-的继承有什么区别" class="headerlink" title="es5 和 es6 的继承有什么区别"></a>es5 和 es6 的继承有什么区别</h1><ol>
<li> class 类内部定义的所有方法都是不可枚举的。这点和 ES5 行为不一致。</li>
<li> 类和模块的内部默认使用严格模式，所以不需要使用 use strict 指定运行模式。</li>
<li> 类必须使用 new 来调用，否则会报错。</li>
<li> 类内部不存在变量提升，这一点与 ES5 完全不同。</li>
</ol>
<h1 id="事件循环机制-（Event-Loop）"><a href="#事件循环机制-（Event-Loop）" class="headerlink" title="事件循环机制 （Event Loop）"></a>事件循环机制 （Event Loop）</h1><p>事件循环机制从整体上告诉了我们 JavaScript 代码的执行顺序 <code>Event Loop</code>即事件循环，是指浏览器或<code>Node</code>的一种解决<code>javaScript</code>单线程运行时不会阻塞的一种机制，也就是我们经常使用<strong>异步</strong>的原理。</p>
<h1 id="包含外部样式表文件和外部脚本文件的-HTML-载入和渲染过程"><a href="#包含外部样式表文件和外部脚本文件的-HTML-载入和渲染过程" class="headerlink" title="包含外部样式表文件和外部脚本文件的 HTML 载入和渲染过程"></a>包含外部样式表文件和外部脚本文件的 HTML 载入和渲染过程</h1><ol>
<li>浏览器下载 HTML 文件并开始解析 DOM。</li>
<li>遇到样式表文件<code>link[rel=stylesheet]</code>时，将其加入资源文件下载队列，继续解析 DOM。</li>
<li>遇到脚本文件时，暂停 DOM 解析并立即下载脚本文件。</li>
<li>下载结束后立即执行脚本，在脚本中可访问当前以上的 DOM。</li>
<li>脚本执行结束，继续解析 DOM。</li>
<li>整个 DOM 解析完成，触发<code>DOMContentLoaded</code>事件。</li>
</ol>
<h1 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h1><h2 id="什么是阻塞？"><a href="#什么是阻塞？" class="headerlink" title="什么是阻塞？"></a>什么是阻塞？</h2><p>在页面中我们通常会引用外部文件，而浏览器在解析 HTML 页面是从上到下依次解析、渲染，如果中引用了一个 a.js 文件，而这个文件很大或者有问题，需要 2 秒加载，那么浏览器会停止渲染页面（此时是白屏显示，就是页面啥都没有），2 秒后加载完成才会继续渲染，这个就是阻塞。</p>
<h2 id="为什么会阻塞？"><a href="#为什么会阻塞？" class="headerlink" title="为什么会阻塞？"></a>为什么会阻塞？</h2><p>所有浏览器在下载 JS 的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到 JS 下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。</p>
<p>由于浏览器为了防止出现 JS 修改 DOM 树，需要重新构建 DOM 树的情况，所以就会阻塞其它的下载和呈现</p>
<p>因为浏览器不知道 a.js 中执行了哪些脚本，会对页面造成什么影响，所以浏览器会等 js 文件下载并执行完成后才继续渲染，如果这个时间过长，会白屏。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1、推迟加载（延迟加载）"><a href="#1、推迟加载（延迟加载）" class="headerlink" title="1、推迟加载（延迟加载）"></a>1、推迟加载（延迟加载）</h3><p>如果页面初始的渲染并不依赖于 js 或者 CSS 可以用推迟加载，就是最后在加载 js 和 css，把引用外部文件的代码写在最后。比如一些按钮的点击事件，比如轮播图动画的脚本也可以放在最后。</p>
<h3 id="2、defer-延迟加载"><a href="#2、defer-延迟加载" class="headerlink" title="2、defer 延迟加载"></a>2、defer 延迟加载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;&quot; defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在文档解析完成开始执行，并且在 DOMContentLoaded 事件之前执行完成，会按照他们在文档出现的顺序去下载解析。效果和把 script 放在文档最后之前是一样的。</p>
<h3 id="3、异步加载"><a href="#3、异步加载" class="headerlink" title="3、异步加载"></a>3、异步加载</h3><ul>
<li>async 异步加载<br>：就是告诉浏览器不必等到加载完外部文件，可以边渲染边下载，什么时候下载完成什么时候执行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;a.js&quot; async&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>onload 时异步加载<br>这个和 script dom element 法差不多但是他不是同时执行 js 和 html，他是等 html 的文件，图片之类的、页面所有的资源全部加载完成后再下载执行 js，这样的方法可以避免阻塞 onload 事件的触发。<br>注：DOMContentLoaded 与 onload 事件不同，DOMContentLoaded 是页面解析完成，页面的 dom 元素可以使用，但是页面的图片、视频等资源可能还没加载完成</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">     function async_load()&#123;</span><br><span class="line">         var s = document.createElement(&#x27;script&#x27;);</span><br><span class="line">         s.type = &#x27;text/javascript&#x27;;</span><br><span class="line">         s.async = true;</span><br><span class="line">         s.src = &#x27;js/yibujiaz.js&#x27;;</span><br><span class="line">         var x = document.getElementsByTagName(&#x27;script&#x27;)[0];</span><br><span class="line">         x.parentNode.insertBefore(s, x);</span><br><span class="line">     &#125;</span><br><span class="line">     if (window.attachEvent)</span><br><span class="line">         window.attachEvent(&#x27;onload&#x27;, async_load);</span><br><span class="line">     else</span><br><span class="line">         window.addEventListener(&#x27;load&#x27;, async_load, false);</span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure>

<h1 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h1><p>宏任务：DOM 渲染后触发，如：setTimeout，setInterval，Ajax，DOM 事件</p>
<p>微任务：DOM 渲染前触发，如：Promise，async/await 微任务执行时机要比宏任务要早</p>
<p>但是事件循环中并非只维护着一个队列，事实上是有两个队列：<br>（1）宏任务队列（macrotask queue）：ajax、setTimeout、setInterval、DOM 监听</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 onclick=&quot;this.innerHTML = &#x27;Hello!&#x27;&quot;&gt;点击此文本！&lt;/h1&gt;//DOM监听</span><br></pre></td></tr></table></figure>

<p>（2）微任务队列（microtask queue）：Promise 的 then 回调、 Mutation Observer API</p>
<p>MutationObserverAPI 可以看作一个监听 DOM 所有变化（包含节点、属性、文本内容的变动）的接口。</p>
<p><strong>主线程任务直接执行</strong></p>
<p><strong>同一次事件循环中   微任务永远在宏任务之前执行</strong></p>
<p>宏任务中的事件放在回调队列（callback queue）中，由事件触发线程维护；</p>
<p>微任务的事件放在微任务队列中，由 js 引擎线程维护。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;start&#x27;)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setTimeout&#x27;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">new Promise((resolve) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;promise&#x27;)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;then1&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;then2&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">console.log(&#x27;end&#x27;)</span><br><span class="line">start</span><br><span class="line">promise</span><br><span class="line">end</span><br><span class="line">then1</span><br><span class="line">then2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<h1 id="call-的使用"><a href="#call-的使用" class="headerlink" title="call 的使用"></a>call 的使用</h1><p>Function.apply(obj,args)方法能接收两个参数</p>
<p>obj：这个对象将代替 Function 类里 this 对象</p>
<p>args：这个是数组，它将作为参数传给 Function（args–&gt;arguments）</p>
<p>公司一道 js 面试题，代码如下，问使用 getName 方法打印出 1,2,3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;1&quot;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:2,</span><br><span class="line">    prop: &#123;</span><br><span class="line">        name:3,</span><br><span class="line">        getName: function() &#123;</span><br><span class="line">            return this.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.info(obj.prop.getName()); //3</span><br><span class="line">console.info(obj.prop.getName.call(obj)); //2</span><br><span class="line">console.info(obj.prop.getName.call(this)); //1</span><br></pre></td></tr></table></figure>

<h2 id="手写-call"><a href="#手写-call" class="headerlink" title="手写 call"></a>手写 call</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   // call</span><br><span class="line">   Function.prototype.myCall = function(thisArg, ...args) &#123;</span><br><span class="line">       const fn = Symbol(&#x27;fn&#x27;)    // 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span><br><span class="line">       thisArg = thisArg || window // 若没有传入this, 默认绑定window对象</span><br><span class="line">       thisArg[fn] = this          // this指向调用call的对象,即我们要改变this指向的函数</span><br><span class="line">       const result = thisArg[fn](...args)  // 执行当前函数</span><br><span class="line">       delete thisArg[fn]              // 删除我们声明的fn属性</span><br><span class="line">       return result                  // 返回函数执行结果</span><br><span class="line">   &#125;</span><br><span class="line">   //测试</span><br><span class="line">   foo.myCall(obj)</span><br><span class="line"></span><br><span class="line">// bind</span><br><span class="line">   Function.prototype.myBind = function (thisArg, ...args) &#123;</span><br><span class="line">       var self = this</span><br><span class="line">       // new优先级</span><br><span class="line">       var fbound = function () &#123;</span><br><span class="line">           self.apply(this instanceof self ? this : thisArg, args.concat(Array.prototype.slice.call(arguments)))</span><br><span class="line">       &#125;</span><br><span class="line">       // 继承原型上的属性和方法</span><br><span class="line">       fbound.prototype = Object.create(self.prototype);</span><br><span class="line">       return fbound;</span><br><span class="line">   &#125;</span><br><span class="line">   //测试</span><br><span class="line">   const obj = &#123; name: &#x27;写代码像蔡徐抻&#x27; &#125;</span><br><span class="line">   function foo() &#123;</span><br><span class="line">       console.log(this.name)</span><br><span class="line">       console.log(arguments)</span><br><span class="line">   &#125;</span><br><span class="line">   foo.myBind(obj, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)()</span><br></pre></td></tr></table></figure>

<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包是指有权访问另外一个函数作用域中的变量的函数。可以理解为(能够读取另一个函数作用域的变量的函数)<br>闭包的实质是因为函数嵌套而形成的作用域链<br>闭包的定义即：函数 <code>A</code> 内部有一个函数 <code>B</code>，函数 <code>B</code> 可以访问到函数 <code>A</code> 中的变量，那么函数 <code>B</code> 就是闭包</p>
<p>好处：</p>
<p>原来外部是无法访问到 b 的，现在可以了</p>
<h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">           var num = 0;</span><br><span class="line">           var fn2 = function() &#123;</span><br><span class="line">               num++;</span><br><span class="line">               console.log(num)</span><br><span class="line">           &#125;</span><br><span class="line">           return fn2</span><br><span class="line">       &#125;</span><br><span class="line">       var fn=add();</span><br><span class="line">           fn()//1</span><br><span class="line">           fn()//2</span><br></pre></td></tr></table></figure>

<p>(1)函数在执行完毕后依然保留内部变量</p>
<p>正常情况下 add 函数执行完成后，add 函数内部的局部变量将会被垃圾回收机制回收，但当我们用 fn 保留对 add 内部的函数的引用时 内部函数对象就不会被释放，而内部函数又引用了 num，因此变量 num 在 add 函数执行完毕后也不会被释放，而是继续存在内存中。</p>
<p>（2）访问函数内部变量</p>
<p>由于 js 的机制导致我们访问某一变量时我们只能从内往外部去访问，但是使用闭包我们就可以访问某函数内部的局部变量。从上例可以看到，我们在 window 中调用了 add（）函数，并且访问到了 add 的局部变量 num</p>
<p>应用场景</p>
<p>1.setTimeout</p>
<p>原生的 setTimeout 传递的第一个函数不能带参数，通过闭包可以实现传参效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f1(a) &#123;</span><br><span class="line">    function f2() &#123;</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    return f2;</span><br><span class="line">&#125;</span><br><span class="line">var fun = f1(1);</span><br><span class="line">setTimeout(fun,1000);//一秒之后打印出1</span><br></pre></td></tr></table></figure>

<p>2.回调</p>
<p>定义行为，然后把它关联到某个用户事件上（点击或者按键）。代码通常会作为一个回调（事件触发时调用的函数）绑定到事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function changeSize(size)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        document.body.style.fontSize = size + &#x27;px&#x27;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var size12 = changeSize(12);</span><br><span class="line">document.getElementById(&#x27;size-12&#x27;).onclick = size12;</span><br></pre></td></tr></table></figure>

<p>3.封装私有变量</p>
<p>用 js 创建一个计数器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">    var sum = 0;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">       inc:function () &#123;</span><br><span class="line">           sum++;</span><br><span class="line">           return sum;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">let result = f1();</span><br><span class="line">console.log(result.inc());//1</span><br><span class="line">console.log(result.inc());//2</span><br><span class="line">console.log(result.inc());//3</span><br></pre></td></tr></table></figure>

<p>在返回的对象中，实现了一个闭包，该闭包携带了局部变量 x，并且，从外部代码根本无法访问到变量 x。</p>
<p>闭包产生的本质<br>当前环境中存在指向父级作用域的引用</p>
<p>一般如何产生闭包<br>返回函数</p>
<p>函数当做参数传递</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)</li>
<li>让函数外部可以操作(读写)到函数内部的数据(变量/函数)</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长</li>
<li>容易造成内存泄露</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul>
<li>能不用闭包就不用</li>
<li>及时释放</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = null //让内部函数成为垃圾对象--&gt;回收闭包</span><br></pre></td></tr></table></figure>

<h1 id="JS-的垃圾回收机制了解吗"><a href="#JS-的垃圾回收机制了解吗" class="headerlink" title="JS 的垃圾回收机制了解吗?"></a>JS 的垃圾回收机制了解吗?</h1><h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾?"></a>什么是垃圾?</h2><p>当一个对象没有任何变量或属性对它引用,此时我们无法操作该对象，这种对象就是一个垃圾</p>
<p>那些没有被任何变量或者属性引用的对象就是垃圾，哪怕几个对象形成一个环形引用，但如果根访问不到他们，那也算是垃圾。</p>
<p>如何清理垃圾<br>在 js 中拥有自动的垃圾回收机制，会自动将垃圾对象销毁，我们需要做只是将不再使用的对象设置为 null</p>
<p>Js 具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。</p>
<p>垃圾回收方式</p>
<p>1.标记清除。</p>
<p>工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p>
<p>2.引用计数</p>
<p>工作原理：跟踪记录每个值被引用的次数。</p>
<p>工作流程：</p>
<ol>
<li>声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是 1。</li>
<li>同一个值又被赋值给另一个变量，这个引用类型值的引用次数加 1.</li>
<li>当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减 1.</li>
<li>当引用次数变成 0 时，说明没办法访问这个值了。</li>
<li>当垃圾收集器下一次运行时，它就会释放引用次数是 0 的值所占的内存。</li>
</ol>
<p>但是循环引用的时候就会释放不掉内存。</p>
<p>循环引用就是对象 A 中包含另一个指向对象 B 的指针，B 中也包含一个指向 A 的引用。</p>
<p>解决：手工断开 js 对象和 DOM 之间的链接。赋值为 null。</p>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。</p>
<ol>
<li>意外的全局变量引起的内存泄漏。</li>
</ol>
<p>原因：全局变量，不会被回收。</p>
<p>解决：使用严格模式避免。</p>
<ol start="2">
<li>闭包引起的内存泄漏</li>
</ol>
<p>原因：闭包可以维持函数内局部变量，使其得不到释放。</p>
<p>解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对 dom 的引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function bindEvent()</span><br><span class="line">&#123;</span><br><span class="line">    var obj=document.createElement(&quot;XXX&quot;);</span><br><span class="line">    obj.onclick=function()&#123;</span><br><span class="line">        //Even if it&#x27;s a empty function</span><br><span class="line">    &#125;</span><br><span class="line">    obj=null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>没有清理的 DOM 元素引用</li>
</ol>
<p>原因：虽然别的地方删除了，但是对象中还存在对 dom 的引用</p>
<p>解决：手动删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var elements = &#123;</span><br><span class="line">    button: document.getElementById(&#x27;button&#x27;),</span><br><span class="line">    image: document.getElementById(&#x27;image&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">function doStuff() &#123;</span><br><span class="line">    image.src = &#x27;http://some.url/image&#x27;;</span><br><span class="line">    button.click();</span><br><span class="line">    console.log(text.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line">function removeButton() &#123;</span><br><span class="line">    document.body.removeChild(document.getElementById(&#x27;button&#x27;));</span><br><span class="line">  // 虽然我们用removeChild移除了button, 但是还在elements对象里保存着#button的引用</span><br><span class="line"> // 换言之, DOM元素还在内存里面.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="什么放在内存中？什么不放在内存中？"><a href="#什么放在内存中？什么不放在内存中？" class="headerlink" title="什么放在内存中？什么不放在内存中？"></a>什么放在内存中？什么不放在内存中？</h1><p>基本类型是：Undefined/Null/Boolean/Number/String</p>
<p>基本类型的值存在内存中，被保存在栈内存中。</p>
<p>引用类型：object</p>
<p>引用类型的值是对象，保存在堆内存中。</p>
<p>js 不允许直接访问内存中的位置，也就是不能直接访问操作对象的内存空间。</p>
<p>在操作对象时，实际上是在操作对象的引用而不是实际的对象。</p>
<h1 id="重排-reflow-和重绘-repaint"><a href="#重排-reflow-和重绘-repaint" class="headerlink" title="重排(reflow)和重绘(repaint)"></a>重排(reflow)和重绘(repaint)</h1><h2 id="浏览器的渲染机制"><a href="#浏览器的渲染机制" class="headerlink" title="浏览器的渲染机制"></a>浏览器的渲染机制</h2><p>浏览器的渲染流程：<br>(1)创建 DOM Tree：浏览器请求到 HTML 文件后，将 HTML 解析成树形的数据结构，通常我们称为 DOM 树；在生成 DOM 树的开始阶段就会对 HTML 文件内的 CSS、JavaScript 文件、图片等资源发起请求；</p>
<p>(2)创建 CSSOM：浏览器请求下载到 CSS 文件，将 CSS 解析成树形的数据结构，CSS Object Model；</p>
<p>CSSOM：即 CSS Object Model，CSS 对象模型，是对 CSS 样式表的对象化表示，同时还提供了相关 API 用来操作 CSS 样式。</p>
<p>(3)创建 Render Tree:所有的 CSS 都被解析成 CSS Object Model 后和 DOM 树共同组合生成渲染树（Render Tree）；<br>(4)布局 Layout：上一步有了渲染树，浏览器已经知道了页面中的所有节点和每个节点的样式以及各个节点之间的从属关系，之一步就是要计算出各个节点在页面中应该显示的位置；<br>(5)绘制页面 Painting： 现在我们已经知道了页面中每个节点、节点的结构、每个节点的样式和位置，现在就可以通过这些数据绘制出我们的页面了。</p>
<p>重排的定义：每个页面都必须经过一次重排（就是页面首次渲染）</p>
<p>哪些操所会造成重排呢？</p>
<p>总之只要是改变了元素的大小、位置的操作都会发生重排。</p>
<p>只要是重排就可能要重新计算页面的布局、重新创建 Render Tree、重新创建 CSSOM、重新创建 DOM Tree 等某些操作。</p>
<p>重绘的定义</p>
<p>改变除了元素位置和大小以外的外观。只是执行了渲染过程的最后一步。所以相对于重排的开销要小得多。</p>
<p>重排和重绘的关系：凡是重排一定会重绘。因为重绘就是页面渲染的最后一步，不进行这一步页面就不能显示。</p>
<h1 id="事件与事件流-浏览器事件模型"><a href="#事件与事件流-浏览器事件模型" class="headerlink" title="事件与事件流(浏览器事件模型)"></a>事件与事件流(浏览器事件模型)</h1><p>什么是事件</p>
<p>JavaScript 和 HTML 之间的交互是通过事件实现的。</p>
<p>事件，就是文档或浏览器窗口发生的一些特定的交互瞬间。</p>
<p>事件流是网页元素接收事件的顺序</p>
<p>DOM0 级只支持冒泡阶段,比如 onclick，取消的话，dom.onclick = null，同一个事件只能有一个处理程序，后面的会覆盖前面的。(不能同时绑定多个事件)</p>
<p>“DOM2 级事件:一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件</p>
<p>规定的事件流包括三个阶段</p>
<p>事件捕获阶段：为截获事件提供机会</p>
<p>处于目标阶段：实际的目标接受事件</p>
<p>事件冒泡阶段:   可以在这个阶段对事件做出响应</p>
<p>虽然捕获阶段在规范中规定不允许响应事件，但是实际上还是会执行，所以有两次机会获取到目标对象。</p>
<p>DOM3 级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件</p>
<p>主要有：使用 focusin 和 focusout 不冒泡 代替冒泡的 focus blur 使用 mouseenter mouseleave 不冒泡代替冒泡的 mouseout 和 mouseover</p>
<p>还支持 wheel 事件 还有规范了 textinput 系列事件 keyup keypress keydown 等事件中的参数</p>
<h1 id="事件代理（Event-Delegation），又称之为事件委托"><a href="#事件代理（Event-Delegation），又称之为事件委托" class="headerlink" title="事件代理（Event Delegation），又称之为事件委托"></a>事件代理（Event Delegation），又称之为事件委托</h1><p>事件的冒泡（Bubble）</p>
<p>所谓的冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1.onclick = function(event) &#123;</span><br><span class="line">    //可以将事件对象的cancelBubble设置为true，即可取消冒泡</span><br><span class="line">    // event.cancelBubble = true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;mouseover&quot;, myFunction);</span><br></pre></td></tr></table></figure>

<h2 id="委派"><a href="#委派" class="headerlink" title="委派"></a>委派</h2><p>将事件统一绑定给元素<strong>共同的祖先元素</strong>（后代元素事件触发时，通过冒泡，通过祖先元素的响应函数来处理事件）<br>这样可以只绑定一次，即可应用到多个元素上</p>
<p>事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能</p>
<h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><p>event.preventDefault()              // 阻止默认事件,例如 a 标签的跳转行为 event.stopPropagation()             // 阻止冒泡</p>
<p>event.stopImmediatePropagation()    // 事件响应优先级：例如同一元素绑定不同事件时，触发 a 事件不让 b 事件触发</p>
<p>event.currentTarget                 // 当前绑定事件的元素</p>
<p>event.target                        // 当前被点击的元素</p>
<h1 id="new-一个函数发生了什么"><a href="#new-一个函数发生了什么" class="headerlink" title="new 一个函数发生了什么"></a>new 一个函数发生了什么</h1><p>构造调用：</p>
<ul>
<li>创造一个全新的对象</li>
<li>这个对象会被执行 Prototype 连接，将这个新对象的 Prototype 链接到这个构造函数 prototype 所指向的对象</li>
<li>这个新对象会绑定到函数调用的 this</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>
</ul>
<p>新创建一个空对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fn = new Object();</span><br></pre></td></tr></table></figure>

<p>Fn.prototype = fn.<strong>proto</strong></p>
<p>如果没有手动返回其他任何对象或返回值是基本类型（Number、String、Boolean）的值，会返回 this 指向的新对象，也就是实例，若返回值是引用类型（Object、Array、Function）的值，则实际返回值为这个引用类型。</p>
<p>自己手写实现一个简单的 new</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function myNew() &#123;</span><br><span class="line">	// 创建一个新对象</span><br><span class="line">    let newObj = &#123;&#125;;</span><br><span class="line">    // 获取构造函数</span><br><span class="line">    let Constructor = Array.prototype.shift.call(arguments);</span><br><span class="line">    //Array.prototype.shift.call：将参数转为一个数组　</span><br><span class="line">    // 连接新对象原型，新对象可以访问原型中的属性</span><br><span class="line">    newObj.__proto__ = Constructor.prototype;</span><br><span class="line">    // 执行构造函数，即绑定 this，并且为这个新对象添加属性</span><br><span class="line">    Constructor.apply(newObj, arguments);</span><br><span class="line">    // 返回该对象</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br><span class="line">    function person(name, age) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    let obj = myNew(person)(&#x27;li&#x27;, 18)</span><br><span class="line">    console.log(obj)</span><br></pre></td></tr></table></figure>

<h1 id="构造函数要用-new-来调用，而不是直接调用？"><a href="#构造函数要用-new-来调用，而不是直接调用？" class="headerlink" title="构造函数要用 new 来调用，而不是直接调用？"></a>构造函数要用 new 来调用，而不是直接调用？</h1><p>用 new 调用的时候，会新建一个空的实例对象，将构造函数的显示原型等于实例的隐式原型，会将构造函数原型上的属性和方法都继承到实例对象中，会将 this 指向这个新实例对象</p>
<p>如果不用 new 调用的话就相当于是一个普通函数，this 会指向 window，也无法继承构造函数的任何属性。</p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>箭头函数中没有 Construct 方法，不能使用 new 调用，会报错。除了箭头函数之外的任何函数都可以 new。</p>
<p>1.箭头函数是匿名函数，不能作为构造函数，不能使用 new</p>
<p>2.箭头函数没有原型属性</p>
<p>3.箭头函数本身不创建 this</p>
<h2 id="原型链和原型链的继承"><a href="#原型链和原型链的继承" class="headerlink" title="原型链和原型链的继承"></a>原型链和原型链的继承</h2><p><strong>什么是原型链？</strong></p>
<p>当对象查找一个属性的时候，如果没有在自身找到，那么就会查找自身的原型，如果原型还没有找到，那么会继续查找原型的原型，直到找到 Object.prototype 的原型时，此时原型为 null，查找停止。 这种通过原型链接的逐级向上的查找链被称为原型链</p>
<p><strong>什么是原型继承？</strong></p>
<p>一个对象可以使用另外一个对象的属性或者方法，就称之为继承。具体是通过将这个对象的原型设置为另外一个对象，这样根据原型链的规则，如果查找一个对象属性且在自身不存在时，就会查找另外一个对象，相当于一个对象可以使用另外一个对象的属性和方法了。</p>
<h1 id="js-继承"><a href="#js-继承" class="headerlink" title="js 继承"></a>js 继承</h1><h2 id="一、原型链继承"><a href="#一、原型链继承" class="headerlink" title="一、原型链继承"></a>一、原型链继承</h2><p><img src="https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162054267-1200211276.png#id=GipjJ&originHeight=148&originWidth=444&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162110117-1744170661.png#id=sgwi9&originHeight=192&originWidth=414&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="><br>　重点：让新实例的原型等于父类的实例。<br>　特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）<br>　缺点：1、新实例无法向父类构造函数传参。（无法传值）<br>　　　　 2、继承单一。<br>　　　　 3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）（改一个两个都会变）</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>二、借用构造函数继承</p>
<p><img src="https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162054267-1200211276.png#id=l6Ti7&originHeight=148&originWidth=444&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162125772-1830945749.png#id=OENBt&originHeight=176&originWidth=414&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="><br>　　　　重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制）<br>　　　　特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。<br>　　　　　　　 2、解决了原型链继承缺点 1、2、3。<br>　　　　　　　 3、可以继承多个构造函数属性（call 多个）。<br>　　　　　　　 4、在子实例中可向父实例传参。<br>　　　　缺点：1、只能继承父类构造函数的属性。<br>　　　　　　　 2、无法实现构造函数的复用。（每次用每次都要重新调用）<br>　　　　　　　 3、每个新实例都有父类构造函数的副本，臃肿。</p>
<h2 id="三、组合继承（组合原型链继承和借用构造函数继承）（常用）"><a href="#三、组合继承（组合原型链继承和借用构造函数继承）（常用）" class="headerlink" title="三、组合继承（组合原型链继承和借用构造函数继承）（常用）"></a>三、组合继承（组合原型链继承和借用构造函数继承）（常用）</h2><p><img src="https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162054267-1200211276.png#id=SmMNi&originHeight=148&originWidth=444&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">　　　　 <img src="https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162137084-1234623120.png#id=Xl0tK&originHeight=157&originWidth=434&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="><br>重点：结合了两种模式的优点，传参和复用<br>特点：1、可以继承父类原型上的属性，可以传参，可复用。<br>　　　 2、每个新实例引入的构造函数属性是私有的。<br>缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</p>
<h2 id="类操作继承"><a href="#类操作继承" class="headerlink" title="类操作继承"></a>类操作继承</h2><p>在之前定义类是通过构造函数来操作的，es6 新增了 class 关键字，此时，我们也可以像其它语言一样来创建各种类了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    constructor(name, age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    print()&#123;</span><br><span class="line">        console.log(&#x27;我叫&#x27; + this.name + &#x27;,今年&#x27; + this.age + &#x27;岁&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">         constructor(x, y) &#123;</span><br><span class="line">             this.x = x;  //this.x这样这个x函数体内的所有函数都可以访问了</span><br><span class="line">             this.y = y;</span><br><span class="line">         &#125;</span><br><span class="line">         sum() &#123;</span><br><span class="line">             console.log(this.x + this.y);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     class Son extends Father &#123;</span><br><span class="line">         constructor(x, y) &#123;</span><br><span class="line">             super(x, y); //调用了父类中的构造函数</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     var son = new Son(1, 2);</span><br><span class="line">     var son1 = new Son(11, 22);</span><br><span class="line">     son.sum();</span><br><span class="line">     son1.sum();</span><br></pre></td></tr></table></figure>

<p>继承中的属性或者方法查找原则: 就近原则</p>
<ol>
<li> 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的</li>
<li> 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// super.say() 就是调用父类中的普通函数 say()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// constructor 里面的this 指向的是 创建的实例对象</span><br></pre></td></tr></table></figure>

<h1 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h1><p>1.var a = {} 其实是 var a = new Object()的语法糖 （a 的构造函数是 Object 函数）<br>2.var a = [] 其实是 var a = new Array()的语法糖  （a 的构造函数是 Array 函数）<br>3.function Foo(){…}其实是 var Foo = new Function(…)   （Foo 的构造函数是 Function 函数）</p>
<h1 id="TCP-的三次握手和四次挥手"><a href="#TCP-的三次握手和四次挥手" class="headerlink" title="TCP 的三次握手和四次挥手"></a>TCP 的三次握手和四次挥手</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>第一次握手：客户端发送一个 SYN 码给服务器，要求建立数据连接；</p>
<p>第二次握手： 服务器 SYN 和自己处理一个 SYN（标志）；叫 SYN+ACK（确认包）；发送给客户端，可以建立连接</p>
<p>第三次握手： 客户端再次发送 ACK 向服务器，服务器验证 ACK 没有问题，则建立起连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYN表示建立连接，</span><br><span class="line">FIN表示关闭连接，</span><br><span class="line">ACK表示响应，</span><br><span class="line">PSH表示有DATA数据传输，</span><br><span class="line">RST表示连接重置。</span><br></pre></td></tr></table></figure>

<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>第一次挥手： 客户端发送 FIN(结束)报文，通知服务器数据已经传输完毕；</p>
<p>第二次挥手: 服务器接收到之后，通知客户端我收到了 SYN,发送 ACK(确认)给客户端，数据还没有传输完成</p>
<p>第三次挥手： 服务器已经传输完毕，再次发送 FIN 通知客户端，数据已经传输完毕</p>
<p>第四次挥手： 客户端再次发送 ACK,进入 TIME_WAIT 状态；服务器和客户端关闭连接；</p>
<p>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</p>
<p>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</p>
<p>为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>答：因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，”你发的 FIN 报文我收到了”。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步握手。</p>
<h2 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h2><p>三次握手为了传输正常流畅</p>
<p>为了通信安全</p>
<p>两边要确认身份至少需要三次</p>
<h1 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h1><p><strong>1.什么是 vue 生命周期？有什么作用？</strong><br>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。</p>
<p>同时在这个过程中也会运行一些叫做 生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。<br><strong>3.简述每个周期具体适合哪些场景</strong><br>beforeCreate：在 new 一个 vue 实例后，只有一些默认的生命周期钩子和默认事件，其他的东西都还没创建。</p>
<p>在 beforeCreate 生命周期执行的时候，data 和 methods 中的数据都还没有初始化。</p>
<p>不能在这个阶段使用 data 中的数据和 methods 中的方法<br>create：data 和 methods 都已经被初始化好了，如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作<br>beforeMount：执行到这个钩子的时候，在内存中已经编译好了模板了，但是还没有挂载到页面中，此时，页面还是旧的<br>mounted：执行到这个钩子的时候，就表示 Vue 实例已经初始化完成了。此时组件脱离了创建阶段，进入到了运行阶段。 如果我们想要通过插件操作页面上的 DOM 节点，最早可以在和这个阶段中进行<br>beforeUpdate： 当执行这个钩子时，页面中的显示的数据还是旧的，data 中的数据是更新后的， 页面还没有和最新的数据保持同步<br>updated：页面显示的数据和 data 中的数据已经保持同步了，都是最新的<br>beforeDestory：Vue 实例从运行阶段进入到了销毁阶段，这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于可用状态。还没有真正被销毁</p>
<p>运用场景：清除计时器、清除非指令绑定的事件等等</p>
<p>destroyed： 这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于不可用状态。组件已经被销毁了。</p>
<p>调用后，Vue 实例指示的所有东西都会解绑，所有的事件监听都会解绑，所有的子实例也会被消除。</p>
<h3 id="vue-生命周期的应用场景："><a href="#vue-生命周期的应用场景：" class="headerlink" title="vue 生命周期的应用场景："></a>vue 生命周期的应用场景：</h3><p>beforeCreate 可以在此时加一些 loading 效果，在 created 时进行移除</p>
<p>created 需要异步请求数据的方法可以在此时执行，完成数据的初始化</p>
<p>mounted 当需要操作 dom 的时候执行，可以配合$.nextTick 使用进行单一事件对数据的更新后更新 dom</p>
<p>updated 当数据更新需要做统一业务处理的时候使用</p>
<p><strong>4.created 和 mounted 的区别</strong><br>created:在模板渲染成 html 前调用，即通常初始化某些属性值，然后再渲染成视图。<br>mounted:在模板渲染成 html 后调用，通常是初始化页面完成后，再对 html 的 dom 节点进行一些需要的操作。<br><strong>5.vue 获取数据在哪个周期函数</strong><br>一般 created/beforeMount/mounted 皆可.<br>比如如果你要操作 DOM , 那肯定 mounted 时候才能操作.</p>
<p><strong>Cookie 具有不可跨域名性</strong></p>
<p>Cookie 实际上是一小段的文本信息</p>
<p><strong>Cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话</strong></p>
<p><strong>Session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</strong></p>
<p><strong>1、cookie 数据存放在客户的浏览器上，session 数据放在服务器上.</strong></p>
<p>简单的说，当你登录一个网站的时候，如果 web 服务器端使用的是 session,那么所有的数据都保存在服务器上面，</p>
<p>客户端每次请求服务器的时候会发送 当前会话的 session_id，服务器根据当前 session_id 判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。</p>
<p>Session 是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的 SessionID,用该 SessionID 为标识符来存取服务器端的 Session 存储空间。</p>
<p>SessionID 这一数据则是保存到客户端，用 Cookie 保存的，用户提交页面时，会将这一 SessionID 提交到服务器端，来存取 Session 数据。</p>
<p>这一过程，是不用开发人员干预的。所以一旦客户端禁用 Cookie，那么 Session 也会失效。</p>
<p>区别：浏览器页面一关 ,session 就消失了，cookie 是预先设置的生存周期，或永久的保存于本地的文件。</p>
<p>关闭浏览器 session 就被清除只是我们所看到的表面现象(实际上是新建了一个 session 对象)，通常情况下，服务器并不会马上清除 session 对象，但这个根据服务端的设定而不同。</p>
<p>如果用户禁用 cookie，则要使用 URL 重写，可以通过 response.encodeURL(url) 进行实现；当浏览器支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 的时候，将会重写 URL 将 SessionID 拼接到访问地址后。</p>
<p>实现 mvvm 主要包含两个方面，数据变化更新视图，视图变化更新数据：</p>
<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>1：总页数（计算的得出）<br>2：总记录数（查询得出）<br>3：显示行数（用户定义）<br>4：当前页数（变量）<br>5：开始位置（计算得出）<br>6：结束位置（计算得出）</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>通过量词可以设置一个内容出现的次数</p>
<p>量词只对它前边的一个内容起作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;n&#125; 正好出现n次</span><br><span class="line">&#123;m,n&#125; 出现m-n次</span><br><span class="line">&#123;m,&#125; m次以上</span><br><span class="line">+ 至少一个，相当于&#123;1,&#125;</span><br><span class="line">* 0个或多个，相当于&#123;0,&#125;</span><br><span class="line">? 0个或1个，相当于&#123;0,1&#125;</span><br></pre></td></tr></table></figure>

<p>^ 表示开头</p>
<p>$ 表示结尾</p>
<h1 id="BFC-规范"><a href="#BFC-规范" class="headerlink" title="BFC 规范"></a>BFC 规范</h1><p>BFC 即 Block Formatting Contexts (块级格式化上下文)</p>
<p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p>
<p>特性<br>1、内部的 Box 会在垂直方向，从顶部开始一个接一个地放置。</p>
<p>2、Box 垂直方向的距离由 margin 决定。</p>
<p>3、在 BFC 中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘），即使存在浮动也是如此</p>
<p>4、BFC 的区域不会与 float box 叠加</p>
<p>5、BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</p>
<p>6、计算 BFC 的高度时，浮动元素也参与计算</p>
<p>如何触发 BFC<br>浮动元素：float 除 none 以外的值（left,right）</p>
<p>绝对定位元素：position（absolute，fixed）</p>
<p>display 为 inline-block、table-cells、flex</p>
<p>overflow 除了 visible 以外的值（hidden，auto，scroll）</p>
<p>BFC 规范的应用<br>1.margin 叠加问题</p>
<p>触发 BFC 后，margin 由触发前（margin 叠加）的 20px 变为了 40px</p>
<p><img src="https://img-blog.csdnimg.cn/20200710192655748.png#id=zCScC&originHeight=250&originWidth=117&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>2.margin 传递</p>
<p><img src="https://img-blog.csdnimg.cn/2020071019423921.png#id=HYEli&originHeight=169&originWidth=180&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>3.浮动问题</p>
<p><img src="https://img-blog.csdnimg.cn/202007101949243.png#id=AEQ9L&originHeight=164&originWidth=234&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>观察下图（左图是触发 BFC 前的，右图是触发之后的）</p>
<p>4.覆盖问题</p>
<p><img src="https://img-blog.csdnimg.cn/20200710202315846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z5bHh5MDAw,size_16,color_FFFFFF,t_70#id=Oo95o&originHeight=246&originWidth=1365&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://img-blog.csdnimg.cn/20200710202336549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z5bHh5MDAw,size_16,color_FFFFFF,t_70#id=TJLIJ&originHeight=259&originWidth=1365&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>BFC 可以解决的问题</p>
<p>1、margin 叠加的问题，我们将某个元素放到我们新建的 BFC 里面就可以避免 margin 叠加、</p>
<p>2、对于左右布局的元素，我们可以给右侧的元素添加 overflow:hidden 或者 auto，左侧的是 float:left</p>
<p>3、可以清除浮动，计算 BFC 高度，浮动元素不会撑开父元素的高度，我们可以让父元素触发 BFC,即使用 overflow:hidden</p>
<h1 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h1><p>let 不可以重复声明变量、不存在变量提升、支持块级作用域</p>
<p>const 用来定义常量</p>
<p>let 声明的变量不会污染全局作用域。</p>
<p>const 定义的基本类型不能改变，但是定义的对象是可以通过修改对象属性等方法来改变的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;let site = &#x27;itLike&#x27;;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>对象解构允许我们使用变量的名字匹配对象的属性 匹配成功 将对象属性的值赋值给变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;name: &#x27;lisi&#x27;, age: 30, sex: &#x27;男&#x27;&#125;;</span><br><span class="line">let &#123;name: myName&#125; = person;</span><br><span class="line">console.log(myName)</span><br></pre></td></tr></table></figure>

<p>解构赋值</p>
<ul>
<li>左右两个边结构必须一样</li>
<li>右边必须是个东西</li>
<li>声明和赋值赋值不能分开，必须在一句话里</li>
<li>解构赋值是浅拷贝</li>
</ul>
<h1 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h1><h2 id="获取自身属性"><a href="#获取自身属性" class="headerlink" title="获取自身属性"></a>获取自身属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 用于获取对象自身所有的属性</span><br><span class="line">var obj = &#123;</span><br><span class="line">    id: 1,</span><br><span class="line">    pname: &#x27;小米&#x27;,</span><br><span class="line">    price: 1999,</span><br><span class="line">    num: 2000</span><br><span class="line">&#125;;</span><br><span class="line">var arr = Object.keys(obj);</span><br><span class="line">console.log(arr);//属性名</span><br><span class="line">arr.forEach(function(value) &#123;</span><br><span class="line">    console.log(value);//值</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h1><p>1）set</p>
<p>一个 Set 是一堆东西的集合，Set 有点像数组，不过跟数组不一样的是，Set 里面不能有重复的内容；</p>
<ol start="2">
<li>map 两个值</li>
</ol>
<p>Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。</p>
<p>如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<p>它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p>
<p>实例属性和方法：size、set、get、has、delete、clear</p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>我们可以说代理对象是我们的目标对象的包装器，我们可以在其中操纵其属性并阻止对它的直接访问。</p>
<p>Proxy 用于修改某些操作的默认行为，即对编程语言层面进行修改，属于“元编程”，Proxy 意思为“代理”，即在访问对象之前建立一道“拦截”，任何访问该对象的操作之前都会通过这道“拦截”，即执行 Proxy 里面定义的方法。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>当您需要对数据进行更多控制时，代理可以派上用场。</p>
<p>你可以根据受控规则扩展或拒绝对原始数据的访问，从而监视对象并确保正确行为。</p>
<p>ES6 原生规定的 Proxy 的基本用法为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let pro = new Proxy(target,handler);</span><br></pre></td></tr></table></figure>

<p>其中 new Proxy 相当于创建了一个 Proxy 实例，target 为所要拦截的目标对象，handler 也是一个对象，里面定义的是对拦截对象所要进行的拦截方法。</p>
<p>Proxy 实例 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> let target = &#123;</span><br><span class="line">      name:&quot;小明&quot;，</span><br><span class="line">      age: 15</span><br><span class="line"> &#125;</span><br><span class="line"> let handler = &#123;</span><br><span class="line">       get:(target,name)=&gt;&#123;//读取属性</span><br><span class="line">             return &quot;success&quot;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line">let pro = new Proxy(target,handler);</span><br><span class="line">console.log(pro.name);</span><br><span class="line">//此时打印出来的结果为 success；</span><br></pre></td></tr></table></figure>

<p>解释：创建的 target 对象为所要拦截的对象</p>
<p>handler 对象为拦截对象后执行的操作</p>
<p>这里 get 方法为读取操作，即用户想要读取 pro 中的属性时执行的拦截操作。最后创建一个 Proxy 实例，因为我设定的读取拦截操作为返回一个“success”字符串，所以当我想读取 pro 中的属性时，结果打印出来的总是“success”字符串。</p>
<p>（2）Proxy 常用的拦截方法</p>
<p>1、get(target,name,property)方法，用于拦截某个读取属性的操作</p>
<p>第一个参数为目标对象</p>
<p>第二个参数为属性名称</p>
<p>第三个属性为操作所针对的对象（可选参数）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> let handler = &#123;</span><br><span class="line">          get:function(target,name,property)&#123;</span><br><span class="line">               if(name in target)&#123;</span><br><span class="line">                      cosnole.log(&quot;success&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                      console.log(&quot;error&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                return Reflect.get(target,name,property);</span><br><span class="line">           &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let target =  &#123;</span><br><span class="line">       name:&quot;小明&quot;,</span><br><span class="line">       age:15</span><br><span class="line"> &#125;</span><br><span class="line"> let pro = new Proxy(target,handler);</span><br><span class="line"> pro.name;</span><br><span class="line">//结果为 success</span><br><span class="line"> pro.grade;</span><br><span class="line"> //结果为error</span><br></pre></td></tr></table></figure>

<p>2、set(target,name,value,property),用于拦截某个属性的赋值操作，第一个参数为目标对象，第二个参数为属性名，第三个参数为属性值，第四个参数为操作行为所针对的对象（可选参数）。</p>
<p>3、has(target,key),用来拦截对象是否具有某个属性值的操作，第一个参数为目标对象，第二个参数为属性名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> let handler = &#123;</span><br><span class="line">        has:function(target,key)&#123;</span><br><span class="line">               if(key[0] != &quot;_&quot;)&#123;</span><br><span class="line">                      return  false</span><br><span class="line">               &#125;</span><br><span class="line">               return true;</span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> let target =  &#123;</span><br><span class="line">      _name:&quot;小明&quot;,</span><br><span class="line">      age:15</span><br><span class="line">&#125;</span><br><span class="line">let pro = new Proxy(target,handler);</span><br><span class="line">console.log(&quot;_name&quot; in pro);</span><br><span class="line">//打印结果为 true</span><br><span class="line">console.log(&quot;age&quot; in pro);</span><br><span class="line">//打印结果为false</span><br></pre></td></tr></table></figure>

<h3 id="Reflect-对象"><a href="#Reflect-对象" class="headerlink" title="Reflect 对象"></a>Reflect 对象</h3><h3 id="用处："><a href="#用处：" class="headerlink" title="用处："></a>用处：</h3><p>当 object 的工具类来用</p>
<p>Reflect 对象的方法与 Proxy 对象的方法一一对应，这使得 Proxy 对象可以方便的调用对应的 Reflect 方法完成默认行为。</p>
<p>简单说，就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p>
<p><code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p>
<p>概述</p>
<p>1、Reflect 对象与 Proxy 对象一样，都是 ES6 对操作对象设计的 API<br>2、对于我个人的理解而言，Reflect 设计的目的是为了优化 Object 的一些操作方法以及合理的返回 Object 操作返回的结果，对于一些命令式的 Object 行为，Reflect 对象可以将其变为函数式的行为</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul>
<li>映射 一个对一个</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [12, 5, 8]</span><br><span class="line">let result = arr.map(function (item) &#123;</span><br><span class="line">    return item*2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>汇总 一堆出来一个</p>
<ul>
<li>用于比如，算个总数，算个平均</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 3, 5, 7]</span><br><span class="line">var result = arr.reduce(function (tmp, item, index) &#123;</span><br><span class="line">    //tmp 上次结果，item当前数，index次数1开始</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;];</span><br><span class="line">var flag1 = arr1.some(function(value) &#123;</span><br><span class="line">    return value == &#x27;pink&#x27;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>filter 也是查找满足条件的元素 返回的是一个数组 而且是把所有满足条件的元素返回回来</p>
<p>some 也是查找满足条件的元素是否存在   返回的是一个布尔值 如果查找到第一个满足条件的元素就终止循环</p>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>过滤器 保留为 true 的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [12, 4, 8, 9]</span><br><span class="line">var result = arr.filter(item =&gt; (item % 3 === 0) ? true : false)</span><br></pre></td></tr></table></figure>

<h2 id="forEach-循环迭代"><a href="#forEach-循环迭代" class="headerlink" title="forEach 循环迭代"></a>forEach 循环迭代</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(function(value, index, array) &#123;</span><br><span class="line">    console.log(&#x27;每个数组元素&#x27; + value);</span><br><span class="line">    console.log(&#x27;每个数组元素的索引号&#x27; + index);</span><br><span class="line">    console.log(&#x27;数组本身&#x27; + array);</span><br><span class="line">    sum += value;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="map-与-foreach"><a href="#map-与-foreach" class="headerlink" title="map 与 foreach"></a>map 与 foreach</h2><p>1、map 速度比 foreach 快</p>
<p>2、map 会返回一个新数组，不对原数组产生影响,foreach 不会产生新数组，foreach 返回 undefined</p>
<p>3、map 因为返回数组所以可以链式操作，foreach 不能</p>
<p>4, map 里可以用 return ,而 foreach 里用 return 不起作用，foreach 不能用 break，会直接报错</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li>多了两个新方法<ul>
<li><code>startsWith</code></li>
<li><code>endsWith</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var url = &#x27;http://qq.com&#x27;</span><br><span class="line">console.log(url.startsWith(&#x27;http&#x27;))</span><br><span class="line">console.log(url.endsWith(&#x27;com&#x27;))</span><br></pre></td></tr></table></figure>

<p>判断是不是开头和结尾 结果是 true 和 false</p>
<p>repeat 可以重复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;y&quot;.repeat(5))</span><br></pre></td></tr></table></figure>

<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 的成员只能是对象，而不能是其他类型的值</p>
<p>WeakSet 不可遍历</p>
<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const s4 = new Set();</span><br></pre></td></tr></table></figure>

<p>向 set 结构中添加值 使用 add 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s4.add(&#x27;a&#x27;).add(&#x27;b&#x27;);</span><br><span class="line">console.log(s4.size)</span><br></pre></td></tr></table></figure>

<p>从 set 结构中删除值 用到的方法是 delete</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const r1 = s4.delete(&#x27;c&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(s4.size)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(r1); //删除成功true，失败false</span><br></pre></td></tr></table></figure>

<p>判断某一个值是否是 set 数据结构中的成员 使用 has</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const r2 = s4.has(&#x27;d&#x27;);</span><br><span class="line">console.log(r2)</span><br></pre></td></tr></table></figure>

<p>清空 set 数据结构中的值 使用 clear 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> s4.clear();</span><br><span class="line">console.log(s4.size);</span><br></pre></td></tr></table></figure>

<h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><ul>
<li>JSON 格式<ul>
<li>JavaScript Object Notation 的缩写，是一种用于数据交换的文本格式</li>
<li>JSON 是 JS 对象 的严格子集</li>
<li>只能用双引号</li>
<li>所有的 key 都必须用双引号包起来</li>
</ul>
</li>
<li>JSON 对象<ul>
<li>JSON 对象是 JavaScript 的原生对象，用来处理 JSON 格式数据，有两个静态方法</li>
<li>JSON.parse(string) ：接受一个 <strong>JSON 字符串</strong>并将其转换成一个 JavaScript <strong>对象</strong>。</li>
<li>JSON.stringify(obj) ：接受一个 JavaScript <strong>对象</strong>并将其转换为一个 <strong>JSON 字符串</strong>。</li>
</ul>
</li>
<li>对象（object）<ul>
<li>是 JavaScript 语言的核心概念，也是最重要的数据类型</li>
<li>对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合</li>
<li>对象的所有键名都是字符串, 所以加不加引号都可以</li>
<li>如果键名是数值，会被自动转为字符串</li>
<li>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型</li>
<li>如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用</li>
<li>in 运算符用于检查对象是否包含某个属性（检查的是键名，不是键值）</li>
<li>for…in 循环用来遍历一个对象的全部属性</li>
</ul>
</li>
</ul>
<h1 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h1><p>Generator 函数的定义</p>
<p>语法上，可以把理解成，Generator 函数是一个状态机，封装了多个内部状态。<br>形式上，Generator 函数是一个普通函数。它不同于普通函数，是可以暂停执行的，所以函数名之前要加星号，以示区别。<br>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器，异步操作需要暂停的地方，都用 yield 语句。<br>generator 的用途：<br>在 JavaScript 中,一个函数一旦被执行,就会执行到最后或者被 return,运行期间不会被外部所影响打断,而 generator 的出现就打破了这种函数运行的完整性。</p>
<p>应用场所</p>
<p>1、控制流管理</p>
<p>2、异步操作的同步化表达</p>
<p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态</p>
<p>认识生成器函数</p>
<ul>
<li>generator 生成器函数<ul>
<li>普通函数，一路到底</li>
<li>generator 函数，中间可以停，到哪停呢，用 yield 配合，交出执行权</li>
<li>yield 有 放弃、退让、退位的意思</li>
<li>需要调用 next()方法启动执行，需要遇到 yield 停, 踹一脚走一步</li>
<li>generator 函数前面加一个 <code>*</code> 两边可以有空格，或靠近函数或<code>function</code></li>
<li>背后实际生成多个小函数，实现走走停停</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function show() &#123;</span><br><span class="line">    console.log(&#x27;a&#x27;)</span><br><span class="line">    console.log(&#x27;b&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">show() // 普通函数</span><br><span class="line">function *show2() &#123;</span><br><span class="line">    console.log(&#x27;1&#x27;)</span><br><span class="line">    yield</span><br><span class="line">    console.log(&#x27;2&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">let genObj = show2()</span><br><span class="line">genObj.next() // 1</span><br><span class="line">genObj.next() // 2</span><br><span class="line">genObj.next() // 最后了，没有结果</span><br></pre></td></tr></table></figure>

<h2 id="generator-yield-是啥"><a href="#generator-yield-是啥" class="headerlink" title="generator-yield 是啥"></a>generator-yield 是啥</h2><ul>
<li><code>yield</code><ul>
<li>既可传参，又可以返回</li>
<li>第一个<code>next()</code>传参无效，只用来启动</li>
</ul>
</li>
<li>如果函数前漏掉 <code>*</code><ul>
<li>就是普通函数</li>
<li>如果有<code>yield</code>会报错， <code>ReferenceError: yield is not defined</code></li>
<li>yield 只能在 Generator 函数内部使用</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function * show() &#123;</span><br><span class="line">    console.log(&#x27;1&#x27;)</span><br><span class="line">    var a = yield</span><br><span class="line">    console.log(&#x27;2&#x27;)</span><br><span class="line">    console.log(a)</span><br><span class="line">&#125;</span><br><span class="line">// yield 传参</span><br><span class="line">var gen = show()</span><br><span class="line">gen.next() // 1</span><br><span class="line">gen.next() // 2 和 undefined 因为没有传参，yield没有返回值</span><br><span class="line">var gen = show()</span><br><span class="line">gen.next(10) // 1 第一次执行到yield，但没有执行赋值</span><br><span class="line">gen.next(20) // 2 和 20</span><br><span class="line"></span><br><span class="line">function* show2() &#123;</span><br><span class="line">    console.log(&#x27;1&#x27;)</span><br><span class="line">    yield 10</span><br><span class="line">    console.log(&#x27;2&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">// yield 返回</span><br><span class="line">var gen = show2()</span><br><span class="line">var res1 = gen.next()</span><br><span class="line">console.log(res1) // &#123; value: 10, done: false &#125;</span><br><span class="line">var res2 = gen.next()</span><br><span class="line">console.log(res2)</span><br><span class="line">// &#123; value: undefined, done: true &#125; 最后的value需要return返回</span><br></pre></td></tr></table></figure>

<p>用处</p>
<p>暂停函数、懒加载之类的</p>
<h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><p>async 是 Generator 函数的语法糖。</p>
<p>如果一个方法标记了 async 关键字,那么这个方法被调用时就是异步执行；</p>
<p><strong>async 函数会返回一个 Promise 对象。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async function testAsync() &#123;</span><br><span class="line">   return “hello async”;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>async 函数返回的是一个 Promise 对象。如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise &#123; &#x27;hello async&#x27; &#125;</span><br></pre></td></tr></table></figure>

<p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">testAsync</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v); <span class="comment">// 输出 hello async</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p>
<p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二一致。</p>
<p>那么下一个关键点就在于 await 关键字了。</p>
<ul>
<li>如果 async 函数中是 return 一个值，这个值就是 Promise 对象中 resolve 的值；</li>
<li>如果 async 函数中是 throw 一个值，这个值就是 Promise 对象中 reject 的值。<br>什么要用 await<br>为了使我们的异步代码，更像同步的代码<br>“await 会暂停当前 async 函数的执行，等待后面的 Promise 的计算结果返回以后再继续执行当前的 async 函数。”<br>所以我们之前如果单纯的 await setTimeout(…) 或者 await exec(…) 是不行滴，await 不是什么都等，它等待的只是 Promise，你如果没有给他返回个 Promise，那它还是会继续向下执行。<br><strong>所以 await 等待的不是所有的异步操作，等待的只是 Promise。</strong><br>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">async函数的写法</span><br><span class="line">async function imAsync(num) &#123;</span><br><span class="line">  if (num &gt; 0) &#123;</span><br><span class="line">    return num // 这里相当于resolve(num)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw num // 这里相当于reject(num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">imAsync(1).then(function (v) &#123;</span><br><span class="line">  console.log(v); // 1</span><br><span class="line">&#125;);</span><br><span class="line">// 注意这里是catch</span><br><span class="line">imAsync(0).catch(function (v) &#123;</span><br><span class="line">  console.log(v); // 0</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>function getSomething() {<br>return “something”;<br>}<br>async function testAsync() {<br>return Promise.resolve(“hello async”);<br>}<br>async function test() {<br>const v1 = await getSomething();<br>const v2 = await testAsync();<br>console.log(v1, v2);<br>}<br>test();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**await 等到之后，做了一件什么事情？**</span><br><span class="line"> 那么右侧表达式的结果，就是await要等的东西。</span><br><span class="line"> 等到之后，对于await来说，分2个情况</span><br><span class="line"></span><br><span class="line">- 不是promise对象</span><br><span class="line"></span><br><span class="line">如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果。</span><br><span class="line"></span><br><span class="line">- 是promise对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。</span><br><span class="line"></span><br><span class="line">- 如果asycn里的代码都是同步的，那么这个函数被调用就会同步执行</span><br><span class="line"></span><br><span class="line">```jsx</span><br><span class="line">async function fn()&#123;</span><br><span class="line">  console.log(&#x27;a&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line">console.log(&#x27;b&#x27;)</span><br><span class="line">//a</span><br><span class="line">//b</span><br></pre></td></tr></table></figure>

<ul>
<li>如果在 await 后面接的这个 promsie 都是同步的，后面的 promise 会同步执行，但是拿到这个值还是得等待（特别注意：如果 promise 没有一个成功的值传入，对 await 来说就算是失败了，下面的代码就不会执行），所以不管 await 后面的代码是同步还是异步，await 总是需要时间，从右向左执行，先执行右侧的代码，执行完后，发现有 await 关键字，于是让出线程，阻塞代码</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>这个代码因为 fn 是属于同步的，所以先打印出 1，然后是 3，但是因为没有 resolve 结果，所以 await 拿不到值，因此不会打印 2</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>这个代码与前面相比多了个 resolve 说明 promise 成功了，所以 await 能拿到结果，因此就是 1 3 2</p>
<h4 id="3-async-await-诞生的初衷（是要解决什么问题？）"><a href="#3-async-await-诞生的初衷（是要解决什么问题？）" class="headerlink" title="3. async/await 诞生的初衷（是要解决什么问题？）"></a>3. async/await 诞生的初衷（是要解决什么问题？）</h4><p>“async/await 是为了简化多个 Promise 的同步操作，就像 Promise 要解决层层嵌套的回调函数的问题一样</p>
<p>所以 async/await 就是要完善 Promise 还不够完美的地方，是在 Promise 的基础上进行改进的，因此也很好理解为什么 await 只能“等待”Promise 对象。</p>
<h3 id="四、个人对-async-await-的理解"><a href="#四、个人对-async-await-的理解" class="headerlink" title="四、个人对 async/await 的理解"></a>四、个人对 async/await 的理解</h3><p>async/await 是在 Promise 之后产生的，它和 Promise 诞生的目的都是为了解决“回调地狱”。</p>
<p>所以我发现 async/await 是在 Promise 的基础上做了改进，await 是接收一个 Promise 对象，而当 Promise 执行到 resolve()或者 reject()的时候（fulfilled 和 rejected），await 才会继续往下执行。</p>
<p>所以关键点就是<strong>得是返回 Promise 对象的函数</strong>才行，不然 await 等你后面的函数执行完了，见你没返回 Promise 对象，那他就继续执行了，不管你了。</p>
<h1 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h1><p>第七种数据类型</p>
<p>生成唯一的标识符来避免冲突</p>
<p>不能被遍历</p>
<p>可以用于当做私有属性</p>
<p>应用场景</p>
<p>1.使用 Symbol 来替代常量</p>
<p>2.使用 Symbol 来作为对象属性名(key)</p>
<h1 id="ES7-预览"><a href="#ES7-预览" class="headerlink" title="ES7 预览"></a>ES7 预览</h1><ul>
<li>数组<ul>
<li><code>arr.includes()</code> 数组是否包含某个东西</li>
<li>数组的 arr.keys(), arr,entries()</li>
<li>for … in 遍历数组 下标 key</li>
<li>for … of 遍历数组 值 value, 不能用于 json</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="line">console.log(arr.includes(1))</span><br><span class="line">for (let i in arr) &#123;</span><br><span class="line">    console.log(i) // 循环的时下标 key</span><br><span class="line">&#125;</span><br><span class="line">for (let i of arr) &#123;</span><br><span class="line">    console.log(i) // 循环的是值 value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串</li>
<li>padStart()/padEnd() 指定宽度，不够就补空格或指定字符</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;=&#x27; + &#x27;abcd&#x27;.padStart(6, &#x27;0&#x27;) + &#x27;=&#x27;)</span><br><span class="line">console.log(&#x27;=&#x27; + &#x27;abcd&#x27;.padEnd(6, &#x27;0&#x27;) + &#x27;=&#x27;)</span><br><span class="line">=00abcd=</span><br><span class="line">=abcd00=</span><br></pre></td></tr></table></figure>

<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>设置父容器为伸缩盒子：会使每一个子元素自动变成伸缩项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br></pre></td></tr></table></figure>

<h2 id="排列方式"><a href="#排列方式" class="headerlink" title="排列方式"></a>排列方式</h2><p>设置子元素的排列方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">justify-content</span><br><span class="line">- 如何分配主轴上的空白空间（主轴上的元素如何排列）</span><br></pre></td></tr></table></figure>

<p>flex-start:让子元素从父容器的起始位置开始排列</p>
<p>flex-end:让子元素从父容器的结束位置开始排列</p>
<p>center:让子元素从父容器的中间位置开始排列</p>
<p>space-between:左右对齐父容器的开始和结束，中间平均分页，产生相同的间距</p>
<p>space-around:将多余的空间平均的分页在每一个子元素的两边</p>
<p>margin:0 auto.造成中间盒子的间距是左右两边盒子间距的两倍</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content: space-around;</span><br></pre></td></tr></table></figure>

<h2 id="控制换行"><a href="#控制换行" class="headerlink" title="控制换行"></a>控制换行</h2><p>flex-wrap:控制子元素是否换行显示，默认不换行</p>
<p>nowrap:不换行–则收缩</p>
<p>wrap:换行</p>
<p>wrap-reverse:翻转，原来是从上到下，翻转后就是从下到上来排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap: wrap;</span><br></pre></td></tr></table></figure>

<p>flex-direction：设置子元素的排列方向：就是用来主轴方向，默认主轴方向是 row(水平方向)</p>
<p>row:水平排列方向，从左到右</p>
<p>row-reverse:水平排列方向，从右到左</p>
<p>column:垂直排列方向，从上到下</p>
<p>column-reverse：垂直排列方向，从下到上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-direction: column-reverse;</span><br></pre></td></tr></table></figure>

<p>flex-flow:是 flex-wrap 和 flex-direction 的综合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-flow: row wrap;</span><br></pre></td></tr></table></figure>

<h2 id="侧轴方向上的对齐方式（垂直居中）"><a href="#侧轴方向上的对齐方式（垂直居中）" class="headerlink" title="侧轴方向上的对齐方式（垂直居中）"></a>侧轴方向上的对齐方式（垂直居中）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 元素在辅轴上如何对齐</span><br><span class="line">- 元素间的关系</span><br></pre></td></tr></table></figure>

<p>align-items:设置子元素(伸缩项)在侧轴方向上的对齐方式</p>
<p>center:设置在侧轴方向上居中对齐</p>
<p>flex-start:设置在侧轴方向上顶对齐</p>
<p>flex-end:设置在侧轴方向上底对齐</p>
<p>stretch:拉伸：让子元素在侧轴方向上进行拉伸，填充满整个侧轴方向&gt;&gt; 默认值</p>
<p>baseline:文本基线</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: center;</span><br></pre></td></tr></table></figure>

<p><strong>align-content</strong>属性值就是 align-items 的值</p>
<p>一个元素可以既是弹性盒子，又是子元素</p>
<h2 id="子元素属性"><a href="#子元素属性" class="headerlink" title="子元素属性"></a>子元素属性</h2><p>flow-grow:可以来扩展子元素的宽度：设置当前元素应该占据剩余空间的比例值</p>
<p>比例值计算 ：当前空间的 flex-grow/所有兄弟元素的 flex-grow 的和</p>
<p>flex-grow 的默认是 0:说明子元素并不会去占据剩余的空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-grow: 1;</span><br></pre></td></tr></table></figure>

<p>flex-shrink:定义收缩比例，通过设置的值来计算收缩空间</p>
<p>比例值计算 ：当前空间的 flex-shrink/所有兄弟元素的 flex-shrink 的和</p>
<p>默认值为 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-shrink: 3;</span><br></pre></td></tr></table></figure>

<p>flex 是用来设置当前伸缩子项占据剩余空间的比例值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex: 1;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex 可以设置弹性元素所有的三个样式</span><br><span class="line">flex 增长 缩减 基础;</span><br><span class="line">initial &quot;flex: 0 1 auto&quot;.</span><br><span class="line">auto  &quot;flex: 1 1 auto&quot;</span><br><span class="line">none &quot;flex: 0 0 auto&quot; 弹性元素没有弹性</span><br></pre></td></tr></table></figure>

<p><strong>align-self: flex-start; 子元素内可以再次单独调整位置</strong></p>
<p>align-self: 用来覆盖当前弹性元素上的 align-items ，属性值就是 align-items 的值</p>
<p>center:设置在侧轴方向上居中对齐</p>
<p>flex-start:设置在侧轴方向上顶对齐</p>
<p>flex-end:设置在侧轴方向上底对齐</p>
<p>stretch:拉伸：让子元素在侧轴方向上进行拉伸，填充满整个侧轴方向&gt;&gt; 默认值</p>
<p>baseline:文本基线</p>
<h2 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h2><p>meta 主要用于设置网页中的一些元数据，元数据不是给用户看</p>
<p>charset 指定网页的字符集</p>
<p>name 指定的数据的名称</p>
<p>content 指定的数据的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;HTML5,前端,CSS3&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;description&quot; content=&quot;这是一个非常不错的网站&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>name 的可选项</p>
<ul>
<li>description 用于指定网站的描述</li>
<li>keywords 表示网站的关键字，可以同时指定多个关键字，关键字间使用,隔开</li>
</ul>
<h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><p>块元素会在页面中独占一行(自上向下垂直排列)</p>
<p>默认宽度是父元素的全部（会把父元素撑满）</p>
<p>默认高度是被内容撑开（子元素）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;form&gt;</span><br></pre></td></tr></table></figure>

<h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><p>行内元素不会独占页面的一行，只占自身的大小</p>
<p>行内元素的默认宽度和高度都是被内容撑开</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;...&lt;/span&gt;</span><br><span class="line">&lt;a&gt;...&lt;/a&gt;  链接</span><br><span class="line">&lt;br&gt;  换行</span><br><span class="line">&lt;b&gt;...&lt;/b&gt;  加粗</span><br><span class="line">&lt;strong&gt;...&lt;/strong&gt;  加粗</span><br><span class="line">&lt;img &gt;  图片</span><br></pre></td></tr></table></figure>

<p>行内元素不支持设置宽度和高度</p>
<p>行内元素可以设置 padding，但是垂直方向 padding 不会影响页面的布局</p>
<p>行内元素可以设置 border，垂直方向的 border 不会影响页面的布局</p>
<p>行内元素可以设置 margin，垂直方向的 margin 不会影响布局</p>
<h1 id="less"><a href="#less" class="headerlink" title="less"></a>less</h1><p>less 是一个 css 的增强版，通过 less 可以编写更少的代码实现更强大的样式</p>
<p>在 less 中添加了许多的新特性：像对变量的支持、对 mixin 的支持… …</p>
<p>less 的语法大体上和 css 语法一致，但是 less 中增添了许多对 css 的扩展，</p>
<p>所以浏览器无法直接执行 less 代码，要执行必须向将 less 转换为 css，然后再由浏览器执行</p>
<h2 id="可以嵌套"><a href="#可以嵌套" class="headerlink" title="可以嵌套"></a>可以嵌套</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.box1&#123;</span><br><span class="line">    background-color: #bfa;</span><br><span class="line">    .box2&#123;</span><br><span class="line">        background-color: #ff0;</span><br><span class="line">        .box4&#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .box3&#123;</span><br><span class="line">        background-color: orange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可以使用变量"><a href="#可以使用变量" class="headerlink" title="可以使用变量"></a>可以使用变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//变量，在变量中可以存储一个任意的值</span><br><span class="line">// 并且我们可以在需要时，任意的修改变量中的值</span><br><span class="line">// 变量的语法： @变量名</span><br><span class="line">@a:200px;</span><br><span class="line">@b:#bfa;</span><br><span class="line">@c:box6;</span><br><span class="line">.box5&#123;</span><br><span class="line">    //使用变量是，如果是直接使用则以 @变量名 的形式使用即可</span><br><span class="line">    width: @a;</span><br><span class="line">    color:@b;</span><br><span class="line">&#125;</span><br><span class="line">//作为类名，或者一部分值使用时必须以 @&#123;变量名&#125; 的形式使用</span><br><span class="line">.@&#123;c&#125;&#123;</span><br><span class="line">    width: @a;</span><br><span class="line">    background-image: url(&quot;@&#123;c&#125;/1.png&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表示当前层的用法"><a href="#表示当前层的用法" class="headerlink" title="表示当前层的用法"></a>表示当前层的用法</h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.box1&#123;</span><br><span class="line">    //为box1设置一个hover</span><br><span class="line">    //&amp; 就表示外层的父元素</span><br><span class="line">    &amp;:hover&#123;</span><br><span class="line">        color: orange;</span><br><span class="line">    &#125;</span><br><span class="line">    div &amp;&#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>//:extend() 对当前选择器扩展指定选择器的样式（选择器分组）</p>
<p>.p2:extend(.p1){</p>
<p>color: red;</p>
<p>}</p>
<h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用类选择器时可以在选择器后边添加一个括号，这时我们实际上就创建了一个mixins</span><br><span class="line">.p4()&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.p5&#123;</span><br><span class="line">    .p4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="混合函数"><a href="#混合函数" class="headerlink" title="混合函数"></a>混合函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//混合函数 在混合函数中可以直接设置变量</span><br><span class="line">.test(@w:100px,@h:200px,@bg-color:red)&#123;</span><br><span class="line">    width: @w;</span><br><span class="line">    height: @h;</span><br><span class="line">    border: 1px solid @bg-color;</span><br><span class="line">&#125;</span><br><span class="line">div&#123;</span><br><span class="line">    //调用混合函数，按顺序传递参数</span><br><span class="line">    // .test(200px,300px,#bfa);</span><br><span class="line">    .test(300px);</span><br><span class="line">    // .test(@bg-color:red, @h:100px, @w:300px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是说可以定义一个函数，然后这个函数里面也可以有默认值，这样的话，使用的时候不传值也能使用。</p>
<h2 id="运算和引入"><a href="#运算和引入" class="headerlink" title="运算和引入"></a>运算和引入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;syntax2.less&quot;;</span><br><span class="line">.box1&#123;</span><br><span class="line">    // 在less中所有的数值都可以直接进行运算</span><br><span class="line">    // + - * /</span><br><span class="line">    width: 100px + 100px;</span><br><span class="line">    height: 100px/2;</span><br><span class="line">    background-color: #bfa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Doctype-作用？标准模式与兼容模式各有什么区别"><a href="#Doctype-作用？标准模式与兼容模式各有什么区别" class="headerlink" title="Doctype 作用？标准模式与兼容模式各有什么区别?"></a>Doctype 作用？标准模式与兼容模式各有什么区别?</h1><p>（1）&lt;!DOCTYPE&gt;声明位于位于 HTML 文档中的第一行，处于   标签之前。告知浏览器的解析器用什么文档标准解析这个文档。</p>
<p>DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。</p>
<p>（2）标准模式的排版 和 JS 运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</p>
<h1 id="HTML5-为什么只需要写"><a href="#HTML5-为什么只需要写" class="headerlink" title="HTML5 为什么只需要写"></a>HTML5 为什么只需要写</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br></pre></td></tr></table></figure>

<p>HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；</p>
<p>而 HTML4.01 基于 SGML,所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。</p>
<p>SGML：标准通用标记语言</p>
<p>文档类型定义（DTD，Document Type Definition）是一种特殊文档，它规定、约束符合标准通用标示语言（SGML）或 SGML 子集可扩展标示语言（XML）规则的定义和陈述。</p>
<h1 id="页面导入样式时，使用-link-和-import-有什么区别？"><a href="#页面导入样式时，使用-link-和-import-有什么区别？" class="headerlink" title="页面导入样式时，使用 link 和@import 有什么区别？"></a>页面导入样式时，使用 link 和@import 有什么区别？</h1><p>（1）link 除了加载 CSS 外，还能用于定义 RSS, 定义 rel 连接属性等作用；</p>
<p>而@import 是 CSS 提供的，只能用于加载 CSS;</p>
<p>（2）页面被加载的时，link 会同时被加载，而@import 引用的 CSS 会等到页面被加载完再加载;</p>
<p>（3）import 是 CSS2.1 提出的，只在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题;</p>
<h1 id="xhtml"><a href="#xhtml" class="headerlink" title="xhtml"></a>xhtml</h1><p>XHTML 指可扩展超文本标签语言（EXtensible HyperText Markup Language）。</p>
<p>XHTML 元素必须被正确地嵌套。</p>
<p>XHTML 元素必须被关闭。</p>
<p>标签名必须用小写字母。</p>
<h1 id="浏览器的内核分别是什么"><a href="#浏览器的内核分别是什么" class="headerlink" title="浏览器的内核分别是什么?"></a>浏览器的内核分别是什么?</h1><p>IE 浏览器的内核 Trident</p>
<p>Mozilla（火狐）的 Gecko</p>
<p>Chrome 的 Blink（WebKit 的分支）</p>
<h1 id="html5-新特性"><a href="#html5-新特性" class="headerlink" title="html5 新特性"></a>html5 新特性</h1><p>绘画 canvas</p>
<p>用于媒介回放的 video 和 audio 元素</p>
<p>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</p>
<p>sessionStorage 的数据在浏览器关闭后自动删除</p>
<p>语意化更好的内容元素，比如 article、footer、header、nav、section</p>
<p>表单控件：calendar、date、time、email、url、search</p>
<p>新的技术 webworker, websockt, Geolocation</p>
<h1 id="语义化的理解？"><a href="#语义化的理解？" class="headerlink" title="语义化的理解？"></a>语义化的理解？</h1><p>用正确的标签做正确的事情！</p>
<p>html 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；</p>
<p>在没有样式 CCS 情况下也以一种文档格式显示，并且是容易阅读的。</p>
<p>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。</p>
<p>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>
<h1 id="HTML5-的离线储存？"><a href="#HTML5-的离线储存？" class="headerlink" title="HTML5 的离线储存？"></a>HTML5 的离线储存？</h1><p>localStorage     长期存储数据，浏览器关闭后数据不丢失；</p>
<p>sessionStorage   数据在浏览器关闭后自动删除。</p>
<h1 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h1><p>cookie 在浏览器和服务器间来回传递。 sessionStorage 和 localStorage 不会</p>
<p>sessionStorage 和 localStorage 的存储空间更大；</p>
<p>sessionStorage 和 localStorage 有更多丰富易用的接口；</p>
<p>sessionStorage 和 localStorage 各自独立的存储空间；</p>
<h1 id="webSocket-如何兼容低浏览器？"><a href="#webSocket-如何兼容低浏览器？" class="headerlink" title="webSocket 如何兼容低浏览器？"></a>webSocket 如何兼容低浏览器？</h1><p>采用 Adobe Flash Socket</p>
<p>WebSocket 是 HTML5 新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道</p>
<h1 id="POST-和-GET-的区别"><a href="#POST-和-GET-的区别" class="headerlink" title="POST 和 GET 的区别"></a>POST 和 GET 的区别</h1><ul>
<li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求</li>
<li>GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置</li>
<li>GET 请求参数会被完整保留在浏览器的历史记录里，而 POST 中的参数不会被保留</li>
<li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有限制</li>
<li>GET 参数通过 URL 传递，POST 放在 Request body 中</li>
<li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS、GET、HEAD、POST、PUT</span><br></pre></td></tr></table></figure>

<ul>
<li>GET 产生的 URL 地址可以被收藏，而 POST 不可以</li>
<li>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制</li>
<li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息</li>
</ul>
<h1 id="用户输入-url-到页面呈现的过程"><a href="#用户输入-url-到页面呈现的过程" class="headerlink" title="用户输入 url 到页面呈现的过程"></a>用户输入 url 到页面呈现的过程</h1><ul>
<li>用户输入 url</li>
<li>浏览器查找域名的 IP 地址 域名解析(DNS 解析)</li>
<li>找到 IP 地址后，建立 TCP 三次握手 ,与目标服务器建立连接</li>
<li>握手成功后，通过规定的协议（http），浏览器向目标主机发送 http 请求，请求数据包</li>
<li>服务器处理收到的请求，将数据返回至浏览器</li>
<li>浏览器收到 HTTP 响应报文</li>
<li>关闭连接 浏览器解析文档</li>
<li>读取页面内容，浏览器渲染，解析 html 源码</li>
<li>生成 Dom 树、解析 css 样式、js 交互</li>
<li>在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了</li>
</ul>
<h2 id="跨域（CORS）"><a href="#跨域（CORS）" class="headerlink" title="跨域（CORS）"></a>跨域（CORS）</h2><p>指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 javascript 施加的安全限制。</p>
<p>CORS，跨域资源共享，需要浏览器和服务器同时支持，基本思想为使用自定义的 HTTP 头部让浏览器和服务器通信</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>浏览器将 CORS 分为两类：</p>
<ul>
<li>简单请求<br>HEAD，GET，POST，<br>HTTP 头部信息不超出几个字段</li>
<li>非简单请求</li>
<li>HEAD 请求<br>只请求页面的首部，可以判断一个资源是否存在</li>
</ul>
<h2 id="3-简单请求"><a href="#3-简单请求" class="headerlink" title="3.简单请求"></a>3.简单请求</h2><p>浏览器直接发出 CORS 请求，在头信息中添加一个 Origin 字段，用来说明请求来自哪个源，服务器根据这个值，决定是否同意这次请求</p>
<ul>
<li>如果服务器不许可，则返回的信息中不会包含 Access-Control-Allow-Origin 字段，这个错误需要 onerror 捕获，返回的状态码可能为 200</li>
<li>如果服务器许可，则服务器返回的响应中会多出 Access-Control-字段</li>
<li>CORS 默认不发送 cookie，需要发送 cookies，则需要服务器指定 Access-Control-Allow-Credentials 字段，需要在 ajax 请求中打开 withCredentials 属性</li>
</ul>
<h2 id="4-非简单请求"><a href="#4-非简单请求" class="headerlink" title="4.非简单请求"></a>4.非简单请求</h2><p>请求方法是 PUT 或 DELETE，Content-Type 字段类型是 application/json</p>
<p>会在正式通信前，增加一次 OPTIONS 查询请求，<strong>预检请求</strong></p>
<p>询问服务器，网页所在域名是否在服务器的许可名单中，以及可以使用那些 HTTP 动词和头信息字段，只有得到肯定答复，浏览器才会发出正式 XMLHTTPRequest 请求，否则会报错</p>
<p>服务器通过预检请求，以后每次浏览器正常 CORS 请求，都会和简单请求一样，会有一个 Origin 字段，服务器的回应也会有 yieldAccess-Control-Allow-Origin 头信息字段</p>
<h3 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h3><p>方法一：</p>
<p>通过后台的 PHP 进行设置</p>
<p>前台无需任何设置，在后台被请求的 PHP 文件中，写入一条 header。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(&quot;Access-Control-Allow-Origin:*&quot;);</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<p>script 不受跨域限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://127.0.0.1/json.php&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>方法三：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在ajax请求时，设置dataType为&quot;jsonp&quot;；</span><br></pre></td></tr></table></figure>

<p>JSONP</p>
<p><strong>1.JSONP 的由来</strong></p>
<p>根据浏览器同源策略，所谓同源就是协议、主机、端口号都相同时成为同源。a 域的 js 不能直接访问 b 域名的信息，但是 script 标签的 src 属性可以跨域引用文件，jsonp 是请求之后后台包装好一段 json，并且把数据放在一个 callback 函数，返回一个 js 文件，动态引入这个文件，下载完成 js 之后，会去调用这个 callback,通过这样访问数据。</p>
<p><strong>2. JSONP 有什么用</strong></p>
<p>由于同源从略的限制，XMLHttpRequest 只允许请求前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过 script 标签实现跨域请求，然后再服务端输出 JSON 数据并执行回调函数，从而解决跨域数据请求</p>
<p><strong>3. 如何使用 JSONP</strong></p>
<p>HTML 代码</p>
<p><img src="http://t12.baidu.com/it/u=1154946920,956464023&fm=173&app=25&f=JPG?w=600&h=428&s=B29457CAD2AC8F4F54F8B50B0300E0C1#id=siNp8&originHeight=428&originWidth=600&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>PHP 代码</p>
<p><img src="http://t11.baidu.com/it/u=398540911,2791133765&fm=173&app=25&f=JPG?w=600&h=163&s=AA9001CBD1D488735E509C0E030070C1#id=Wb8yR&originHeight=163&originWidth=600&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><strong>4. JSONP 原理</strong></p>
<p>首先在客户端注册一个 callback，然后把 callback 的名字传给服务器。客户端浏览器，解析 script 变迁，并执行返回 javascript 文档，此时数据作为参数，传入了客户端预先定义好的 callback 函数里。简单的说，就是利用 script 标签没有跨域限制的“漏洞”来达到与第三方通讯的目的。</p>
<p><img src="http://t10.baidu.com/it/u=2156837736,2073091767&fm=173&app=25&f=JPG?w=600&h=263&s=80504730139278690654C1DA0000C0B5#id=NZW2q&originHeight=263&originWidth=600&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>总结一下，json 是一种数据格式，jsonp 是一种数据调用的方式，带 callback 的 json 就是 jsonp。</p>
<p>方法四：反向代理</p>
<p>首先我们用 nginx 作为代理服务器和用户交互，这样用户就只需要在 80 端口上进行交互就可以了，这样就避免了跨域问题，因为我们都是在 80 端口上进行交互的</p>
<h1 id="http-状态码有那些？分别代表是什么意思？"><a href="#http-状态码有那些？分别代表是什么意思？" class="headerlink" title="http 状态码有那些？分别代表是什么意思？"></a>http 状态码有那些？分别代表是什么意思？</h1><ul>
<li>100-199 用于指定客户端应相应的某些动作。</li>
<li>200-299 用于表示请求成功。</li>
<li>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。</li>
<li>400-499 用于指出客户端的错误。</li>
<li>400 语义有误，当前请求无法被服务器理解。</li>
<li>401 当前请求需要用户验证</li>
<li>403 服务器已经理解请求，但是拒绝执行它。</li>
<li>500-599 用于支持服务器错误。</li>
<li>503 – 服务不可用</li>
</ul>
<p>开头的状态码</p>
<p>100Continue 继续。客户端应继续其请求</p>
<p><strong>2 开头的状态码</strong></p>
<p>200OK 请求成功。一般用于 GET 与 POST 请求</p>
<p><strong>3 开头的状态码</strong></p>
<p>301Moved Permanently 永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。</p>
<p>302Found 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI</p>
<p>304Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p>
<p>305Use Proxy 使用代理。所请求的资源必须通过代理访问</p>
<p>306Unused 已经被废弃的 HTTP 状态码</p>
<p><strong>4 开头的状态码</strong></p>
<p>400Bad Request 客户端请求的语法错误，服务器无法理解</p>
<p>401Unauthorized 请求要求用户的身份认证</p>
<p>403Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求</p>
<p>404Not Found 服务器无法根据客户端的请求找到资源(网页)。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</p>
<p><strong>5 开头的状态码</strong></p>
<p>500Internal Server Error 服务器内部错误，无法完成请求</p>
<p>501Not Implemented 服务器不支持请求的功能，无法完成请求</p>
<p>505HTTP Version not supported 服务器不支持请求的 HTTP 协议的版本，无法完成处理</p>
<h2 id="http-缓存控制"><a href="#http-缓存控制" class="headerlink" title="http 缓存控制"></a>http 缓存控制</h2><p>http 缓存能够帮助服务器提高并发性能，很多资源不需要重复请求直接从浏览器中拿缓存 http</p>
<p>Cache-control 用于控制 HTTP 缓存<br>Expires 表示存在时间，允许客户端在这个时间之前不去检查（发请求），等同 max-age 的效果。但是如果同时存在，则被 Cache-Control 的 max-age 覆盖。</p>
<p>通过设置 http 头中的 cache-control 和 expires 的属性，可设定浏览器缓存，将静态内容设为永不过期，或者很长时间后才过期。</p>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>浏览器缓存机制有两种，一种为强缓存，一种为协商缓存</p>
<p>对于强缓存，浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，直接使用缓存。<br>对于协商缓存，第一次请求缓存且保存缓存标识与时间，重复请求向服务器发送缓存标识和最后缓存时间，服务端进行校验，如果失效则使用缓存</p>
<p>强缓存通过  expires 和 cache-control 控制</p>
<p>协商缓存   通过  last-Modify   和 E-tag 控制</p>
<p>补充：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 为什么有expires还需要cache-control</span><br><span class="line">   因为expires 有个服务器和浏览器时间不同步的问题</span><br><span class="line">   expires是绝对事件   cache-control是相对时间</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>last-modify 和 Etag<br>last-modify 它是有个精度问题   到秒<br>e-tag 没有精度问题   只要文件改变  e-tag 值就改变</li>
</ol>
<h2 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h2><p>超文本传输协议 HTTP 协议被用于在 Web 浏览器和网站服务器之间传递信息，HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了 Web 浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP 协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p>为了解决 HTTP 协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议 HTTPS，为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<p><strong>一、HTTP 和 HTTPS 的基本概念</strong></p>
<p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p>
<p>HTTPS：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。</p>
<p>HTTPS 协议的主要作用可以分为两种：</p>
<p>一种是建立一个信息安全通道，来保证数据传输的安全；</p>
<p>另一种就是确认网站的真实性。</p>
<p><strong>二、HTTP 与 HTTPS 有什么区别？</strong></p>
<p>HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。</p>
<p>HTTPS 和 HTTP 的区别主要如下：</p>
<p>1、https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。</p>
<p>2、http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</p>
<p>3、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</p>
<p>4、http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</p>
<p><strong>三、HTTPS 的工作原理</strong></p>
<p>我们都知道 HTTPS 能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用 HTTPS 协议。</p>
<p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤</p>
<p>（1）客户使用 https 的 URL 访问 Web 服务器，要求与 Web 服务器建立 SSL 连接。</p>
<p>（2）Web 服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p>
<p>（3）客户端的浏览器与 Web 服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。</p>
<p>（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p>
<p>（5）Web 服务器利用自己的私钥解密出会话密钥。</p>
<p>（6）Web 服务器利用会话密钥加密与客户端之间的通信。</p>
<p><strong>四、HTTPS 的优点</strong></p>
<p>尽管 HTTPS 并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但 HTTPS 仍是现行架构下最安全的解决方案，主要有以下几个好处：</p>
<p>（1）使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
<p>（2）HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p>
<p>（3）HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>
<p><strong>五、HTTPS 的缺点</strong></p>
<p>虽然说 HTTPS 有很大的优势，但其相对来说，还是存在不足之处的：</p>
<p>（1）HTTPS 协议握手阶段比较费时</p>
<p>（2）HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p>
<p>（3）SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p>
<p>（4）SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。</p>
<p>（5）HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。</p>
<h2 id="HTTP-协议-与-TCP-协议-的区别"><a href="#HTTP-协议-与-TCP-协议-的区别" class="headerlink" title="HTTP 协议 与 TCP 协议 的区别"></a>HTTP 协议 与 TCP 协议 的区别</h2><p><strong>TCP 协议是传输层协议，主要解决数据如何在网络中传输，而 HTTP 是应用层协议，主要解决如何包装数据。</strong></p>
<p>Http 协议是建立在 TCP 协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次 Http 请求。Http 会通过 TCP 建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http 会立即将 TCP 连接断开，这个过程是很短的，所以 Http 连接是一种短连接，是一种无状态的连接。</p>
<p>HTTP(超文本传输协议)是利用 TCP 在两台电脑(通常是 Web 服务器和客户端)之间传输信息的协议。客户端使用 Web 浏览器发起 HTTP 请求给 Web 服务器，Web 服务器发送被请求的信息给客户端。</p>
<p>HTTP 连接举例：</p>
<p>我们模拟一下 TCP 短连接的情况，client 向 server 发起连接请求，server 接到请求，然后双方建立连接。client 向 server 发送消息，server 回应 client，然后一次读写就完成了，这时候双方任何一个都可以发起 close 操作，不过一般都是 client 先发起 close 操作。为什么呢，一般的 server 不会回复完 client 后立即关闭连接的，当然不排除有特殊的情况。</p>
<p>短连接一般只会在 client/server 间传递一次读写操作。<br>短连接的操作步骤是：建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接</p>
<p>http 请求由三部分组成，分别是：请求行、消息报头、请求正文</p>
<p>1、请求行以一个方法符号开头，以空格分开，后面跟着请求的 URI 和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF<br>其中 Method 表示请求方法；Request-URI 是一个统一资源标识符；HTTP-Version 表示请求的 HTTP 协议版本；CRLF 表示回车和换行（除了作为结尾的 CRLF 外，不允许出现单独的 CR 或 LF 字符）。</p>
<p>请求方法（所有方法全为大写）有多种，各个方法的解释如下：<br>GET   请求获取 Request-URI 所标识的资源<br>POST   在 Request-URI 所标识的资源后附加新的数据<br>HEAD   请求获取由 Request-URI 所标识的资源的响应消息报头<br>PUT   请求服务器存储一个资源，并用 Request-URI 作为其标识<br>DELETE 请求服务器删除 Request-URI 所标识的资源<br>TRACE   请求服务器回送收到的请求信息，主要用于测试或诊断<br>CONNECT 保留将来使用<br>OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求<br>应用举例：<br>GET 方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用 GET 方法向服务器获取资源，eg:GET /form.html HTTP/1.1 (CRLF)</p>
<p>HEAD 方法与 GET 方法几乎是一样的，对于 HEAD 请求的回应部分来说，它的 HTTP 头部中包含的信息与通过 GET 请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到 Request-URI 所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。</p>
<p><strong>3、HTTP 响应也是由三个部分组成，分别是：状态行、消息报头、响应正文</strong><br>1、状态行格式如下：<br>HTTP-Version Status-Code Reason-Phrase CRLF<br>其中，HTTP-Version 表示服务器 HTTP 协议的版本；Status-Code 表示服务器发回的响应状态代码；Reason-Phrase 表示状态代码的文本描述。</p>
<p>2、响应报头后述</p>
<p>3、响应正文就是服务器返回的资源的内容</p>
<p><strong>4.关闭连接</strong><br>客户和服务器双方都可以通过关闭套接字来结束 TCP/IP 对话</p>
<h2 id="HTTP-中与缓存有关请求头，响应头字段"><a href="#HTTP-中与缓存有关请求头，响应头字段" class="headerlink" title="HTTP 中与缓存有关请求头，响应头字段"></a>HTTP 中与缓存有关请求头，响应头字段</h2><p>请求头：浏览器向服务器发送请求的数据，资源。</p>
<p>响应头：服务器向浏览器响应数据，告诉浏览器具体操作。</p>
<p>常见的请求头：</p>
<p>Accept: text/html,image/*                         浏览器可以接收的类型</p>
<p>Accept-Charset: ISO-8859-1                     浏览器可以接收的编码类型</p>
<p>Accept-Encoding: gzip,compress                 浏览器可以接收压缩编码类型</p>
<p>Accept-Language: en-us,zh-cn                   浏览器可以接收的语言和国家类型</p>
<p>Host: <a target="_blank" rel="noopener" href="http://www.lks.cn/">www.lks.cn:80</a>                           浏览器请求的主机和端口</p>
<p>If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT   某个页面缓存时间</p>
<p>Referer: <a target="_blank" rel="noopener" href="http://www.lks.cn/index.html">http://www.lks.cn/index.html</a>               请求来自于哪个页面</p>
<p>User-Agent: Mozilla/4.0 compatible; MSIE 5.5; Windows NT 5.0   浏览器相关信息</p>
<p>Cookie：                                     浏览器暂存服务器发送的信息</p>
<p>Connection: close1.0/Keep-Alive1.1               HTTP 请求的版本的特点</p>
<p>Date: Tue, 11 Jul 2000 18:23:51GMT               请求网站的时间</p>
<p>Allow:GET                                     请求的方法 GET 常见的还有 POST</p>
<p>Keep-Alive：5                                 连接的时间；5</p>
<p>Connection：keep-alive                         是否是长连接</p>
<p>Cache-Control：max-age=300                   缓存的最长时间 300s</p>
<p>常见的响应头：</p>
<p>Location: <a target="_blank" rel="noopener" href="http://www.lks.cn/index.html">http://www.lks.cn/index.html</a>               控制浏览器显示哪个页面</p>
<p>Server:apache nginx                             服务器的类型</p>
<p>Content-Encoding: gzip                           服务器发送的压缩编码方式</p>
<p>Content-Length: 80                               服务器发送显示的字节码长度</p>
<p>Content-Language: zh-cn                         服务器发送内容的语言和国家名</p>
<p>Content-Type: image/jpeg; charset=UTF-8           服务器发送内容的类型和编码类型</p>
<p>Last-Modified: Tue, 11 Jul 2000 18:23:51GMT       服务器最后一次修改的时间</p>
<p>Refresh: 1;url=<a target="_blank" rel="noopener" href="http://www.lks.cn/">http://www.lks.cn</a>                     控制浏览器 1 秒钟后转发 URL 所指向的页面</p>
<p>Content-Disposition: attachment; filename=lks.jpg     服务器控制浏览器发下载方式打开文件</p>
<p>Transfer-Encoding: chunked                       服务器分块传递数据到客户端</p>
<p>Set-Cookie:SS=Q0=5Lb_nQ; path=/search         服务器发送 Cookie 相关的信息</p>
<p>Expires: -1                                       资源的过期时间，提供给浏览器缓存数据,-1 永远过期</p>
<p>Cache-Control: no-cache                         告诉浏览器，一定要回服务器校验，不管有没有缓存数据。</p>
<p>Pragma: no-cache                               服务器控制浏览器不要缓存网页</p>
<p>Connection: close/Keep-AliveHTTP                 请求的版本的特点</p>
<p>Date: Tue, 11 Jul 2000 18:23:51 GMT             响应网站的时间</p>
<p>ETag：“ihfdgkdgnp98hdfg”                     资源实体的标识(唯一标识，类似 md5 值，文件有修改 md5 就不一样)</p>
<p>关于缓存相关头的解释：</p>
<p>**_<em>Expires</em>、_**</p>
<p>一个 GMT 时间,试图告知浏览器,在此日期内,可以信任并使用对应缓存中的副本,缺点是,一但客户端日期不准确.则可能导致失效.</p>
<p><strong><em><em>Pragma : no-cache</em></em></strong></p>
<p>这个是 http1.0 中的常规头，作用同 http1.1 的 Cache-Control : no-cache</p>
<p><strong><em><em>Last-Modified</em></em></strong></p>
<p>一个 GMT 时间,告知被请求实体的最后修改时间.用于浏览器校验其缓存副本是否仍然可以信任.与其相关的两个条件请求标头：</p>
<p>1） If-Modified-Since</p>
<p>仅在 get 方法中意义，这个也是比较常见的。 如果实体在指定时间后,没有修改则返回一个 304,否则返回一个常规的 Get 请求的响应(比如 200)，静态文件没有修改返回 304 是好的，因为它只是回服务器校验一下是否有修改，而并没有像 200 那样重新请求数据。</p>
<p>2） If-Unmodified-Since:</p>
<p>如果实体没有任何修改,那么就可以直接执行该请求， 而如果有修改,则返回一个 412 Precondition Failed 状态码,并且抛弃该方法对应的行为操作(GET 方法除外).</p>
<p><strong><em><em>Cache-Control</em></em></strong> (http1.1 的常见头)</p>
<p>1） public</p>
<p>仅体现在响应头，通知浏览器可以无条件的缓存该响应。</p>
<p>2） private</p>
<p>仅体现在响应头，通知浏览器只针对单个用户缓存响应. 且可以具体指定某个字段.如 private –“username”</p>
<p>3） no-cache</p>
<p>a) 请求头中：告诉浏览器回去服务器取数据，并验证你的缓存(如果有的话)。</p>
<p>b) 响应头中：告诉浏览器，一定要回服务器校验，不管有没有缓存数据。 如果确定没有被改，可以使用缓存中的数据</p>
<p>4） no-store</p>
<p>告诉浏览器任何情况下都不要被缓存。</p>
<p>5） max-age</p>
<p>a) 请求头中：强制响应浏览器，根据该值,校验缓存.即与自身的 Age 值,与请求时间做比较.如果超出 max- age 值,则强制去服务器端验证.以确保返回一个新鲜的响应.其功能本质上与传统的 Expires 类似,但区别在于 Expires 是根据某个特定日期值做比较.一但缓存者自身的时间不准确.则结果可能就是错误的.而 max-age,显然无此问题. Max-age 的优先级也是高于 Expires 的.</p>
<p>b) 响应头中：同上</p>
<h2 id="HTTP-2-0-相比-1-0-有哪些重大改进？"><a href="#HTTP-2-0-相比-1-0-有哪些重大改进？" class="headerlink" title="HTTP/2.0 相比 1.0 有哪些重大改进？"></a>HTTP/2.0 相比 1.0 有哪些重大改进？</h2><p>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。</p>
<p>速度更快</p>
<p>首部压缩</p>
<h1 id="优化渲染过程"><a href="#优化渲染过程" class="headerlink" title="优化渲染过程"></a>优化渲染过程</h1><p>代码层面的优化</p>
<p>减少重绘和回流</p>
<p>懒执行 —— 将某些逻辑放到使用时再进行，可以通过定时器或事件进行唤醒</p>
<p>懒加载 —— 将不关键的资源延后加载，如图片、视频资源等。</p>
<p>图片优化：</p>
<p>可以用 css 模拟代替的尽量不要用图片</p>
<p>小图片用 base64 格式</p>
<p>雪碧图</p>
<p>选择正确的图片格式</p>
<p>选择使用 WebP 格式，体积较小，缺点是兼容性不好</p>
<p>小图使用 PNG ，图标类可以使用 SVG 代替</p>
<p>照片使用 JPEG</p>
<h2 id="typeof-方法"><a href="#typeof-方法" class="headerlink" title="typeof 方法"></a>typeof 方法</h2><p>检查字符串时，会返回 string</p>
<p>检查数值时，会返回 number</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof b);</span><br></pre></td></tr></table></figure>

<h2 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h2><p>Null（空值）类型的值只有一个，就是 null null 这个值专门用来表示一个为空的对象</p>
<p>使用 typeof 检查一个 null 值时，会返回 object</p>
<h2 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h2><p>Undefined（未定义）类型的值只有一个，就 undefind</p>
<p>当声明一个变量，但是并不给变量赋值时，它的值就是 undefined</p>
<p>使用 typeof 检查一个 undefined 时也会返回 undefined</p>
<h4 id="字符串-–-gt-数字"><a href="#字符串-–-gt-数字" class="headerlink" title="字符串 –&gt; 数字"></a>字符串 –&gt; 数字</h4><p>1.如果是纯数字的字符串，则直接将其转换为数字</p>
<p>2.如果字符串中有非数字的内容，则转换为 NaN</p>
<p>3.如果字符串是一个空串或者是一个全是空格的字符串，则转换为 0</p>
<h4 id="布尔-–-gt-数字"><a href="#布尔-–-gt-数字" class="headerlink" title="布尔 –&gt; 数字"></a>布尔 –&gt; 数字</h4><p>true 转成 1</p>
<p>false 转成 0</p>
<h4 id="null-–-gt-数字-0"><a href="#null-–-gt-数字-0" class="headerlink" title="null –&gt; 数字     0"></a>null –&gt; 数字     0</h4><h4 id="undefined-–-gt-数字-NaN"><a href="#undefined-–-gt-数字-NaN" class="headerlink" title="undefined –&gt; 数字 NaN"></a>undefined –&gt; 数字 NaN</h4><h3 id="使用-Boolean-函数"><a href="#使用-Boolean-函数" class="headerlink" title="使用 Boolean()函数"></a>使用 Boolean()函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = Boolean(a);</span><br></pre></td></tr></table></figure>

<h3 id="数字-—-gt-布尔"><a href="#数字-—-gt-布尔" class="headerlink" title="数字 —&gt; 布尔"></a>数字 —&gt; 布尔</h3><p>除了 0 和 NaN，其余的都是 true</p>
<h3 id="字符串-—-gt-布尔"><a href="#字符串-—-gt-布尔" class="headerlink" title="字符串 —&gt; 布尔"></a>字符串 —&gt; 布尔</h3><p>除了空串，其余的都是 true</p>
<h3 id="null-和-undefined-都会转换为-false"><a href="#null-和-undefined-都会转换为-false" class="headerlink" title="null 和 undefined 都会转换为 false"></a>null 和 undefined 都会转换为 false</h3><p>对象也会转换为 true</p>
<h1 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h1><p>通过该运算符可以检查一个对象中是否含有指定的属性</p>
<p>如果有则返回 true，没有则返回 false</p>
<p>语法：属性名” in 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;name&quot; in obj);</span><br></pre></td></tr></table></figure>

<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><ul>
<li>在全局作用域中有一个全局对象 window</li>
<li>创建的变量都会作为 window 对象的属性保存</li>
<li>创建的函数都会作为 window 对象的方法保存</li>
<li>在页面的任意的部分都可以访问的到</li>
<li>在全局作用域中无法访问到函数作用域的变量</li>
</ul>
<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><ul>
<li>调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁</li>
<li>每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的</li>
<li>在函数作用域中可以访问到全局作用域的变量</li>
<li>当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用</li>
<li>如果没有则向上一级作用域中寻找，直到找到全局作用域</li>
<li>如果全局作用域中依然没有找到，则会报错 ReferenceError</li>
<li>在函数中要访问全局变量可以使用 window 对象</li>
</ul>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p>根据函数的调用方式的不同，this 会指向不同的对象</p>
<p>1.以函数形式调用时，this 永远都是 window</p>
<p>2.以方法的形式调用时，this 是调用方法的对象</p>
<p>3.以构造函数的形式调用时，this 是新创建的那个对象</p>
<p>4.使用 call 和 apply 调用时，this 是指定的那个对象</p>
<p><strong>谁调用 this 就是指向谁</strong></p>
<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>可以用来从数组提取指定元素</p>
<p><strong>该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回</strong></p>
<p>参数：</p>
<p>1.截取开始的位置的索引,包含开始索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result = arr.slice(1,4);</span><br></pre></td></tr></table></figure>

<p>2.截取结束的位置的索引,不包含结束索引</p>
<p>第二个参数可以省略不写,此时会截取从开始索引往后的所有元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = arr.slice(3);</span><br></pre></td></tr></table></figure>

<p>索引可以传递一个负值，如果传递一个负值，则从后往前计算</p>
<p>-1 倒数第一个</p>
<p>-2 倒数第二个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = arr.slice(1,-2);</span><br></pre></td></tr></table></figure>

<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>可以用于删除数组中的指定元素</p>
<p><strong>使用 splice()会影响到原数组，会将指定元素从原数组中删除</strong></p>
<p><strong>并将被删除的元素作为返回值返回</strong></p>
<p>参数：</p>
<p>第一个，表示开始位置的索引</p>
<p>第二个，表示删除的数量</p>
<p>第三个，及以后可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result = arr.splice(3,0,&quot;牛魔王&quot;,&quot;铁扇公主&quot;,&quot;红孩儿&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>splice 方法虽然说是删除，但是也可以用来添加可以选择位置，添加一个或者多个</strong></p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>concat()可以连接两个或多个数组，并将新的数组返回</p>
<p>该方法不会对原数组产生影响</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result = arr.concat(arr2, arr3, &quot;牛魔王&quot;, &quot;铁扇公主&quot;);</span><br></pre></td></tr></table></figure>

<p>这样可以连接数组，然后后面还可以字符串，都会拼起来</p>
<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>该方法可以将数组转换为一个<strong>字符串</strong></p>
<p>该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回</p>
<p>在 join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符</p>
<p>如果不指定连接符，则默认使用,作为连接符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = arr.join(&quot;@-@&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>该方法用来反转数组（前边的去后边，后边的去前边）</p>
<p>该方法会直接修改原数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.reverse();</span><br></pre></td></tr></table></figure>

<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>可以用来对数组中的元素进行排序</p>
<p>也会影响原数组，默认会按照 Unicode 编码进行排序</p>
<p><strong>sort()可以添加一个回调函数</strong></p>
<p>里面放两个形参</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = [5, 4, 2, 1, 3, 6, 8, 7];</span><br><span class="line">arr.sort(function(a, b) &#123;</span><br><span class="line">    //降序排列</span><br><span class="line">    return b - a;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><p>第一个参数，就是当前正在遍历的元素</p>
<p>第二个参数，就是当前正在遍历的元素的索引</p>
<p>第三个参数，就是正在遍历的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(function(value , index , obj)&#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h1 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h1><p>在调用函数时，浏览器每次都会传递进两个隐含的参数</p>
<p>this 和 arguments</p>
<p>在调用函数时，我们所传递的实参都会在 arguments 中保存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arguments.length可以用来获取实参的长度</span><br><span class="line">arguments[0] 表示第一个实参</span><br><span class="line">      function fun(a,b)&#123;</span><br><span class="line">        console.log(arguments.callee == fun);</span><br><span class="line">	这个属性对应一个函数对象，就是当前正在指向的函数的对象</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h1><h2 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h2><p>可以用来获取字符串的长度</p>
<h2 id="indexof"><a href="#indexof" class="headerlink" title="indexof()"></a>indexof()</h2><p>该方法可以检索一个字符串中是否含有指定内容</p>
<h2 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h2><p>result = str.substring(0,1); 可以用来截取一个字符串，可以 slice()类似</p>
<h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><p>result = str.split(“d”);拆分</p>
<h2 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase"></a>toUpperCase</h2><h2 id="toLowerCase-大小写"><a href="#toLowerCase-大小写" class="headerlink" title="toLowerCase 大小写"></a>toLowerCase 大小写</h2><h2 id="typeof-和-instanceof"><a href="#typeof-和-instanceof" class="headerlink" title="typeof 和 instanceof"></a>typeof 和 instanceof</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>可以区别: 数值, 字符串, 布尔值, undefined, function</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof a === &#x27;number&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>专门用来判断对象数据的类型: Object, Array 与 Function</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(b1 instanceof Object, typeof b1) // true &#x27;object&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h1><p>浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用.</p>
<p>深拷贝拷贝多层, 每一级别的数据都会拷贝</p>
<p>应用场景</p>
<p>从服务器 fetch 到数据之后我将其存放在 store 中，通过 props 传递给界面，然后我需要对这堆数据进行修改，那涉及到的修改就一定有保存和取消，所以我们需要将这堆数据拷贝到其它地方。</p>
<p>当你想使用某个对象的值，在修改时不想修改原对象，那么可以用深拷贝弄一个新的内存对象。像 es6 的新增方法都是深拷贝，所以推荐使用 es6 语法</p>
<h1 id="原生-ajax"><a href="#原生-ajax" class="headerlink" title="原生 ajax"></a>原生 ajax</h1><p>步骤一:创建异步对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ajax = new XMLHttpRequest();</span><br></pre></td></tr></table></figure>

<p>步骤二:设置请求的 url 参数,参数一是请求的类型,</p>
<p>参数二是请求的 url,可以带参数,</p>
<p>动态的传递参数 starName 到服务端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ajax.open(&#x27;get&#x27;,&#x27;getStar.php?starName=&#x27;+name);</span><br></pre></td></tr></table></figure>

<p>//步骤三:发送请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ajax.send();</span><br></pre></td></tr></table></figure>

<p>//步骤四:注册事件 onreadystatechange 状态改变就会调用，如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ajax.onreadystatechange = function () &#123;</span><br><span class="line">if (ajax.readyState==4 &amp;&amp;ajax.status==200) &#123;</span><br><span class="line">　　　　console.log(ajax.responseText);//输入相应的内容</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="前端有哪些页面优化方法"><a href="#前端有哪些页面优化方法" class="headerlink" title="前端有哪些页面优化方法?"></a>前端有哪些页面优化方法?</h1><ul>
<li>减少 HTTP 请求数</li>
<li>简化页面</li>
<li>合理设置 HTTP 缓存</li>
<li>资源合并与压缩</li>
<li>合并 CSS 图片，减少请求数的又一个好办法。</li>
<li>将外部脚本置底（将脚本内容在页面信息内容加载后再加载）</li>
<li>多图片网页使用图片懒加载。</li>
<li>在 js 中尽量减少闭包的使用</li>
<li>尽量合并 css 和 js 文件</li>
<li>尽量使用字体图标或者 SVG 图标，来代替传统的 PNG 等格式的图片</li>
<li>在 JS 中避免“嵌套循环”和 “死循环”</li>
<li>尽可能使用事件委托（事件代理）来处理事件绑定的操作</li>
</ul>
<h1 id="浏览器渲染的主要流程是什么"><a href="#浏览器渲染的主要流程是什么" class="headerlink" title="浏览器渲染的主要流程是什么?"></a>浏览器渲染的主要流程是什么?</h1><ul>
<li>将 html 代码按照深度优先遍历来生成 DOM 树。</li>
<li>css 文件下载完后也会进行渲染，生成相应的 CSSOM。</li>
<li>当所有的 css 文件下载完且所有的 CSSOM 构建结束后，就会和 DOM 一起生成 Render Tree。</li>
<li>接下来，浏览器就会进入 Layout 环节，将所有的节点位置计算出来。</li>
<li>最后，通过 Painting 环节将所有的节点内容呈现到屏幕上。</li>
</ul>
<h1 id="说几条写-JavaScript-的基本规范？"><a href="#说几条写-JavaScript-的基本规范？" class="headerlink" title="说几条写 JavaScript 的基本规范？"></a>说几条写 JavaScript 的基本规范？</h1><p>1.不要在同一行声明多个变量。</p>
<p>2.请使用 ===/!==来比较 true/false 或者数值</p>
<p>3.使用对象字面量替代 new Array 这种形式</p>
<p>4.不要使用全局函数。</p>
<p>5.Switch 语句必须带有 default 分支</p>
<p>6.函数不应该有时候有返回值，有时候没有返回值。</p>
<p>7.For 循环必须使用大括号</p>
<p>8.If 语句必须使用大括号</p>
<p>9.for-in 循环中的变量 应该使用 var 关键字明确限定作用域，从而避免作用域污染。</p>
<h1 id="undefined-和-null-区别"><a href="#undefined-和-null-区别" class="headerlink" title="undefined 和 null 区别"></a>undefined 和 null 区别</h1><p>null： Null 类型，代表“空值”，代表一个空对象指针，使用 typeof 运算得到 “object”，所以你可以认为它是一个特殊的对象值。</p>
<p>undefined： Undefined 类型，当一个声明了一个变量未初始化时，得到的就是 undefined。</p>
<p>null 是 javascript 的关键字，可以认为是对象类型，它是一个空对象指针，和其它语言一样都是代表“空值”</p>
<p>undefined 是 javascript 才有的。</p>
<p>undefined 是为了区分空指针对象和未初始化的变量，它是一个预定义的全局变量。没有返回值的函数返回为 undefined，没有实参的形参也是 undefined。</p>
<h1 id="IE-与火狐的事件机制有什么区别？"><a href="#IE-与火狐的事件机制有什么区别？" class="headerlink" title="IE 与火狐的事件机制有什么区别？"></a>IE 与火狐的事件机制有什么区别？</h1><p>事件处理机制：IE 是事件冒泡、火狐是事件捕获</p>
<h1 id="如何编写高性能的-JavaScript？"><a href="#如何编写高性能的-JavaScript？" class="headerlink" title="如何编写高性能的 JavaScript？"></a>如何编写高性能的 JavaScript？</h1><ul>
<li>遵循严格模式：”use strict”;</li>
<li>将 js 脚本放在页面底部，加快渲染页面;</li>
<li>将 js 脚本成组打包，减少请求;</li>
<li>尽量使用局部变量来保存全局变量;</li>
<li>尽量减少使用闭包;</li>
<li>尽量减少对象成员嵌套;</li>
<li>缓存 DOM 节点的访问;</li>
<li>尽量使用直接量创建对象和数组;</li>
</ul>
<h1 id="防抖和节流的实现"><a href="#防抖和节流的实现" class="headerlink" title="防抖和节流的实现"></a>防抖和节流的实现</h1><p>函数节流是指一定时间内 js 方法只跑一次。</p>
<p>节流：高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//节流throttle代码：</span><br><span class="line">function throttle(fn,delay) &#123;</span><br><span class="line">    let canRun = true; // 通过闭包保存一个标记</span><br><span class="line">    return function () &#123;</span><br><span class="line">         // 在函数开头判断标记是否为true，不为true则return</span><br><span class="line">        if (!canRun) !canRun===(canrRun!=true)</span><br><span class="line">            return;</span><br><span class="line">         // 立即设置为false</span><br><span class="line">        canRun = false;</span><br><span class="line">        // 将外部传入的函数的执行放在setTimeout中</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">        // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。</span><br><span class="line">        // 当定时器没有执行的时候标记永远是false，在开头被return掉</span><br><span class="line">            fn.apply(this, arguments);</span><br><span class="line">            canRun = true;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>防抖</p>
<p>函数防抖是指频繁触发的情况下，只有足够的间隔时间，才执行代码一次。</p>
<p><strong>在第一次触发事件时，不立即执行函数，而是给出一个期限值比如 200ms</strong>，然后：</p>
<ul>
<li>如果在 200ms 内没有再次触发滚动事件，那么就执行函数</li>
<li>如果在 200ms 内再次触发滚动事件，那么当前的计时取消，重新开始计时</li>
</ul>
<p><strong>效果</strong>：如果短时间内大量触发同一事件，只会执行一次函数。</p>
<p>防抖：触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//防抖debounce代码：</span><br><span class="line">function debounce(fn,delay) &#123;</span><br><span class="line">    var timeout = null; // 创建一个标记用来存放定时器的返回值</span><br><span class="line">    return function (e) &#123;</span><br><span class="line">        // 每当用户输入的时候把前一个 setTimeout clear 掉</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        // 然后又创建一个新的 setTimeout, 这样就能保证interval 间隔内如果时间持续触发，就不会执行 fn 函数</span><br><span class="line">        timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">            fn.apply(this, arguments);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 处理函数</span><br><span class="line">function handle() &#123;</span><br><span class="line">    console.log(&#x27;防抖：&#x27;, Math.random());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//滚动事件</span><br><span class="line">window.addEventListener(&#x27;scroll&#x27;, debounce(handle,500));</span><br></pre></td></tr></table></figure>

<p>区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>防抖(debounce)</p>
<p>search 搜索联想，用户在不断输入值时，用防抖来节约请求资源。</p>
<p>window 触发 resize 的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</p>
<p>节流(throttle)</p>
<p>鼠标不断点击触发，mousedown(单位时间内只触发一次)</p>
<p>监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 来判断</p>
<h1 id="MVC-架构模式"><a href="#MVC-架构模式" class="headerlink" title="MVC 架构模式"></a>MVC 架构模式</h1><p>架构模式是一个通用的、可重用的解决方案。</p>
<p>模型-视图-控制器模式，也称为 MVC 模式（Model View Controller）。用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC 被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。它把软件系统分为三个基本部分：</p>
<p>模型（Model）：负责存储系统的中心数据。</p>
<p>视图（View）：将信息显示给用户（可以定义多个视图）。</p>
<p>控制器（Controller）：处理用户输入的信息。负责从视图读取数据，控制用户输入，并向模型发送数据，是应用程序中处理用户交互的部分。负责管理与用户交互交互控制。</p>
<p>这种方式使得程序的修改和扩展简化，并且使程序某一部分的重复利用称为可能。</p>
<p>通过对复杂度的简化，使程序结构更加直观。</p>
<p>将信息的内部表示与信息的呈现方式分离开来，并接受用户的请求。它分离了组件，并允许有效的代码重用。</p>
<p><strong>四、特点</strong></p>
<p>MVC 重要特点就是两种分离：</p>
<p>视图和数据模型的分离：使用不同的视图对相同的数据进行展示；分离可视和不可视的组件，能够对模型进行独立测试。因为分离了可视组件减少了外部依赖利于测试。</p>
<p>视图和表现逻辑(Controller)的分离：Controller 是一个表现逻辑的组件，并非一个业务逻辑组件。MVC 可以作为表现模式也可以作为建构模式，意味这 Controller 也可以是业务逻辑。分离逻辑和具体展示，能够对逻辑进行独立测试。</p>
<p>优点：耦合性低；重用性高；生命周期成本低；部署块；可维护性高；有利软件工程化管理。</p>
<p>缺点：没有明确的定义；不适合小型，中等规模的应用程序；增加系统结构和实现的复用性；视图与控制器间的过于紧密的连接；视图对模型数据的低效率访问；一般高级的界面工具或构造器不支持模式。</p>
<p><strong>六、解决的问题</strong></p>
<p>维护容易，开发速度快，二次开发难度低，工作量小，代码复用，耦合度低</p>
<h1 id="为什么-css-放在顶部而-js-写在后面"><a href="#为什么-css-放在顶部而-js-写在后面" class="headerlink" title="为什么 css 放在顶部而 js 写在后面"></a>为什么 css 放在顶部而 js 写在后面</h1><p>1.浏览器预先加载 css 后，可以不必等待 HTML 加载完毕就可以渲染页面了</p>
<p>2.其实 HTML 渲染并不会等到完全加载完在渲染页面，而是一边解析 DOM 一边渲染。</p>
<p>3.js 写在尾部，主要是因为 js 主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验</p>
<p>但是随着 JS 技术的发展，JS 也开始承担页面渲染的工作。比如我们的 UI 其实可以分被对待，把渲染页面的 js 放在前面，时间处理的 js 放在后面</p>
<h1 id="为什么虚拟-DOM-会提高性能"><a href="#为什么虚拟-DOM-会提高性能" class="headerlink" title="为什么虚拟 DOM 会提高性能"></a>为什么虚拟 DOM 会提高性能</h1><p>虚拟 DOM 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 doom 操作，从而提高性能</p>
<p>具体实现步骤：</p>
<p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档中</p>
<p>当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异</p>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><h3 id="vuex-是-vue-框架中状态管理。"><a href="#vuex-是-vue-框架中状态管理。" class="headerlink" title="vuex 是 vue 框架中状态管理。"></a>vuex 是 vue 框架中状态管理。</h3><p>场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p>
<h3 id="vuex-有哪几种属性"><a href="#vuex-有哪几种属性" class="headerlink" title="vuex 有哪几种属性"></a>vuex 有哪几种属性</h3><p>State、 Getter、Mutation 、Action、 Module<br>state =&gt; 基本数据(数据源存放地)<br>getters =&gt; 从基本数据派生出来的数据<br>mutations =&gt; 提交更改数据的方法，同步！<br>actions =&gt; 像一个装饰器，包裹 mutations，使之可以异步。<br>modules =&gt; 模块化 Vuex</p>
<h3 id="Vue-js-中-ajax-请求代码应该写在组件的-methods-中还是-vuex-的-actions-中？"><a href="#Vue-js-中-ajax-请求代码应该写在组件的-methods-中还是-vuex-的-actions-中？" class="headerlink" title="Vue.js 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 actions 中？"></a>Vue.js 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 actions 中？</h3><p>如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入 vuex 的 state 里。</p>
<h2 id="vuex-中-action-和-mutation-有何区别？"><a href="#vuex-中-action-和-mutation-有何区别？" class="headerlink" title="vuex 中 action 和 mutation 有何区别？"></a>vuex 中 action 和 mutation 有何区别？</h2><ul>
<li>action 中处理异步，mutation 不可以</li>
<li>mutation 做原子操作<br>所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何上下文切换</li>
<li>action 可以整合多个 mutation<br>视图触发 Action，Action 再触发 Mutation<br>Mutation：专注于修改 State，理论上是修改 State 的唯一途径。<br>Action：业务代码、异步请求。<br>Mutation：必须同步执行。<br>Action：可以异步，但不能直接操作 State。<br>Action 提交的是 mutation，而不是直接变更状态。</li>
</ul>
<p>javascript 异步表示 async，指：代码执行不按顺序，‘跳过’执行，待其他某些代码执行完后，再来执行，称为“异步”。</p>
<p>javascript 同步表示 sync，指：代码依次执行。</p>
<h2 id="什么是前端路由？"><a href="#什么是前端路由？" class="headerlink" title="什么是前端路由？"></a>什么是前端路由？</h2><p>前端路由是直接找到与地址匹配的一个组件或对象并将其渲染出来。也就是说，通过改变浏览器地址 URL，在不重新请求页面的情况下，更新页面视图</p>
<h1 id="router-的区别"><a href="#router-的区别" class="headerlink" title="router 的区别"></a><img src="https://g.yuque.com/gr/latex?route%E5%92%8C#card=math&code=route%E5%92%8C&id=lPUzN">router 的区别</h1><p>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$route获取的是当前url地址的信息，通过$route可以拿到的数据包括</span><br><span class="line">fullPath: &quot;/Namevue/test&quot;   </span><br><span class="line">router: &quot;&quot;     //路由规则所属的路由器</span><br><span class="line">name: &quot;Namevue&quot;    //当前路径的名字，如果没有使用具名路径，则名字为空</span><br><span class="line">params: &#123;id: &quot;test&quot;&#125;    //路由中的定义的动态片段和全匹配片段的键值对</span><br><span class="line">path: &quot;/Namevue/test&quot;    //当前路由对象的路径，会被解析为绝对路径，如 &quot;/home/news&quot;</span><br><span class="line">query: &#123;&#125;   //路由中查询参数的键值对。例如，对于 /home/01?favorite=yes ，会得到$route.query.favorite == ‘yes‘ 。</span><br></pre></td></tr></table></figure>

<p>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p>
<p>this.$router.push()</p>
<p>描述：跳转到不同的 url，但这个方法会向 history 栈添加一个记录，点击后退会返回到上一个页面。</p>
<p>this.$router.replace()</p>
<p>描述：同样是跳转到指定的 url，但是这个方法不会向 history 里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。</p>
<p>this.$router.go(n)</p>
<p>相对于当前页面向前或向后跳转多少个页面,类似 <code>window.history.go(n)</code>。n 可为正数可为负数。正数返回上一个页面</p>
<h2 id="vue-router-常用的路由模式"><a href="#vue-router-常用的路由模式" class="headerlink" title="vue-router 常用的路由模式"></a>vue-router 常用的路由模式</h2><p>hash 默认：有 #，也就是路由的 hash，后面是路由</p>
<p>H5 history(需要服务端支持)：没有 #，需要服务端再次，无特殊需求可选择 hash 模式</p>
<h2 id="前端路由原理"><a href="#前端路由原理" class="headerlink" title="前端路由原理"></a>前端路由原理</h2><p>本质：监听 URL 的变化，然后匹配路由规则，并且无需刷新页面。</p>
<p>基于 Hash —— 兼容性更好，但存在 ‘#’ 不够美观</p>
<p>点击跳转或浏览器历史跳转：触发 hashchange 事件 -&gt; 解析 url -&gt;   匹配到对应的路由规则</p>
<p>手动刷新： 触发 load 事件 -&gt; …</p>
<p>基于 History API —— HTML5 新路由方案，更加方便可读，兼容性较差</p>
<p>浏览器动作，如前进后退：触发 popstate 事件 -&gt; 解析 url -&gt;   匹配到对应的路由规则</p>
<p>点击跳转：调用 pushState 函数向浏览器历史添加一个状态 -&gt; …</p>
<p>刷新页面或输入 URL：会向服务器请求，所以使用 history 需要后端配合重定向</p>
<h3 id="hash-模式：监听浏览器地址-hash-值变化，执行相应的-js-改变网页内容"><a href="#hash-模式：监听浏览器地址-hash-值变化，执行相应的-js-改变网页内容" class="headerlink" title="hash 模式：监听浏览器地址 hash 值变化，执行相应的 js 改变网页内容"></a>hash 模式：监听浏览器地址 hash 值变化，执行相应的 js 改变网页内容</h3><ul>
<li>本身以及它后面的字符称作 hash，可通过 window.location.hash 属性读取</li>
<li>url 中可以带有一个 hash，比如 <a target="_blank" rel="noopener" href="http://localhost:9000//#/song.html">http://localhost:9000/#/song</a> 中的 hash 值就是 <a target="_blank" rel="noopener" href="http://localhost:9000//#/song.html">#/song</a></li>
<li>hashchange 事件触发：</li>
<li><ul>
<li>直接更改浏览器地址，在最后面增加或者改变#hash</li>
<li>通过改变 location.href 或者 location.hash 的值（window.location.href：表示重定向，后面跟着的是完整的 url 地址。window.location.hash：得到的是锚链接）</li>
<li>通过触发点击带锚点的链接</li>
<li>浏览器前进后退可能导致 hash 的变化，前提是两个网页地址中的 hash 值不同</li>
</ul>
</li>
</ul>
<h3 id="history-模式：利用-history-API-实现-url-地址改变，网页内容改变"><a href="#history-模式：利用-history-API-实现-url-地址改变，网页内容改变" class="headerlink" title="history 模式：利用 history API 实现 url 地址改变，网页内容改变"></a>history 模式：利用 history API 实现 url 地址改变，网页内容改变</h3><ul>
<li>History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。HTML5 History API 提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的 URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</li>
<li>History 对象方法：<ul>
<li>history.back()加载 history 列表中的前一个 URL</li>
<li>history.forward()加载 history 列表中的下一个 URL</li>
<li>history.go(n)加载 history 列表中的某个具体页面</li>
</ul>
</li>
<li>HTML5 新接口：history.pushState(stateObj,title,url)</li>
<li><ul>
<li>@状态对象：传给目标路由的信息,可为空<br>@页面标题：目前所有浏览器都不支持,填空字符串即可<br>@可选 url：目标 url，不会检查 url 是否存在，且不能跨域。如不传该项,即给当前 url 添加 sateObj</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.pushState(stateObj, title, targetURL);</span><br></pre></td></tr></table></figure>

<ul>
<li>pushState 方法不会触发页面刷新，只是导致 history 对象发生变化，改变网址，网页不会真的跳转，本质上网页还停留在原页面</li>
<li>这里的 url 受到同源策略的限制</li>
<li>popstate 事件触发：每当同一个文档的浏览历史（即 history 对象）出现变化时，就会触发 popstate 事件<ul>
<li><code>popstate</code>事件会在点击后退、前进按钮(或调用<code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>方法)时触发。</li>
<li><strong>由</strong><code>**history.pushState()**</code><strong>或者</strong><code>**history.replaceState()**</code><strong>形成的历史节点中前进后退会形成页面切换。</strong></li>
<li>注意：仅仅调用 pushState 方法或 replaceState 方法，并不会触发该事件，只有用户点击浏览器倒退按钮 和前进按钮，或者使用 JavaScript 调用 back、forward、go 方法时才会触发。</li>
<li>用法：使用的时候，可以为 popstate 事件指定回调函数。这个回调函数的参数是一个 event 事件对象，它的 state 属性指向 pushState 和 replaceState 方法为当前 URL 所提供的状态对象（即这两个方法的第一个参数）</li>
</ul>
</li>
</ul>
<h3 id="history-和-hash-两种模式比较"><a href="#history-和-hash-两种模式比较" class="headerlink" title="history 和 hash 两种模式比较"></a>history 和 hash 两种模式比较</h3><ul>
<li>pushState 设置的新 URL 可以是与当前同源的任意 URL<br>而 hash 只可修改#后面的部分，故只可设置与当前同文档的 URL</li>
<li>pushState 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中<br>而 hash 设置的新值必须与原来不一样才会触发记录添加到栈中</li>
<li>pushState 通过 stateObject 可以添加任意类型的数据到记录中<br>而 hash 只可添加短字符串</li>
<li>pushState 可额外设置 title 属性供后续使用</li>
</ul>
<h3 id="history-模式的一个问题"><a href="#history-模式的一个问题" class="headerlink" title="history 模式的一个问题"></a>history 模式的一个问题</h3><ul>
<li>对于单页应用来讲，理想的使用场景是仅在进入应用时加载 index.html，后续的网络操作通过 Ajax 完成，不会根据 URL 重新请求页面，但是难免遇到特殊情况，比如用户直接在地址栏输入并回车，浏览器重启重新加载应用等。</li>
<li>例子：<ul>
<li>在 hash 模式下，对于如果重新请求，只会发送 故在 hash 模式下遇到根据 URL 请求页面的情况不会有问题。hash 模式仅改变 hash 部分的内容，而 hash 部分是不会包含在 HTTP 请求中的</li>
<li>在 history 模式下，对于会将该 URL 修改得和正常请求后端的 URL 一样，在此情况下重新向后端发送请求，如后端没有配置对应/user/id 的路由处理，则会返回 404 错误</li>
</ul>
</li>
<li>解决办法：官方推荐的解决办法是在服务器端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回一个 index.html 页面，这个页面就是你 app 依赖的页面。同时这么做以后，服务器就不会再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。</li>
</ul>
<h2 id="二、单页应用与多页应用"><a href="#二、单页应用与多页应用" class="headerlink" title="二、单页应用与多页应用"></a>二、单页应用与多页应用</h2><ul>
<li>单页应用（SPA）<ul>
<li>即 第一次进入页面的时候会请求一个 html 文件，刷新清除一下。切换到其他组件，此时路径也相应变化，但是并没有新的 html 文件请求，页面内容也变化了。</li>
<li>原理：JS 会感知到 url 的变化，通过这一点，可以用 js 动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这个时候的路由不是后端来做了，而是前端来做，判断页面到底是显示哪个组件，清除不需要的，显示需要的组件。</li>
<li>这种过程就是单页应用，每次跳转的时候不需要再请求 html 文件了</li>
</ul>
</li>
<li>多页应用</li>
<li><ul>
<li>每一次页面跳转的时候，后台服务器都会给返回一个新的<code>html</code>文档，这种类型的网站也就是多页网站，也叫做多页应用。</li>
<li>原理：用一些超链接来实现页面切换和跳转的</li>
</ul>
</li>
</ul>
<h1 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h1><p>computed：常用于比较消耗性能的计算场景，具有缓存性，getter 执行后会被缓存，只有它依赖的属性值变化后，下一次获取的 computed 值才会重新计算</p>
<p>watch：常用于某些数据的监听，观察 props、 $emit 或本组件值的变化来执行回调进行后续操作，无缓存性，页面重新渲染时值不变化也会执行。</p>
<h2 id="分别简述-computed-和-watch-的使用场景"><a href="#分别简述-computed-和-watch-的使用场景" class="headerlink" title="分别简述 computed 和 watch 的使用场景"></a>分别简述 computed 和 watch 的使用场景</h2><p>computed:<br>　　当一个属性受多个属性影响的时候就需要用到 computed<br>　　最典型的栗子： 购物车商品结算的时候<br>watch:<br>　　当一条数据影响多条数据的时候就需要用 watch<br>　　栗子：搜索数据</p>
<h1 id="vue-项目性能优化"><a href="#vue-项目性能优化" class="headerlink" title="vue 项目性能优化"></a>vue 项目性能优化</h1><p>合理适用 v-if 和 v-show</p>
<p>区分 computed 和 watch 的使用</p>
<p>v-for 遍历为 item 添加 key</p>
<p>v-for 遍历避免同时使用 v-if</p>
<p>图片懒加载</p>
<p>路由懒加载</p>
<p>第三方插件按需引入</p>
<p>SSR 服务端渲染，首屏加载速度快，SEO 效果好</p>
<h4 id="是服务端渲染"><a href="#是服务端渲染" class="headerlink" title="是服务端渲染"></a>是服务端渲染</h4><p>是将组件或页面通过服务器生成 html 字符串，再发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序</p>
<h2 id="Vue-响应式原理"><a href="#Vue-响应式原理" class="headerlink" title="Vue 响应式原理"></a>Vue 响应式原理</h2><p>Vue 采用数据劫持结合发布—订阅模式的方法，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<h2 id="Vue-的基本原理"><a href="#Vue-的基本原理" class="headerlink" title="Vue 的基本原理"></a>Vue 的基本原理</h2><p><img src="https://segmentfault.com/img/bV9lca?w=1200&h=750#id=QoCKb&originHeight=458&originWidth=732&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>1、通过 document.createDocumentFragment()建立虚拟 DOM Tree，遍历指定根节点内部节点，根据、v-model 等规则进行 compile；<br>2、通过 Object.defineProperty()进行数据变化拦截；<br>3、截取到的数据变化，通过发布者-订阅者模式，触发 Watcher，从而改变虚拟 DOM 中的具体数据；<br>4、通过改变虚拟 DOM 元素值，从而改变最后渲染 dom 树的值，完成双向绑定</p>
<p>完成数据的双向绑定在于 Object.defineProperty()</p>
<h2 id="Vue-双向绑定的实现"><a href="#Vue-双向绑定的实现" class="headerlink" title="Vue 双向绑定的实现"></a>Vue 双向绑定的实现</h2><p>vue 双向数据绑定是通过 数据劫持 结合 发布订阅模式的方式来实现的。</p>
<p>数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；<br>核心：关于 VUE 双向数据绑定，其核心是 Object.defineProperty()方法。</p>
<p><strong>1、简易双绑</strong></p>
<p>首先，我们把注意力集中在这个属性上：Object.defineProperty。</p>
<blockquote>
<p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。<br><strong>语法：</strong>Object.defineProperty(obj, prop, descriptor)</p>
</blockquote>
<p>什么叫做，定义或修改一个对象的新属性，并返回这个对象呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj,&#x27;hello&#x27;,&#123;</span><br><span class="line">  get:function()&#123;</span><br><span class="line">    //我们在这里拦截到了数据</span><br><span class="line">    console.log(&quot;get方法被调用&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  set:function(newValue)&#123;</span><br><span class="line">    //改变数据的值，拦截下来额</span><br><span class="line">    console.log(&quot;set方法被调用&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.hello//输出为“get方法被调用”，输出了值。</span><br><span class="line">obj.hello = &#x27;new Hello&#x27;;//输出为set方法被调用，修改了新值</span><br></pre></td></tr></table></figure>

<p>通过以上方法可以看出，获取对象属性值触发 get、设置对象属性值触发 set，因此我们可以想象到数据模型对象的属性设置和读取可以驱动 view 层的数据变化，view 的数据变化传递给数据模型对象，在 set 里面可以做很多事情。</p>
<h2 id="vue-的两个核心点"><a href="#vue-的两个核心点" class="headerlink" title="vue 的两个核心点"></a>vue 的两个核心点</h2><p>答：数据驱动、组件系统<br>数据驱动：ViewModel，保证数据和视图的一致性。<br>组件系统：应用类 UI 可以看作全部是由组件树构成的。</p>
<p>一、数据驱动，也就是数据的双向绑定</p>
<p>想完成这个过程，我们需要：</p>
<p>数据劫持 / 数据代理<br>依赖收集<br>发布订阅模式<br>也就是说：Vue 响应式核心就是，getter 的时候会收集依赖，setter 的时候会触发依赖更新</p>
<p>vue 将遍历 data 中对象的所有 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。</p>
<p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。</p>
<p>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。</p>
<p>getter 的时候我们会收集依赖，依赖收集就是订阅数据变化 watcher 的收集，依赖收集的目的是当响应式数据发生变化时，能够通知相应的订阅者去处理相关的逻辑。</p>
<p>setter 的时候会触发依赖更新，之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p>
<p>总结：</p>
<p>1）原理：</p>
<p>当创建 Vue 实例时,vue 会遍历 data 选项的属性,利用 Object.defineProperty 为属性添加 getter 和 setter 对数据的读取进行劫持（getter 用来依赖收集,setter 用来派发更新）,并且在内部追踪依赖,在属性被访问和修改时通知变化。</p>
<p>每个组件实例会有相应的 watcher 实例,会在组件渲染的过程中记录依赖的所有数据属性（进行依赖收集,还有 computed watcher,user watcher 实例）,之后依赖项被改动时,setter 方法会通知依赖与此 data 的 watcher 实例重新计算（派发更新）,</p>
<p>从而使它关联的组件重新渲染。</p>
<p>2）实现过程：</p>
<p>我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器 Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者 Watcher 看是否需要更新。<br>因为订阅者是有很多个，所以我们需要有一个消息订阅器 Dep 来专门收集这些订阅者，然后在监听器 Observer 和订阅者 Watcher 之间进行统一管理的。接着，我们还需要有一个指令解析器 Compile，对每个节点元素进行扫描和解析，</p>
<p>将相关指令对应初始化成一个订阅者 Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者 Watcher 接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下 3 个步骤，实现数据的双向绑定：</p>
<p>1.实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</p>
<p>2.实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。</p>
<p>3.实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器</p>
<p>Proxy 的代理是针对整个对象的，而不是对象的某个属性，因此不同 Object.defineProperty 的必须遍历对象每个属性，Proxy 只需要做一层代理就可以监听同级结构下的所有属性变化，当然对于深层结构，递归还是需要进行的。</p>
<p>此外 Proxy 支持代理数组的变化。Proxy 就是 vue3.0 使用的方法</p>
<p>二、组件系统<br>组件的核心选项</p>
<p>1 模板（template）：模板声明了数据和最终展现给用户的 DOM 之间的映射关系。</p>
<p>2 初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状态。</p>
<p>3 接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享。</p>
<p>4 方法（methods）：对数据的改动操作一般都在组件的方法内进行。</p>
<p>5 生命周期钩子函数（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，最新 2.0 版本对于生命周期函数名称改动很大。</p>
<p>6 私有资源（assets）：Vue.js 当中将用户自定义的指令、过滤器、组件等统称为资源。一个组件可以声明自己的私有资源。私有资源只有该组件和它的子组件可以调用。</p>
<h2 id="使用-Proxy（vue3"><a href="#使用-Proxy（vue3" class="headerlink" title="使用 Proxy（vue3)"></a>使用 Proxy（vue3)</h2><p>我们知道在 Vue2 对于监测数组的变化是通过重写了数组的原型来完成的，这么做的原因是:</p>
<ol>
<li>不会对数组每个元素都监听，提升了性能.(<code>arr[index] = newValue</code>是不会触发试图更新的,这点不是因为 defineProperty 的局限性，而是出于性能考量的)</li>
<li>defineProperty 不能检测到数组长度的变化，准确的说是通过改变 length 而增加的长度不能监测到(<code>arr.length = newLength</code>也不会)。</li>
</ol>
<p>同样对于对象，由于 defineProperty 的局限性，Vue2 是不能检测对象属性的添加或删除的。</p>
<p>相对于 defineProperty，Proxy 无疑更加强大，可以代理数组，并且提供了多种属性访问的方法 traps(get,set,has,deleteProperty 等等)。</p>
<p>以上只是 vue 的核心思想，通过对象底层属性的 set 和 get 进行数据拦截，vue 的虚拟 dom 又是怎么实现的，且看以下分解。</p>
<p><strong>2、虚拟 DOM 树</strong></p>
<p>创建虚拟 DOM：<br>var frag = document.createDocumentFragment();<br>view 层的和 v-model 的编译规则如下：<br>html:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &#123;&#123; msg &#125;&#125;&lt;br&gt;</span><br><span class="line">    &lt;input class=&quot;inp-text&quot; type=&quot;text&quot; v-model=&quot;inpText&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;text-box&quot;&gt;</span><br><span class="line">        &lt;p class=&quot;show-text&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>createDocumentFragment()</p>
<p>是用来创建一个虚拟的节点对象，或者说，是用来创建文档碎片节点。它可以包含各种类型的节点，在创建之初是空的。</p>
<p>创建虚拟 DOM 流程：<br>1、通过 virtualDom 创建虚拟节点，将目标盒子内所有子节点添加到其内部，注意这里只是子节点；<br>2、子节点通过 compile 进行编译</p>
<p>a:如果节点为元素，其 nodeType = 1</p>
<p>b:如果节点为文本，其 nodeType = 3<br>3、如果第二步子节点仍有子节点，通过 hasChildNodes()来确认，如果有递归调用 compile 方法。</p>
<p><strong>3、响应式原理</strong><br>核心思想：Object.defineProperty(obj, key, {set, get})</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function defineReact(obj, key, value)&#123;</span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">        set: function(newValue)&#123;</span><br><span class="line">            console.log(`触发setter`);</span><br><span class="line">            value = newValue;</span><br><span class="line">            console.log(value);</span><br><span class="line">        &#125;,</span><br><span class="line">        get: function()&#123;</span><br><span class="line">            console.log(`触发getter`);</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是针对 data 数据的属性的响应式定义，但是如何去实现 vue 实例 vm 绑定 data 每个属性，通过以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function observe(obj, vm)&#123;</span><br><span class="line">    Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class="line">        defineReact(vm, key, obj[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vue 的构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Vue(options)&#123;</span><br><span class="line">    this.data = options.data;</span><br><span class="line">    let id = options.el;</span><br><span class="line">    observe(this.data, this); // 将每个data属相绑定到Vue的实例上this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上我们可以实现 Vue 实例绑定 data 属性。</p>
<p>如何去实现 Vue，通常我们实例化 Vue 是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &#x27;container&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: &#x27;Hello world!&#x27;,</span><br><span class="line">        inpText: &#x27;Input text&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(vm.msg); // Hello world!</span><br><span class="line">console.log(vm.inpText); // Input text</span><br></pre></td></tr></table></figure>

<p>实现以上效果，我们必须在 vue 内部初始化虚拟 Dom</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> function Vue(options)&#123;</span><br><span class="line">    this.data = options.data;</span><br><span class="line">    let id = options.el;</span><br><span class="line"></span><br><span class="line">    observe(this.data, this); // 将每个data属相绑定到Vue的实例上this</span><br><span class="line"></span><br><span class="line">    //------------------------添加以下代码</span><br><span class="line">    let container = document.getElementById(id);</span><br><span class="line">    let fragment = virtualDom(container, this); // 这里通过vm对象初始化</span><br><span class="line">    container.appendChild(fragment);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我们再对 Vue 进行实例化，则可以看到以下页面：</p>
<p><img src="https://segmentfault.com/img/bVbqG3f?w=980&h=346#id=hNjdp&originHeight=258&originWidth=732&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>至此我们实现了 dom 的初始化，下一步我们在 v-model 元素添加监听事件，这样就可以通过 view 层的操作来修改 vm 对应的属性值。在 compile 编译的时候，可以准确的找到 v-model 属相元素，因此我们把监听事件添加到 compile 内部。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function compile(node, data)&#123;</span><br><span class="line">    let reg = /\&#123;\&#123;(.*)\&#125;\&#125;/g;</span><br><span class="line">    if(node.nodeType === 1)&#123; // 标签</span><br><span class="line">        let attr = node.attributes;</span><br><span class="line">        for(let i = 0, len = attr.length; i &lt; len; i++)&#123;</span><br><span class="line">            // console.log(attr[i].nodeName, attr[i].nodeValue);</span><br><span class="line">            if(attr[i].nodeName === &#x27;v-model&#x27;)&#123;</span><br><span class="line">                let name = attr[i].nodeValue;</span><br><span class="line">                node.value = data[name];</span><br><span class="line"></span><br><span class="line">                // ------------------------添加监听事件</span><br><span class="line">                node.addEventListener(&#x27;keyup&#x27;, function(e)&#123;</span><br><span class="line">                    data[name] = e.target.value;</span><br><span class="line">                &#125;, false);</span><br><span class="line">                // -----------------------------------</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.hasChildNodes())&#123;</span><br><span class="line">            node.childNodes.forEach((item) =&gt; &#123;</span><br><span class="line">                compile(item, data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(node.nodeType === 3)&#123; // 文本节点</span><br><span class="line">        if(reg.test(node.nodeValue))&#123;</span><br><span class="line">            let name = RegExp.$1;</span><br><span class="line">            name = name.trim();</span><br><span class="line">            node.nodeValue = data[name];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步我们操作页面输入框，可以看到以下效果，证明监听事件添加有效。<br><img src="https://segmentfault.com/img/bVbqG3t?w=895&h=454#id=mJh6E&originHeight=371&originWidth=732&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>到这里我们已经实现了 MVVM 的，即 Model -&gt; vm -&gt; View || View -&gt; vm -&gt; Model 中间桥梁就是 vm 实例对象。</p>
<h2 id="观察者模式原理"><a href="#观察者模式原理" class="headerlink" title="观察者模式原理"></a>观察者模式原理</h2><p>观察者模式定义了对象间的一种一对多的组合关系，当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。</p>
<p>观察者模式必须包含两个角色：观察者和观察对象，两者之间存在“观察”的逻辑关联，当观察对象状态发生改变时，将通知相应的观察者以更新状态。</p>
<ul>
<li>优点</li>
</ul>
<ol>
<li>观察者与被观察者是抽象耦合的</li>
<li>建立了一套触发机制</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li> 被观察者有很多的观察者时，通知更新这一过程会花费很多的时间</li>
<li> 观察者和被观察者之间存在循环依赖的话，可能导致系统奔溃</li>
</ol>
<p>观察者模式也称为发布者-订阅者模式，这样说应该会更容易理解，更加形象。</p>
<p>场景：商店售卖商品，顾客订阅商品信息，当商品数量出现变化时，通知给每一位订阅该消息的顾客</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 被观察者</span><br><span class="line">class Subject &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.observer = []  // 已订阅的观察者对象</span><br><span class="line">        this.goodsCount = 0  // 商店的商品，此时商品数量都为0</span><br><span class="line">    &#125;</span><br><span class="line">    // 顾客订阅商店的商品事件</span><br><span class="line">    on(observer) &#123;</span><br><span class="line">        this.observer.push(observer)</span><br><span class="line">    &#125;</span><br><span class="line">    // 改变商品的数量</span><br><span class="line">    updateGoodsCount(newCount) &#123;</span><br><span class="line">        this.goodsCount = newCount</span><br><span class="line">        // 派发消息给每一个顾客</span><br><span class="line">        this.emit()</span><br><span class="line">    &#125;</span><br><span class="line">    // 发送消息给一订阅的顾客</span><br><span class="line">    emit() &#123;</span><br><span class="line">        this.observer.forEach(ob =&gt; &#123;</span><br><span class="line">            ob.getMessage(this.goodsCount)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 观察者</span><br><span class="line">class Observer &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    // 接受商店派发的消息</span><br><span class="line">    getMessage(goodsCount) &#123;</span><br><span class="line">        console.log(`亲爱的$&#123;this.name&#125;,现在商品数量为$&#123;goodsCount&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let subject = new Subject(&quot;商店&quot;)</span><br><span class="line">let o1 = new Observer(&quot;顾客1&quot;)</span><br><span class="line">let o2 = new Observer(&quot;顾客2&quot;)</span><br><span class="line">subject.on(o1)</span><br><span class="line">subject.on(o2)</span><br><span class="line"></span><br><span class="line">subject.updateGoodsCount(1)  // 修改商品的数量，订阅者将收到消息</span><br><span class="line">subject.updateGoodsCount(2)  // 修改商品的数量，订阅者将收到消息</span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">亲爱的顾客1,现在商品数量为1</span><br><span class="line">亲爱的顾客2,现在商品数量为1</span><br><span class="line">亲爱的顾客1,现在商品数量为2</span><br><span class="line">亲爱的顾客2,现在商品数量为2</span><br></pre></td></tr></table></figure>

<p>订阅者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var subscribe_1 = &#123;</span><br><span class="line">    update: function()&#123;</span><br><span class="line">        console.log(&#x27;This is subscribe_1&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var subscribe_2 = &#123;</span><br><span class="line">    update: function()&#123;</span><br><span class="line">        console.log(&#x27;This is subscribe_2&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var subscribe_3 = &#123;</span><br><span class="line">    update: function()&#123;</span><br><span class="line">        console.log(&#x27;This is subscribe_3&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>三个订阅者都有 update 方法。</p>
<p>发布者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Publisher()&#123;</span><br><span class="line">this.subs = [subscribe_1, subscribe_2, subscribe_3]; // 添加订阅者</span><br><span class="line">&#125;</span><br><span class="line">Publisher.prototype = &#123;</span><br><span class="line">    constructor: Publisher,</span><br><span class="line">    notify: function()&#123;</span><br><span class="line">        this.subs.forEach(function(sub)&#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>发布者通过 notify 方法对订阅者广播，订阅者通过 update 来接受信息。<br>实例化 publisher：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var publisher = new Publisher();</span><br><span class="line">publisher.notify();</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/bVbqG4M?w=847&h=194#id=r8wNK&originHeight=168&originWidth=732&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>这里我们可以做一个中间件来处理发布者-订阅者模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var publisher = new Publisher();</span><br><span class="line">var middleware = &#123;</span><br><span class="line">    publish: function()&#123;</span><br><span class="line">        publisher.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">middleware.publish();</span><br></pre></td></tr></table></figure>

<p><strong>5、观察者模式嵌入</strong><br>到这一步，我们已经实现了：<br>1、修改 v-model 属性元素 -&gt; 触发修改 vm 的属性值 -&gt; 触发 set<br>2、发布者添加订阅 -&gt; notify 分发订阅 -&gt; 订阅者 update 数据<br>接下来我们要实现：更新视图，同时把订阅——发布者模式嵌入。</p>
<p>发布者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Publisher()&#123;</span><br><span class="line">    this.subs = []; // 订阅者容器</span><br><span class="line">&#125;</span><br><span class="line">Publisher.prototype = &#123;</span><br><span class="line">    constructor: Publisher,</span><br><span class="line">    add: function(sub)&#123;</span><br><span class="line">        this.subs.push(sub); // 添加订阅者</span><br><span class="line">    &#125;,</span><br><span class="line">    notify: function()&#123;</span><br><span class="line">        this.subs.forEach(function(sub)&#123;</span><br><span class="line">            sub.update(); // 发布订阅</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>订阅者：<br>考虑到要把订阅者绑定 data 的每个属性，来观察属性的变化，参数：name 参数可以有 compile 中获取的 name 传参。由于传入的 node 节点类型分为两种，我们可以分为两订阅者来处理，同时也可以对 node 节点类型进行判断，通过 switch 分别处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Subscriber(node, vm, name)&#123;</span><br><span class="line">    this.node = node;</span><br><span class="line">    this.vm = vm;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Subscriber.prototype = &#123;</span><br><span class="line">    constructor: Subscriber,</span><br><span class="line">    update: function()&#123;</span><br><span class="line">        let vm = this.vm;</span><br><span class="line">        let node = this.node;</span><br><span class="line">        let name = this.name;</span><br><span class="line">        switch(this.node.nodeType)&#123;</span><br><span class="line">            case 1:</span><br><span class="line">                node.value = vm[name];</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                node.nodeValue = vm[name];</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们要把订阅者添加到 compile 进行虚拟 dom 的初始化，替换掉原来的赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function compile(node, data)&#123;</span><br><span class="line">    let reg = /\&#123;\&#123;(.*)\&#125;\&#125;/g;</span><br><span class="line">    if(node.nodeType === 1)&#123; // 标签</span><br><span class="line">        let attr = node.attributes;</span><br><span class="line">        for(let i = 0, len = attr.length; i &lt; len; i++)&#123;</span><br><span class="line">            // console.log(attr[i].nodeName, attr[i].nodeValue);</span><br><span class="line">            if(attr[i].nodeName === &#x27;v-model&#x27;)&#123;</span><br><span class="line">                let name = attr[i].nodeValue;</span><br><span class="line">                // --------------------这里被替换掉</span><br><span class="line">                // node.value = data[name];</span><br><span class="line">                new Subscriber(node, data, name);</span><br><span class="line"></span><br><span class="line">                // ------------------------添加监听事件</span><br><span class="line">                node.addEventListener(&#x27;keyup&#x27;, function(e)&#123;</span><br><span class="line">                    data[name] = e.target.value;</span><br><span class="line">                &#125;, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.hasChildNodes())&#123;</span><br><span class="line">            node.childNodes.forEach((item) =&gt; &#123;</span><br><span class="line">                compile(item, data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(node.nodeType === 3)&#123; // 文本节点</span><br><span class="line">        if(reg.test(node.nodeValue))&#123;</span><br><span class="line">            let name = RegExp.$1;</span><br><span class="line">            name = name.trim();</span><br><span class="line">            // ---------------------这里被替换掉</span><br><span class="line">            // node.nodeValue = data[name];</span><br><span class="line">            new Subscriber(node, data, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然是对虚拟 dom 编译初始化，Subscriber 要初始化，即 Subscriber.update,因此要对 Subscriber 作进一步的处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Subscriber(node, vm, name)&#123;</span><br><span class="line">     this.node = node;</span><br><span class="line">     this.vm = vm;</span><br><span class="line">     this.name = name;</span><br><span class="line"></span><br><span class="line">     this.update();</span><br><span class="line"> &#125;</span><br><span class="line"> Subscriber.prototype = &#123;</span><br><span class="line">     constructor: Subscriber,</span><br><span class="line">     update: function()&#123;</span><br><span class="line">         let vm = this.vm;</span><br><span class="line">         let node = this.node;</span><br><span class="line">         let name = this.name;</span><br><span class="line">         switch(this.node.nodeType)&#123;</span><br><span class="line">             case 1:</span><br><span class="line">                 node.value = vm[name];</span><br><span class="line">                 break;</span><br><span class="line">             case 3:</span><br><span class="line">                 node.nodeValue = vm[name];</span><br><span class="line">                 break;</span><br><span class="line">             default:</span><br><span class="line">                 break;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>发布者添加到 defineReact，来观察数据的变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function defineReact(data, key, value)&#123;</span><br><span class="line">    let publisher = new Publisher();</span><br><span class="line">    Object.defineProperty(data, key, &#123;</span><br><span class="line">        set: function(newValue)&#123;</span><br><span class="line">            console.log(`触发setter`);</span><br><span class="line">            value = newValue;</span><br><span class="line">            console.log(value);</span><br><span class="line">            publisher.notify(); // 发布订阅</span><br><span class="line">        &#125;,</span><br><span class="line">        get: function()&#123;</span><br><span class="line">            console.log(`触发getter`);</span><br><span class="line">            if(Publisher.global)&#123; //这里为什么来添加判断条件，主要是让publisher.add只执行一次，初始化虚拟dom编译的时候来执行</span><br><span class="line">                publisher.add(Publisher.global); // 添加订阅者</span><br><span class="line">            &#125;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步将订阅者添加到发布者容器内，对订阅者改造：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function Subscriber(node, vm, name)&#123;</span><br><span class="line">      Publisher.global = this;</span><br><span class="line">      this.node = node;</span><br><span class="line">      this.vm = vm;</span><br><span class="line">      this.name = name;</span><br><span class="line"></span><br><span class="line">      this.update();</span><br><span class="line">      Publisher.global = null;</span><br><span class="line">  &#125;</span><br><span class="line">  Subscriber.prototype = &#123;</span><br><span class="line">      constructor: Subscriber,</span><br><span class="line">      update: function()&#123;</span><br><span class="line">          let vm = this.vm;</span><br><span class="line">          let node = this.node;</span><br><span class="line">          let name = this.name;</span><br><span class="line">          switch(this.node.nodeType)&#123;</span><br><span class="line">              case 1:</span><br><span class="line">                  node.value = vm[name];</span><br><span class="line">                  break;</span><br><span class="line">              case 3:</span><br><span class="line">                  node.nodeValue = vm[name];</span><br><span class="line">                  break;</span><br><span class="line">              default:</span><br><span class="line">                  break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>1.vue 优点？</strong><br>轻量级框架：只关注视图层，是一个构建数据的视图集<br>双向数据绑定：在数据操作方面更为简单；<br>组件化：实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；<br>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；<br>虚拟 DOM：dom 操作是非常耗费性能的， 不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；<br>运行速度更快<br><strong>4.v-show 和 v-if 指令的共同点和不同点？</strong><br>答: 共同点：都能控制元素的显示和隐藏；<br>不同点：实现本质方法不同，v-show 本质就是通过控制 css 中的 display 设置为 none，控制隐藏，只会编译一次；v-if 是动态的向 DOM 树内添加或者删除 DOM 元素，若初始值为 false，就不会编译了。而且 v-if 不停的销毁和创建比较消耗性能。<br>总结：如果要频繁切换某节点，使用 v-show(切换开销比较小，初始开销较大)。如果不需要频繁切换某节点使用 v-if（初始渲染开销较小，切换开销比较大）。<br><strong>5.如何让 CSS 只在当前组件中起作用？</strong><br>答：在组件中的 style 前面加上 scoped<br><strong>6.keep-alive 的作用是什么?</strong><br>答:keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br><strong>7.如何获取 dom?</strong><br>答：ref=”domName” 用法：this.$refs.domName<br><strong>8.说出几种 vue 当中的指令和它的用法？</strong><br>答：v-model 双向数据绑定；<br>v-for 循环；<br>v-if v-show 显示与隐藏；<br>v-on 事件；v-once: 只绑定一次。<br><strong>9. vue-loader 是什么？使用它的用途有哪些？</strong><br>答：vue 文件的一个加载器，将 template/js/style 转换成 js 模块。<br>用途：js 可以写 es6、style 样式可以 scss 或 less、template 可以加 jade 等</p>
<p>简单的说，他就是基于 webpack 的一个的 loader，解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理，核心的作用，就是提取，划重点。<br>至于什么是 webpack 的 loader，其实就是用来打包、转译 js 或者 css 文件，简单的说就是把你写的代码转换成浏览器能识别的，还有一些打包、压缩的功能等。</p>
<p><strong>10.为什么使用 key?</strong><br>答：需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点。<br>作用主要是为了高效的更新虚拟 DOM。<br><strong>11.axios 及安装?</strong><br>答：请求后台资源的模块。npm install axios –save 装好，<br>js 中使用 import 进来，然后.get 或.post。返回在.then 函数中如果成功，失败则是在.catch 函数中。<br><strong>12.v-modal 的使用。</strong><br>答：v-model 用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：<br>v-bind 绑定一个 value 属性；<br>v-on 指令给当前元素绑定 input 事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-bind:value=&quot;inputValue&quot; v-on:input=&quot;inputValue = argument[0]&quot;&gt;&lt;/my-component&gt;</span><br><span class="line"></span><br><span class="line">这个时候，inputValue接受的值就是input事件的回调函数的第一个参数，所以在自定义组件中，要实现数据绑定，还需要$emit去触发input的事件。</span><br><span class="line">this.$emit(&#x27;input&#x27;, value)</span><br></pre></td></tr></table></figure>

<p>使用 父组件 v-model 传值，子组件 props[‘value’]接收，而子组件也可以通过$emit(‘input’,false)，去改变父组件中 v-model 和 子组件中 value 的值 。</p>
<p>代码本质上是&lt;input :value=“test” @input=“test = $event.target.value”&gt;，其中@input 是对输入事件的一个监听:value=”test”是将监听事件中的数据放入到 input。在这边需要强调一点，v-model 不仅可以给 input 赋值还可以获取 input 中的数据，而且数据的获取是实时的，因为语法糖中是用@input 对输入框进行监听的。</p>
<p><strong>13.请说出 vue.cli 项目中 src 目录每个文件夹和文件的用法？</strong><br>答：assets 文件夹是放静态资源；components 是放组件；router 是定义路由相关的配置; app.vue 是一个应用主组件；main.js 是入口文件。</p>
<p><strong>15.v-on 可以监听多个方法吗？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-on=&quot;&#123; input:onInput,focus:onFocus,blur:onBlur, &#125;&quot;&gt;。</span><br></pre></td></tr></table></figure>

<p>**16.<img src="https://g.yuque.com/gr/latex?nextTick%E7%9A%84%E4%BD%BF%E7%94%A8**%0A%E7%AD%94%EF%BC%9A%E5%BD%93%E4%BD%A0%E4%BF%AE%E6%94%B9%E4%BA%86data%E7%9A%84%E5%80%BC%E7%84%B6%E5%90%8E%E9%A9%AC%E4%B8%8A%E8%8E%B7%E5%8F%96%E8%BF%99%E4%B8%AAdom%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC%EF%BC%8C%E6%98%AF%E4%B8%8D%E8%83%BD%E8%8E%B7%E5%8F%96%E5%88%B0%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E5%80%BC%EF%BC%8C%0A%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8#card=math&code=nextTick%E7%9A%84%E4%BD%BF%E7%94%A8%2A%2A%0A%E7%AD%94%EF%BC%9A%E5%BD%93%E4%BD%A0%E4%BF%AE%E6%94%B9%E4%BA%86data%E7%9A%84%E5%80%BC%E7%84%B6%E5%90%8E%E9%A9%AC%E4%B8%8A%E8%8E%B7%E5%8F%96%E8%BF%99%E4%B8%AAdom%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC%EF%BC%8C%E6%98%AF%E4%B8%8D%E8%83%BD%E8%8E%B7%E5%8F%96%E5%88%B0%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E5%80%BC%EF%BC%8C%0A%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8&id=ACApx">nextTick 这个回调，让修改后的 data 值渲染更新到 dom 元素之后在获取，才能成功。</p>
<p>this.$nextTick()将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。</p>
<p>第一个例子</p>
<p>在 created()钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作并无作用，而在 created()里使用 this.$nextTick()可以等待 dom 生成以后再来获取 dom 对象</p>
<p>然后来看第二个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;section&gt;</span><br><span class="line">    &lt;h1 ref=&quot;hello&quot;&gt;&#123;&#123; value &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;el-button type=&quot;danger&quot; @click=&quot;get&quot;&gt;点击&lt;/el-button&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        value: &#x27;Hello World ~&#x27;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        this.value = &#x27;你好啊&#x27;;</span><br><span class="line">        console.log(this.$refs[&#x27;hello&#x27;].innerText);</span><br><span class="line">        this.$nextTick(() =&gt; &#123;</span><br><span class="line">          console.log(this.$refs[&#x27;hello&#x27;].innerText);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>根据上面的例子可以看出，在方法里直接打印的话， 由于 dom 元素还没有更新， 因此打印出来的还是未改变之前的值，而通过 this.$nextTick()获取到的值为 dom 更新之后的值</p>
<p>this.$nextTick()在页面交互，尤其是从后台获取数据后重新生成 dom 对象之后的操作有很大的优势。</p>
<p><strong>17.vue 组件中 data 为什么必须是一个函数？</strong><br>答：因为 JavaScript 的特性所导致，在 component 中，data 必须以函数的形式存在，不可以是对象。<br>　　组建中的 data 写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的 data，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个 data，这样改一个全都改了。<br><strong>18.渐进式框架的理解</strong><br>可以根据不同的需求选择不同的层级；</p>
<p><strong>VUE 不强求你一次性接受并使用它的全部功能特性</strong>。</p>
<p>1.只是使用 VUE 做些<strong>基础操作</strong>，</p>
<p>2.引入 VUE 的 components 组件特性了。</p>
<p>3.逐渐用到前端路由、状态集中管理、并最终实现一个高度工程化的前端项目。<br><strong>21.v-if 和 v-for 的优先级</strong><br>答：当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。所以，不推荐 v-if 和 v-for 同时使用。<br>如果 v-if 和 v-for 一起用的话，vue 中的的会自动提示 v-if 应该放到外层去。<br><strong>22.assets 和 static 的区别</strong><br>答：相同点：assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点<br>不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。</p>
<p>static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。<br>建议：将项目中 template 需要的样式文件 js 文件等都可以放置在 assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如 iconfoont.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，我们不再需要处理，直接上传。<br><strong>23.vue 常用的修饰符</strong><br>.stop：等同于 JavaScript 中的 event.stopPropagation()，防止事件冒泡；<br>.prevent：等同于 JavaScript 中的 event.preventDefault()，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；<br>.capture：与事件冒泡的方向相反，事件捕获由外到内；<br>.self：只会触发自己范围内的事件，不包含子元素；<br>.once：只会触发一次。</p>
<p><strong>25.vue 和 jQuery 的区别</strong><br>答：jQuery 是使用选择器（$）选取 DOM 对象，对其进行赋值、取值、事件绑定等操作，其实和原生的 HTML 的区别只在于可以更方便的选取和操作 DOM 对象，而数据和界面是在一起的。</p>
<p>比如需要获取 label 标签的内容：$(“lable”).val();,它还是依赖 DOM 元素的值。<br>Vue 则是通过 Vue 对象将数据和 View 完全分离开来了。对数据进行操作不再需要引用相应的 DOM 对象，可以说数据和 View 是分离的，他们通过 Vue 对象这个 vm 实现相互的绑定。这就是传说中的 MVVM。<br><strong>26. 引进组件的步骤</strong><br>答: 在 template 中引入组件；<br>在 script 的第一行用 import 引入路径；<br>用 component 中写上组件名称。<br><strong>27.delete 和 Vue.delete 删除数组的区别</strong><br>答：delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。Vue.delete 直接删除了数组 改变了数组的键值。</p>
<p>delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。<br>Vue.delete 直接删除了数组 改变了数组的键值。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="variable language_">this</span>.$delete(b, <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/12665637-4c16334926b37570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/478/format/webp#id=I9r51&originHeight=157&originWidth=478&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12665637-81e13b602907e736.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/655/format/webp#id=WQunO&originHeight=162&originWidth=655&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><strong>28.SPA 首屏加载慢如何解决</strong><br>答：安装动态懒加载所需插件；使用 CDN 资源。</p>
<p>CDN 的全称是 Content Delivery Network，即内容分发网络。</p>
<p>CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
<p><strong>29.Vue-router 跳转和 location.href 有什么区别</strong><br>使用 location.href=’/url’来跳转，简单方便，但是刷新了页面；<br>使用 history.pushState(‘/url’)，无刷新页面，静态跳转；</p>
<p>引进 router，然后使用 router.push(‘/url’)来跳转，使用了 diff 算法，实现了按需加载，减少了 dom 的消耗。<br>其实使用 router 跳转和使用 history.pushState()没什么差别的，因为 vue-router 就是用了 history.pushState()，尤其是在 history 模式下。</p>
<p>总之，pushState 方法不会触发页面刷新，只是导致 history 对象发生变化，地址栏会有反应。</p>
<p><strong>30. vue slot</strong><br>答：简单来说，假如父组件需要在子组件内放一些 DOM，那么这些 DOM 是显示、不显示、在哪个地方显示、如何显示，就是 slot 分发负责的活。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//引用</span><br><span class="line">&lt;Logo&gt;</span><br><span class="line">  &lt;span slot=&quot;name&quot;&gt;商品详情&lt;/span&gt;</span><br><span class="line">&lt;/Logo&gt;</span><br><span class="line"></span><br><span class="line">//插槽组件</span><br><span class="line">    &lt;div class=&quot;headspan&quot;&gt;</span><br><span class="line">      &lt;slot name=&quot;name&quot;&gt;</span><br><span class="line">        &lt;span&gt;用户注册&lt;/span&gt;</span><br><span class="line">      &lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>31.你们 vue 项目是打包了一个 js 文件，一个 css 文件，还是有多个文件？</strong><br>答：根据 vue-cli 脚手架规范，一个 js 文件，一个 CSS 文件。<br><strong>32.Vue 里面 router-link 在电脑上有用，在安卓上没反应怎么解决？</strong><br>答：Vue 路由在 Android 机上有问题，babel 问题，安装 babel polypill 插件解决。<br><strong>33.Vue2 中注册在 router-link 上事件无效解决方法</strong><br>答： 使用@click.native。原因：router-link 会阻止 click 事件，.native 指直接监听一个原生事件。<br><strong>34.RouterLink 在 IE 和 Firefox 中不起作用（路由不跳转）的问题</strong><br>方法一：只用 a 标签，不适用 button 标签</p>
<p>方法二：使用 button 标签和 Router.navigate 方法</p>
<p><strong>vue-router 有哪几种导航钩子?</strong><br>答：三种，<br>第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。<br>第二种：组件内的钩子<br>第三种：单独路由独享组件</p>
<h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>在路由跳转之前 我们主要是利用 vue-router 提供的钩子函数 beforeEach()对路由进行判断。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由守卫</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">matched</span>.<span class="title function_">some</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="property">meta</span>.<span class="property">isLogin</span>)) &#123;</span><br><span class="line">    <span class="comment">//判断是否需要登录</span></span><br><span class="line">    <span class="keyword">if</span> (sessionStorage[<span class="string">&quot;username&quot;</span>]) &#123;</span><br><span class="line">      <span class="title function_">next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(&#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">        <span class="attr">query</span>: &#123;</span><br><span class="line">          <span class="attr">redirect</span>: to.<span class="property">fullPath</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>

<p>to 表示将要跳转到的组件 (目标组件)<br>console.log(from); //(源组件)<br>next();<br>next 是一个函数<br>next() 进入下一个组件的钩子函数<br>next(false)   阻止跳转 中断导航<br>next(“/login”) 进入指定的组件的钩子函数</p>
<h2 id="组件内的导航钩子"><a href="#组件内的导航钩子" class="headerlink" title="组件内的导航钩子"></a>组件内的导航钩子</h2><p>组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。他们是直接在路由组件内部直接进行定义的</p>
<p>我们看一下他的具体用法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> File = &#123;</span><br><span class="line">    template: `&lt;div&gt;This <span class="keyword">is</span> file&lt;/div&gt;`,</span><br><span class="line">    beforeRouteEnter(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">        <span class="comment">// do someting</span></span><br><span class="line">        <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouteUpdate(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">        <span class="comment">// do someting</span></span><br><span class="line">        <span class="comment">// 在当前路由改变，但是依然渲染该组件是调用</span></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouteLeave(to, <span class="keyword">from</span> ,next) &#123;</span><br><span class="line">        <span class="comment">// do someting</span></span><br><span class="line">        <span class="comment">// 导航离开该组件的对应路由时被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意是：</p>
<blockquote>
<p>beforeRouteEnter 不能获取组件实例 this，因为当守卫执行前，组件实例被没有被创建出来，剩下两个钩子则可以正常获取组件实例 this<br>但是并不意味着在 beforeRouteEnter 中无法访问组件实例，我们可以通过给 next 传入一个回调来访问组件实例。在导航被确认是，会执行这个回调，这时就可以访问组件实例了，如：</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span><br><span class="line">    next (<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里通过 vm 来访问组件实例解决了没有 this 的问题</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>，仅仅是 beforRouteEnter 支持给 next 传递回调，其他两个并不支持。因为归根结底，支持回调是为了解决 this 问题，而其他两个钩子的 this 可以正确访问到组件实例，所有没有必要使用回调</p>
</blockquote>
<p><strong>35.axios 的特点有哪些</strong><br>答：从浏览器中创建 XMLHttpRequests；<br>支持 Promise API；<br>拦截请求和响应；<br>转换请求数据和响应数据；<br>取消请求；<br>自动换成 json。<br>axios 中的发送字段的参数是 data 跟 params 两个，两者的区别在于 params 是跟请求地址一起发送的，data 的作为一个请求体进行发送<br>params 一般适用于 get 请求，data 一般适用于 post put 请求。</p>
<p><strong>37.params 和 query 的区别</strong><br>用法：query 要用 path 来引入，params 要用 name 来引入，接收参数都是类似的，分别是 this.<img src="https://g.yuque.com/gr/latex?route.query.name%E5%92%8Cthis.#card=math&code=route.query.name%E5%92%8Cthis.&id=LWl6u">route.params.name。</p>
<p>url 地址显示：query 更加类似于我们 ajax 中 get 传参</p>
<p>param 在浏览器地址栏中显示参数，post 则不显示</p>
<p>query 刷新不会丢失 query 里面的数据<br>params 刷新会丢失 params 里面的数据。</p>
<p>传参可以使用 params 和 query 两种方式。<br>使用 params 传参只能用 name 来引入路由<br>使用 query 传参使用 path 来引入路由。<br>params 是路由的一部分,必须要在路由后面添加参数名。</p>
<p>query 是拼接在 url 后面的参数，没有也没关系。</p>
<p>query 相当于 get 请求，页面跳转的时候，可以在地址栏看到请求参数</p>
<p>而 params 相当于 post 请求，参数不会再地址栏中显示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//操作 路由跳转</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">      name:&#x27;hello&#x27;,</span><br><span class="line">      params:&#123;</span><br><span class="line">          name:&#x27;word&#x27;,</span><br><span class="line">          age:&#x27;11&#x27;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//读取 路由参数接收</span><br><span class="line">this.name = this.$route.params.name;</span><br><span class="line">this.age = this.$route.params.age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//query传参，使用path跳转</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">    path:&#x27;second&#x27;,</span><br><span class="line">    query: &#123;</span><br><span class="line">        queryId:&#x27;20180822&#x27;,</span><br><span class="line">        queryName: &#x27;query&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//query传参接收</span><br><span class="line">this.queryName = this.$route.query.queryName;</span><br><span class="line">this.queryId = this.$route.query.queryId;</span><br></pre></td></tr></table></figure>

<h2 id="vue-router-传参"><a href="#vue-router-传参" class="headerlink" title="vue-router 传参"></a>vue-router 传参</h2><blockquote>
<p>分析:考查 vue-router 的传值方式</p>
<p><code>**解析**</code>  vue-router 传值 可以通过 地址传值</p>
<p>最简单的就是 url 传值, url 传值又两种, params 和 query 参数传值</p>
<p>params 传值 是指的动态路由传值</p>
<p>query 传值,指通过?后面的拼接参数传值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: &#x27;/user/:id&#x27; &#125; // 定义一个路由参数</span><br><span class="line">&lt;router-link to=&quot;/user/123&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">// 传值 /user/123 &#x27;/user/:id&#x27; ---123 就是 id this.$route.params.id // 取值</span><br><span class="line">专门获取 :id 这种参数 params 参数</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: &#x27;/user&#x27; &#125; // 定义一个路由参数</span><br><span class="line">&lt;router-link to=&quot;/user?id=123&amp;name=zs&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">// 传值 this.$route.query.id // 取值 获取 ?后面的参数 query参数 查询字符</span><br><span class="line">this.$route.query.name --- zs</span><br></pre></td></tr></table></figure>

<p><strong>36.请说下封装 vue 组件的过程？</strong></p>
<ol>
<li> 建立组件的模板，先把架子搭起来，写写样式，考虑好组件的基本逻辑。</li>
<li> 准备好组件的数据输入。即分析好逻辑，定好 props 里面的数据、类型。</li>
<li> 准备好组件的数据输出。即根据组件逻辑，做好要暴露出来的方法。</li>
<li> 封装完毕了，直接调用即可</li>
</ol>
<p><strong>38.vue 初始化页面闪动问题</strong><br>答：使用 vue 开发时，在 vue 初始化之前，由于 div 是不归 vue 管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。<br>首先：在 css 里加上[v-cloak] {<br>display: none;<br>}。</p>
<p>这个指令保持在元素上直到关联实例结束编译</p>
<p><strong>39.vue 更新数组时触发视图更新的方法</strong><br>答:push()；pop()；shift()；unshift()；splice()； sort()；reverse()<br><strong>40.vue 常用的 UI 组件库</strong><br>答：Mint UI，element，VUX<br><strong>41.vue 修改打包后静态资源路径的修改</strong><br>答：cli2 版本：将 config/index.js 里的 assetsPublicPath 的值改为 ‘./‘ 。<br>build: {<br>…<br>assetsPublicPath: ‘./‘,<br>…<br>}<br>cli3 版本：在根目录下新建 vue.config.js 文件，然后加上以下内容：（如果已经有此文件就直接修改）<br>module.exports = {<br>publicPath: ‘’, // 相对于 HTML 页面（目录相同） }</p>
<p><strong>1.mvvm 框架是什么？</strong><br>答：vue 是实现了双向数据绑定的 mvvm 框架，当视图改变更新模型层，当模型层改变更新视图层。在 vue 中，使用了双向绑定技术，就是 View 的变化能实时让 Model 发生变化，而 Model 的变化也能实时更新到 View。<br><strong>2.vue-router 是什么?它有哪些组件</strong><br>vue 用来写路由一个插件。router-link、router-view</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;</span><br><span class="line"> this.$router.push(&quot;/admin/index&quot;);</span><br><span class="line">         &lt;div class=&quot;rightContainer&quot;&gt;</span><br><span class="line">            &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">import Person from &#x27;@/views/User/Person.vue&#x27;</span><br><span class="line"> export default &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    component: Home,</span><br><span class="line">    children: [&#123;</span><br><span class="line">        path: &#x27;/&#x27;,</span><br><span class="line">        component: Index</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.active-class 是哪个组件的属性？</strong><br>答：vue-router 模块的 router-link 组件。children 数组来定义子路由</p>
<p>active-class 是<strong>vue-router</strong>模块的<strong>router-link</strong>组件中的属性，用来做选中<strong>样式的切换</strong>；</p>
<p><strong>8.vue-router 实现路由懒加载（ 动态加载路由 ）</strong><br>答:三种方式<br>第一种：vue 异步组件技术 ==== 异步加载，vue-router 配置路由 , 使用 vue 的异步组件技术 , 可以实现按需加载 .但是,这种情况下一个组件生成一个 js 文件。<br>第二种：路由懒加载(使用 import)。<br>第三种：webpack 提供的 require.ensure()，vue-router 配置路由，使用 webpack 的 require.ensure 技术，也可以实现按需加载。这种情况下，多个路由指定相同的 chunkName，会合并打包成一个 js 文件。</p>
<h2 id="vue-传值"><a href="#vue-传值" class="headerlink" title="vue 传值"></a>vue 传值</h2><p>父 -&gt;子 传值   使用 props 接受</p>
<p>子-&gt;父 传值     父亲写事件函数   子 $emit 触发 传值</p>
<p>子组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> props: &#123;</span><br><span class="line">   dialog: Object,</span><br><span class="line">   formData: Object</span><br><span class="line"> &#125;,</span><br><span class="line">this.$emit(&quot;func&quot;, this.msg);</span><br></pre></td></tr></table></figure>

<p>父组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  &lt;PersonDialog :dialog=&quot;dialog&quot; :formData=&quot;formData&quot; @func=&quot;getMsgFormSon&quot; @update=&quot;getPerson&quot;&gt;&lt;/PersonDialog&gt;</span><br><span class="line">     dialog: &#123;</span><br><span class="line">       show: false,</span><br><span class="line">       title: &quot;&quot;,</span><br><span class="line">       option: &quot;&quot;</span><br><span class="line">     &#125;,</span><br><span class="line">getMsgFormSon(data) &#123;</span><br><span class="line">      this.formData.project_src + data;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>

<p>兄弟传值  $bus 中转站</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;view&gt;</span><br><span class="line">        &lt;h1&gt;c2&lt;/h1&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">     mounted () &#123;</span><br><span class="line">    // 注册事件</span><br><span class="line">        this.bus.$on(&#x27;updateData&#x27;, (content)=&gt;&#123;</span><br><span class="line">            console.log(content);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 注册的总线事件要在组件销毁时卸载，否则会多次挂载，造成触发一次但多个响应的情况</span><br><span class="line">    beforeDestroy () &#123;</span><br><span class="line">    this.bus.$off(&#x27;updateData&#x27;, (content)=&gt;&#123;</span><br><span class="line">            console.log(content);</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;view&gt;</span><br><span class="line">        &lt;button @tap=&quot;tapBus&quot;&gt;c1&lt;/button&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods:&#123;</span><br><span class="line">        tapBus()&#123;</span><br><span class="line">      // 触发兄弟组件身上的事件，并传一个object过去</span><br><span class="line">            this.bus.$emit(&#x27;updateData&#x27;, &#123;loading: false&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>4 如果组件之间 关系很远 是很多组件都要用的值  <strong>vuex</strong></p>
<p><strong>vuex</strong>   <strong>就是一个全局状态数据管理</strong></p>
<p>简单来说 他的数据类似全局变量 哪个组件都可以使用</p>
<p><strong>他的使用逻辑是什么？</strong></p>
<p>在 store 里面的   state   写的数据   是全局数据   所有组件都可以使用</p>
<p><strong>使用逻辑</strong></p>
<p><strong>操作全局 vuex 的 state 数据</strong></p>
<p>正常情况   必须  dispatch (action)—&gt;action 去 commit 触发 mutation–》mutation 里面才能修改 state 全局数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$store.dispatch(&quot;increment&quot;);</span><br><span class="line">dispatch去操作action</span><br></pre></td></tr></table></figure>

<p>action—&gt;mutation—&gt;修改 state</p>
<p>其他情况 你也可以跳过 action   去   直接 commit mutation–》修改 state 全局数据</p>
<h2 id="vuex-模块化-module-管理"><a href="#vuex-模块化-module-管理" class="headerlink" title="vuex 模块化 module 管理"></a>vuex 模块化 module 管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">import bus from &#x27;./module/bus&#x27;</span><br><span class="line">import app from &#x27;./module/app&#x27;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        // 这里是根vuex状态</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        // 这里是根vuex状态</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        // 这里是根vuex状态</span><br><span class="line">    &#125;,</span><br><span class="line">    modules: &#123; // 子vuex状态模块注册</span><br><span class="line">        namespaced: true, // 为了解决不同模块命名冲突的问题</span><br><span class="line">        app,</span><br><span class="line">        bus</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">app文件</span><br><span class="line">const state = &#123;</span><br><span class="line">    user: &#123;&#125;, // 需要管理的状态数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mutations = &#123;</span><br><span class="line">    setUser (state, val) &#123;</span><br><span class="line">            state.user = val</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">const getters = &#123;&#125;</span><br><span class="line">const actions = &#123;&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    namespaced: true,</span><br><span class="line">    state,</span><br><span class="line">    mutations,</span><br><span class="line">    getters,</span><br><span class="line">    actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用属性和指令"><a href="#常用属性和指令" class="headerlink" title="常用属性和指令"></a>常用属性和指令</h2><p>常用的组件属性 =&gt; data/ methods/filters/ components/watch/created/mounted/beforeDestroy/computed/props</p>
<p>常用组件指令: v-if/v-on/v-bind/v-model/v-text/v-once</p>
<h2 id="使用-Proxy-代理跨域"><a href="#使用-Proxy-代理跨域" class="headerlink" title="使用 Proxy 代理跨域"></a>使用 Proxy 代理跨域</h2><p>什么是跨域？</p>
<p>域名 协议 ip 地址 端口 任何一个不一样 就跨域</p>
<p>解决跨域？</p>
<p>1 jsonp   —使用 script 的 src 发送   只能 get 请求</p>
<p>2 cors 后台设置允许跨域    <strong>需要后台设置</strong> 允许跨域</p>
<p>所有后台语言 都可以设置</p>
<p>3   服务器代理</p>
<p><strong>重点现在前端 vue 框架是可以自己设置 服务器代理的</strong>  proxy</p>
<p><strong>配置就行</strong></p>
<p><strong>vue 在 vue.config.js   可以配置重写 webpack</strong></p>
<p>以下为 webpack 配置代理的配置</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line">module.exports = <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// 修改的配置</span></span><br><span class="line">  devServer<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      proxy<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          &#x27;/api&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              target<span class="punctuation">:</span> &#x27;http<span class="punctuation">:</span><span class="comment">//122.51.238.153&#x27;,</span></span><br><span class="line">              changeOrigin<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">              pathRewrite<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                &#x27;^/api&#x27;<span class="punctuation">:</span> &#x27;&#x27;</span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>**target**</code>：接口域名；</p>
<p><code>**changeOrigin**</code>： 如果设置为<code>true</code>,那么本地会虚拟一个服务端接收你的请求并代你发送该请求；</p>
<p><code>**pathRewrite**</code>：如果接口中是没有 api 的，那就直接置空（如上）如果接口中有 api，就需要写成{‘^/api’:‘’}</p>
<p><strong>上线了如果还有跨域 可以让后台设置允许跨域</strong></p>
<h2 id="Vue-keep-alive-使用"><a href="#Vue-keep-alive-使用" class="headerlink" title="Vue keep-alive 使用"></a>Vue keep-alive 使用</h2><blockquote>
<p>分析: 此题考查 Vue 中组件缓存的使用</p>
<p><strong>keep-alive  vue 原生自带   用来缓存组件的</strong></p>
<p>解析:  keep-alive 是 Vue 提供的一个全局组件, Vue 的组件是有销毁机制的,比如条件渲染, 路由跳转时 组件都会经历<code>**销毁**</code>, 再次回到页面时,又会回到 <code>**重生**</code>, 这一过程保证了生命周期钩子函数各个过程都会在这一生命周期中执行.</p>
<p>但是,我们辛辛苦苦获取的数据 滑动的页面 会因为组件的销毁 重生 而 <code>**归零**</code>,这影响了交互的体验, 所以 keep-alvie 出现了, 可以帮助我们缓存想要缓存的组件实例, 只用用 keep-alive <code>**包裹**</code>你想要缓存的组件实例, 这个时候, 组件创建之后,就不会再进行 销毁, 组件数据和状态得以保存</p>
<p>但是,没有了销毁,也就失去了重生的环节, 我们失去了 原有的钩子函数, 所以 keep-alive 包裹的组件 都获取了另外<strong>两个事件 –如果缓存组件需要重新获取数据</strong></p>
<p>唤醒 activated 重新唤醒休眠组件实例时 执行</p>
<p>休眠 deactivated 组件实例进入休眠状态时执行</p>
</blockquote>
<p>但是我们不能缓存所有的组件实例, 如果是针对 组件容器 router-view 这个组件进行的缓存, 一般的策略是在路由的元信息 meta 对象中设置是否缓存的标记,   然后根据标记决定是否进行缓存</p>
<p>还有需要注意的问题是:   被缓存的组件中如果还有子组件, 那么子组件也会一并拥有 激活和唤醒事件,并且这些事件会在同时执行</p>
<h2 id="页面刷新了之后-vuex-中的数据消失怎么解决"><a href="#页面刷新了之后-vuex-中的数据消失怎么解决" class="headerlink" title="页面刷新了之后 vuex 中的数据消失怎么解决"></a>页面刷新了之后 vuex 中的数据消失怎么解决</h2><blockquote>
<p><code>**解析**</code>: vuex 数据位于内存, 页面的刷新重置会导致数据的<code>**归零**</code>,也就是所谓的消失,   本地持久化可以解决这个问题.本地持久化用到的技术也就是 本次存储 sesstionStorage 或者 localStorage ,</p>
<p>如果需要保持的更长久 ,浏览器关掉 再打开依然存有数据,需要使用后者</p>
<p>实施方案:  state 的持久化 也就是分别需要在 state 数据初始化 /更新 的时候 进行读取和设置本地存储操作</p>
<p>代码如下</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title function_">store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: localStorge.<span class="title function_">getItem</span>(<span class="string">&quot;user&quot;</span>), <span class="comment">// 初始化时读取 本地存储</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">updateUser</span>(<span class="params">state, payload</span>) &#123;</span><br><span class="line">      state.<span class="property">user</span> = payload.<span class="property">user</span>;</span><br><span class="line">      localStoregae.<span class="title function_">setItem</span>(<span class="string">&quot;user&quot;</span>, payload.<span class="property">user</span>); <span class="comment">// 数据更新时 设置本地存储</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="vue-做服务端渲染"><a href="#vue-做服务端渲染" class="headerlink" title="vue 做服务端渲染"></a>vue 做服务端渲染</h2><p>nuxt.js    vue 语法版本的   服务器渲染(ssr) 框架</p>
<blockquote>
<p>分析: 为什么要做服务端渲染, 首先要明白 服务端渲染解决什么问题</p>
<p><code>**解析**</code>: vuejs 官网说的很明白, 要做服务端渲染首先必须是有对应的需求,即对 实时到达时间(页面访问时间)的绝对需求.   如果只是简单的一个管理系统, 区区几百毫秒的优化 显得十分小题大做.</p>
<p>服务端渲染这里 有一个成熟优秀的框架 nuxt.js , 正如 next.js 对于 react,nuxt 是 vue 服务端渲染的优秀解决方案</p>
</blockquote>
<blockquote>
<p>nuxt 的出现可以让渲染内容完全服务端化,解决 seo 不够友好, 首屏渲染速度不够迅速的问题,</p>
<p>但是这里需要注意: 并不是所有页面都需要服务端渲染, 因为服务端渲染比重多大 对于服务器的访问处理能力 要求也会急剧增大</p>
</blockquote>
<p><strong>普通 vue 项目   打开地址查看源代码   是空</strong>   他主要是用切换的时候才会有内容</p>
<p><strong>nuxt.js 项目   查看源代码 他是已经渲染好了很多 html 了</strong></p>
<p>这个和 seo 搜索引擎 比如百度 他会去 找到所有网站 挨个看你的网站内容 有没有 好不好–爬虫</p>
<p>如果普通 vue   项目 是 空的   那么 就没有内容  seo 不行 网站就很垃圾</p>
<p>如果 nuxt.js 项目   有内容   就比较好 利于 seo</p>
<p>普通 vue 项目   内容打包到 js 了   那个 js 会很大   首页就显示很慢</p>
<p>如果 nuxt.js 项目   只是一些 js 其他的他服务器端就渲染好了   稍微快</p>
<p>vue 单页面应用渲染是从服务器获取所需 js，在客户端将其解析生成 html 挂载于</p>
<p>id 为 app 的 DOM 元素上，这样会存在两大问题。</p>
<ol>
<li>由于资源请求量大，造成网站首屏加载缓慢，不利于用户体验。</li>
<li>由于页面内容通过 js 插入，对于内容性网站来说，搜索引擎无法抓取网站内容，不利于 SEO。<br>Nuxt.js 是一个基于 Vue.js 的通用应用框架，预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。可以将 html 在服务端渲染，合成完整的 html 文件再输出到浏览器。</li>
</ol>
<p><strong>除此之外，nuxt 与 vue 还有一些其他方面的区别。</strong></p>
<ol>
<li><strong>路由</strong><br> nuxt 按照 pages 文件夹的目录结构自动生成路由<br> <a target="_blank" rel="noopener" href="http://localhost:3000/user/reg">http://localhost:3000/user/reg</a>   相当于 去访问  pages 文件夹 下的  user 文件夹 下的 reg.vue<br> vue 需在 src/router/index.js 手动配置路由</li>
<li><strong>入口页面</strong><br> nuxt 页面入口为 layouts/default.vue<br> vue 页面入口为 src/App.vue</li>
<li> nuxt 类似  router-view   nuxt-link   类似 router-link</li>
<li><strong>webpack 配置</strong><br> nuxt 内置 webpack，允许根据服务端需求，在 nuxt.config.js 中的 build 属性自定义构建 webpack 的配置，覆盖默认配置<br> vue 关于 webpack 的配置存放在 build 文件夹下</li>
<li> <strong>asyncData 里面发送 ajax 这个东西跟生命周期这些都是平级的</strong></li>
</ol>
<p>要理解 asyncData 方法执行时，其实是在服务端完成的，这个数据是在服务端渲染好了的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unxtjs的ajax，你先别往你那个异步上去思考，其实这里面所有的ajax最后都会形成页面。你别想着，我一点按钮，调用一个方法，然后再ajax去加载数据。因为我们最后全部都会生成静态，所以任何的获取数据的操作，最后都会变成页面的跳转。</span><br></pre></td></tr></table></figure>

<p>所以，官方给了一套写法，你必须按照这个去写，<br>并且这里的 ajax 会再页面渲染之前就执行。这个东西跟生命周期这些都是平级的。</p>
<p>1 cnpm install @nuxtjs/axios –save<br>2 .plugins 目录新建 axios.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import * as axios from &#x27;axios&#x27;</span><br><span class="line">let options =&#123;&#125;</span><br><span class="line">//需要全路径才能工作</span><br><span class="line">if(process.server)&#123;</span><br><span class="line">　　options.baseURL=http://$&#123;process.env.HOST || &#x27;localhost&#x27;&#125;:$&#123;process.env.PORT || 3000&#125;/api</span><br><span class="line">&#125;</span><br><span class="line">export default axios.create(options)</span><br></pre></td></tr></table></figure>

<p>3.Nuxt.config.js 增加 axios 配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modules:[</span><br><span class="line"></span><br><span class="line">　　&#x27;@nuxtjs/axios&#x27;</span><br><span class="line"></span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>4 使用 asyncData 里面发送 ajax 这个东西跟生命周期这些都是平级的 在页面渲染之前</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  async asyncData(&#123;app&#125;)&#123;</span><br><span class="line">　　        let res =await app.$axios(&#123;</span><br><span class="line">          headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;,</span><br><span class="line">          method: &#x27;get&#x27;,</span><br><span class="line">          url: `http://test.yms.cn/testjson.asp`,</span><br><span class="line">          data: &#x27;&#x27;</span><br><span class="line">        　　&#125;)</span><br><span class="line">        // app.$axios</span><br><span class="line">        　　console.log(&#x27;res&#x27;,res.data)</span><br><span class="line">        　　return&#123;</span><br><span class="line">        　      　testData:res.data.title</span><br><span class="line">        　　&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">      console.log(&#x27;nuxt reg组件&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前端鉴权一般思路"><a href="#前端鉴权一般思路" class="headerlink" title="前端鉴权一般思路"></a>前端鉴权一般思路</h2><p>以前讲过   我们可以 在 axios 的   请求拦截器 里面 配置 token</p>
<p><strong>token</strong></p>
<p>令牌，是用户身份的验证方式。</p>
<p>最简单的 token 组成:uid(用户唯一的身份标识)、time（当前时间的时间戳）、sign（签名）。</p>
<p>对 Token 认证的五点认识</p>
<p><strong>一个 Token 就是一些信息的集合；</strong></p>
<p>在 Token 中包含足够多的信息，以便在后续请求中减少查询数据库的几率；</p>
<p>服务端需要对 cookie 和 HTTP Authrorization Header 进行 Token 信息的检查；</p>
<p>基于上一点，你可以用一套 token 认证代码来面对浏览器类客户端和非浏览器类客户端；</p>
<p>因为 token 是被签名的，所以我们可以认为一个可以解码认证通过的 token 是由我们系统发放的，其中带的信息是合法有效的；</p>
<p><strong>session</strong></p>
<p>会话，代表服务器与浏览器的一次会话过程，这个过程是连续的，也可以时断时续。</p>
<p>cookie 中存放着一个 sessionID，请求时会发送这个 ID；</p>
<p>session 因为请求（request 对象）而产生；</p>
<p>session 是一个容器，可以存放会话过程中的任何对象；</p>
<p>session 的创建与使用总是在服务端，浏览器从来都没有得到过 session 对象；</p>
<p>session 是一种 http 存储机制，目的是为武装的 http 提供持久机制。</p>
<p><strong>cookie</strong></p>
<p>储存在用户本地终端上的数据，服务器生成，发送给浏览器，下次请求统一网站给服务器。</p>
<p><strong>cookie 与 session 区别</strong></p>
<p>cookie 数据存放在客户端上，session 数据放在服务器上；</p>
<p>cookie 不是很安全，且保存数据有限；</p>
<p>session 一定时间内保存在服务器上,当访问增多，占用服务器性能。</p>
<p><strong>session 与 token</strong></p>
<p>作为身份认证，token 安全行比 session 好；</p>
<p>Session 认证只是简单的把 User 信息存储到 Session 里，因为 SID 的不可预测性，暂且认为是安全的。这是一种认证手段。 而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问 某用户的信息。</p>
<p><strong>token 与 cookie</strong></p>
<p>Cookie 是不允许垮域访问的，但是 token 是支持的， 前提是传输的用户认证信息通过 HTTP 头传输；</p>
<p>token 就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie 就是写在客户端的一个 txt 文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用 cookie 自动登录用户名；session 和 cookie 差不多，只是 session 是写在服务器端的文件，也需要在客户端写入 cookie 文件，但是文件里是你的浏览器编号.Session 的状态是存储在服务器端，客户端只有 session id；而 Token 的状态是存储在客户端。</p>
<p>1 有些 axios 请求 需要 token   我们 是可以 配置请求拦截器</p>
<p>2 有些页面 需要登录才能看   我们也可以用路由导航守卫 router.beforeEach   判断 token</p>
<p>3 新情况？侧边栏 有很多 那么 后台侧边栏 有不同的人登录 难道我们要 每个人都可以看全部侧边栏吗？</p>
<p>这个时候就涉及到   如果不同的人登录 权限职位不一样   应该给他展示 不同的侧边栏</p>
<p>这个时候 侧边栏 一般是路由相关的页面   是需要循环生成的</p>
<p>不同的人 路由数组不一样   那么 循环生成的侧边栏 就不一样了</p>
<p>这样就可以控制侧边栏 显示</p>
<p>因为 我们做的并不是传统的项目,而是前后分离项目,也就是前端项目和后端服务进行了<code>**剥离**</code>, 后端没有办法用 session 来存储你任意一个前端项目域名下的身份信息,。</p>
<p>也就是后端不再提供会话的身份存储,而是通过一个鉴权接口将用户的身份,登录时间,请求端口,协议头..等等信息 组装成一个加密的串 返给前端请求,   前端拿到了这个串,就可以认为自己登录成功</p>
<p>那么这个<code>**加密串**</code>就成了 前端用户是否登录的成功标志, 这就是我们的 token , 那么在接下来的接口请求中,我们几乎都要携带这个加密串,因为它是<code>**唯一**</code>能<code>**证明我们身份**</code>的信息.</p>
<p>为了方便,我们会一般在请求工具 axios(举例)的拦截器中<code>**统一注入token**</code>, 减少代码的重复</p>
<p>token 同时具有时效性,我们也需要在此时对 token 过期进行处理,一旦出现过期的请求码, 就需要进行 换取新 token 或者重新登录的解决方案</p>
<p>除此之外,我们还需要依据<code>**有无加密串**</code> 在前端对于某些页面的访问进行限制, 这个会用到我们的 Vue-Router 中的导航守卫.</p>
<p><strong>vue 单页项目涉及到多角色用户权限问题，不同的角色用户拥有不同的功能权限， 不同的功能权限对应的不同的页面</strong></p>
<p>一开始 有一些 默认的路由</p>
<p>登录后 比如你是总经理   后台会返回给前端 总经理能看见的 路由页面地址 数组</p>
<p>前端在 router.beforeEach 路由导航守卫里面 拿到返回的地址   使用 <strong>router.addRouter</strong> 动态加上 这个项目路由就好了</p>
<p>routes= 后台返回的 符合条件的 路由数据 类似我们自己写的那个 path 等等<br>this.$router.addRoutes(routes)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 路由导航守卫</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  　　　　//判断user信息是否已经获取 我已经登录了</span><br><span class="line">          // 登录后就 把 后台给我的路由数组 addRouter就行</span><br><span class="line">          if (token) &#123;</span><br><span class="line">  　　　　　　　　//根据用户的角色类型来生成对应的新路由</span><br><span class="line">              //  在这里要用 登录时候后台返回的 路由数组</span><br><span class="line">              // 建议大家 把那个数组 写在 vuex里面</span><br><span class="line">              // 从vuex 拿出 登录时候存的 newRouter</span><br><span class="line">              // 1 你提前写好 会有所有人能看的 一些 默认的路由</span><br><span class="line">              // 2 不同的 登录后  对应的路由 再追加</span><br><span class="line">              // this.$store.state.newRouter</span><br><span class="line">              // const newRouter = [&#123;path:&quot;/xxx&quot; ...&#125; ..]</span><br><span class="line">              //将新路由添加到路由中</span><br><span class="line">              // router.addRoutes vue带的专门用来追加路由的</span><br><span class="line">              //　router.addRoutes(newRouter)</span><br><span class="line">  　　　　　　　//为了正确渲染导航,将对应的新的路由添加到vuex中</span><br><span class="line">               // 渲染对应的侧边栏</span><br><span class="line">          &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="vue-数据流"><a href="#vue-数据流" class="headerlink" title="vue 数据流"></a>vue 数据流</h2><p>**vue  react 数据流 是单向 的   父–&gt;   子  **</p>
<p>在<strong>vue</strong> <strong>React</strong>中<strong>数据流</strong>向是<strong>单向</strong>的，<strong>由父节点流向子节点</strong>，如果父节点的 props 发生了改变，那么 React 会递归遍历整个组件</p>
<p><strong>父组件通过绑定 props 的方式，将数据传递给子组件，但是子组件自己并没有权利修改这些数据，如果要修改，只能把修改这一个行为通过 event 的方式报告给父组件，由父组件本身决定改如何处理数据。</strong></p>
<h2 id="如何在组件中监听-Vuex-的数据变化"><a href="#如何在组件中监听-Vuex-的数据变化" class="headerlink" title="如何在组件中监听 Vuex 的数据变化"></a>如何在组件中监听 Vuex 的数据变化</h2><p><code>**第一种方案**</code>   我们可以在组件中通过组件的 <strong>watch 方法来做</strong>, 因为组件可以将 state 数据映射到 组件的计算属性上,</p>
<p>然后 监听 映射的计算属性即可 代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vuex中的state数据</span></span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//  A组件中映射 state数据到计算属性</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">   <span class="comment">//  this.$store.state.count</span></span><br><span class="line">  <span class="comment">// mapState       把全局  count 变成 可以直接使用的 数据</span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// A组件监听 count计算属性的变化</span></span><br><span class="line">   <span class="attr">watch</span>: &#123;</span><br><span class="line">     <span class="comment">// watch 可以监听 data 数据 也可以监听 全局 vuex数据</span></span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="comment">// 用本身的数据进行一下计数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">changeCount</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>**第二种方案**</code>   vuex 中 store 对象本身提供了<code>**watch**</code>函数 ,可以利用该函数进行监听</p>
<ul>
<li><strong>watch(fn: Function, callback: Function, options?: Object): Function</strong></li>
</ul>
<p>响应式地侦听 <code>fn</code> 的返回值，当值改变时调用回调函数。<code>fn</code> 接收 store 的 state 作为第一个参数，其 getter 作为第二个参数。最后接收一个可选的对象参数表示 Vue 的 <code>[vm.$watch](https://cn.vuejs.org/v2/api/#vm-watch)</code> 方法的参数。</p>
<p>代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">watch</span>(<span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="property">count</span></span><br><span class="line">  &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">changeCount</span>++</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vue-单页面和多页面的使用"><a href="#Vue-单页面和多页面的使用" class="headerlink" title="Vue 单页面和多页面的使用"></a>Vue 单页面和多页面的使用</h2><p>我想配置多页面？</p>
<p>有多个页面   写死的步骤   只需要 配置 vue.config.js 和对应好文件夹 就行</p>
<p>配置 多入口页面<strong>在 vue.config.js 里写上这些</strong> 重点是入口选择对应页面的 main.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//vue.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      // page 的入口</span><br><span class="line">      entry: &quot;src/views/index/main.js&quot;,</span><br><span class="line">      // 模板来源</span><br><span class="line">      template: &quot;public/index.html&quot;,</span><br><span class="line">      // 在 dist/index.html 的输出</span><br><span class="line">      filename: &quot;index.html&quot;,</span><br><span class="line">      // 当使用 title 选项时，</span><br><span class="line">      // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span><br><span class="line">      title: &quot;Index Page&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ui: &#123;</span><br><span class="line">      // page 的入口</span><br><span class="line">      entry: &quot;src/views/ui/main.js&quot;,</span><br><span class="line">      // 模板来源</span><br><span class="line">      template: &quot;public/ui.html&quot;,</span><br><span class="line">      // 在 dist/ui.html 的输出</span><br><span class="line">      filename: &quot;ui.html&quot;,</span><br><span class="line">      // 当使用 title 选项时，</span><br><span class="line">      // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span><br><span class="line">      title: &quot;ui Page&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4  main.js 不同的入口 对应上自己的 根组件和 页面元素</p>
<p>5   通过 a 标签跳转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    ui页面啊啊啊</span><br><span class="line">    &lt;a href=&quot;home.html&quot;&gt;去home页面&lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="webpack-打包原理是什么"><a href="#webpack-打包原理是什么" class="headerlink" title="webpack 打包原理是什么"></a>webpack 打包原理是什么</h2><p>webpack 打包原理是将根据文件间的依赖关系对其进行静态分析，然后将这些模块按指定规则生成静态资源，当 webpack 处理程序时，会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成 bundle。</p>
<p>webpack 只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。webpack 就是识别你的入口文件。识别你的模块依赖，来打包你的代码。</p>
<p>至于你的代码使用的是 commonjs 还是 amd 或者 es6 的 import。webpack 都会对其进行分析。来获取代码的依赖。</p>
<p>AMD、CMD、CommonJS 和 ES6 Import 四个都是引用 js 文件的方法，具体实现和使用方式不同（都是对模块定义的规范化产出）</p>
<p>webpack 做的就是分析代码。转换代码，编译代码，输出代码。webpack 本身是一个 node 的模块，所以 webpack.config.js 是以 commonjs 形式书写的(node 中的模块化是 commonjs 规范的)</p>
<p>webpack 中每个模块有一个唯一的 id，是从 0 开始递增的。整个打包后的 bundle.js 是一个匿名函数自执行。参数则为一个数组。数组的每一项都为个 function。function 的内容则为每个模块的内容，并按照 require 的顺序排列。</p>
<p>1、Entry</p>
<p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。</p>
<p>2、Output</p>
<p>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上,整个应用程序结构，都会被编译到指定的输出路径的文件夹中。</p>
<p>3、Module</p>
<p>模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</p>
<p>4、Chunk</p>
<p>代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。</p>
<p>5、Loader</p>
<p>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。</p>
<p>loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后就可以利用 webpack 的打包能力，对它们进行处理。</p>
<p>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">const &#123; resolve &#125; = require(&#x27;path&#x27;);</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#x27;./src/js/index.js&#x27;,  //入口</span><br><span class="line">  output: &#123;                     //出口</span><br><span class="line">    filename: &#x27;js/[name].js&#x27;,</span><br><span class="line">    path: resolve(__dirname, &#x27;build&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;                  //模块</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [new HtmlWebpackPlugin()], //插件</span><br><span class="line">  mode: &#x27;development&#x27;,            //模式</span><br><span class="line">  resolve: &#123;              //除css以外</span><br><span class="line">    alias: &#123;</span><br><span class="line">      $css: resolve(__dirname, &#x27;src/css&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [&#x27;.js&#x27;, &#x27;.json&#x27;, &#x27;.jsx&#x27;, &#x27;.css&#x27;],</span><br><span class="line">    modules: [resolve(__dirname, &#x27;../../node_modules&#x27;), &#x27;node_modules&#x27;]</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;         //服务器配置</span><br><span class="line">    // 运行代码的目录</span><br><span class="line">    contentBase: resolve(__dirname, &#x27;build&#x27;),</span><br><span class="line">    // 监视 contentBase 目录下的所有文件，一旦文件变化就会 reload</span><br><span class="line">    watchContentBase: true,</span><br><span class="line">    watchOptions: &#123;</span><br><span class="line">      // 忽略文件</span><br><span class="line">      ignored: /node_modules/</span><br><span class="line">    &#125;,</span><br><span class="line">    // 启动gzip压缩</span><br><span class="line">    compress: true,</span><br><span class="line">    // 端口号</span><br><span class="line">    port: 5000,</span><br><span class="line">    // 域名</span><br><span class="line">    host: &#x27;localhost&#x27;,http 缓存控制</span><br><span class="line">    // 自动打开浏览器</span><br><span class="line">    open: true,</span><br><span class="line">    // 开启HMR功能</span><br><span class="line">    hot: true,</span><br><span class="line">    // 不要显示启动服务器日志信息</span><br><span class="line">    clientLogLevel: &#x27;none&#x27;,</span><br><span class="line">    // 除了一些基本启动信息以外，其他内容都不要显示</span><br><span class="line">    quiet: true,</span><br><span class="line">    // 如果出错了，不要全屏提示~</span><br><span class="line">    overlay: false,</span><br><span class="line">    // 服务器代理 --&gt; 解决开发环境跨域问题</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      // 一旦devServer(5000)服务器接受到 /api/xxx 的请求，就会把请求转发到另外一个服务器(3000)</span><br><span class="line">      &#x27;/api&#x27;: &#123;</span><br><span class="line">        target: &#x27;http://localhost:3000&#x27;,</span><br><span class="line">        // 发送请求时，请求路径重写：将 /api/xxx --&gt; /xxx （去掉/api）</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &#x27;^/api&#x27;: &#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong></p>
<ol>
<li>专注于处理模块化的项目，能做到开箱即用，一步到位</li>
<li>可通过 <code>plugin</code> 扩展，完整好用又不失灵活</li>
<li>社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展</li>
<li>良好的开发体验</li>
</ol>
<p><strong>缺点</strong></p>
<p>只能用于采用模块化开发的项目</p>
<h4 id="npm-打包时需要注意哪些？如何利用-webpack-来更好的构建？"><a href="#npm-打包时需要注意哪些？如何利用-webpack-来更好的构建？" class="headerlink" title="npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？"></a>npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？</h4><p>npm 是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。</p>
<p>NPM 模块需要注意以下问题：</p>
<p>要支持 CommonJS 模块化规范，所以要求打包后的最后结果也遵守该规则。<br>Npm 模块使用者的环境是不确定的，很有可能并不支持 ES6，所以打包的最后结果应该是采用 ES5 编写的。并且如果 ES5 是经过转换的，请最好连同 SourceMap 一同上传。</p>
<p>Npm 包大小应该是尽量小（有些仓库会限制包大小）<br>发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。</p>
<p>UI 组件类的模块应该将依赖的其它资源文件，例如.css 文件也需要包含在发布的模块里。<br>基于以上需要注意的问题，我们可以对于 webpack 配置做以下扩展和优化：<br>输出 ES5 代码的解决方案：使用 babel-loader 把 ES6 代码转换成 ES5 的代码。再通过开启 devtool: ‘source-map’输出 SourceMap 以发布调试。</p>
<p>Npm 包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是修改.babelrc 文件，为其加入 transform-runtime 插件<br>不能将依赖模块打包到 NPM 模块中的解决方案：使用 externals 配置项来告诉 webpack 哪些模块不需要打包。<br>对于依赖的资源文件打包的解决方案：通过 css-loader 和 extract-text-webpack-plugin 来实现</p>
<h3 id="什么是-loader-什么是-plugin"><a href="#什么是-loader-什么是-plugin" class="headerlink" title="什么是 loader ? 什么是 plugin ?"></a>什么是 loader ? 什么是 plugin ?</h3><p>【Loader】：用于对模块源码的转换，loader 描述了 webpack 如何处理非 javascript 模块，并且在 buld 中引入这些依赖。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或者将内联图像转换为 data URL。比如说：CSS-Loader，Style-Loader 等。</p>
<p>【Plugin】：目的在于解决 loader 无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack 提供了很多开箱即用的插件：CommonChunkPlugin 主要用于提取第三方库和公共模块，避免首屏加载的 bundle 文件，或者按需加载的 bundle 文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建 bundle。</p>
<p>loader：模块转换器，<code>webpack</code> 将一切文件视为模块，但 <code>webpack</code> 只能解析 <code>JavaScript</code> 文件，而 loader 作用是让 <code>webpack</code> 拥有了加载 和 解析非 <code>JavaScript</code> 文件的能力。</p>
<p>plugin：在 <code>webpack</code> 构建流程中的特定时机注入扩展逻辑，让它具有更多的灵活性。在 <code>webpack</code> 运行的生命周期中会广播出许多事件，<code>plugin</code> 可以监听这些事件，在合适的时机通过 <code>webpack</code> 提供的 API 改变输出结果。</p>
<p><strong>用法的区别：</strong></p>
<p><code>Loader</code> 在 <code>module.rules</code> 中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个 Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）<br><code>Plugin</code> 在 <code>plugins</code> 中单独配置。 类型为数组，每一项是一个 <code>plugin</code> 的实例，参数都通过构造函数传入。</p>
<h3 id="有哪些常见的-Loader-？他们是解决什么问题的？"><a href="#有哪些常见的-Loader-？他们是解决什么问题的？" class="headerlink" title="有哪些常见的 Loader ？他们是解决什么问题的？"></a>有哪些常见的 Loader ？他们是解决什么问题的？</h3><p><code>file-loader</code>：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件<br><code>url-loader</code>：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去<br><code>source-map-loader</code>：加载额外的 Source Map 文件，以方便断点调试<br><code>image-loader</code>：加载并且压缩图片文件<br><code>babel-loader</code>：把 ES6 转换成 ES5<br><code>css-loader</code>：加载 CSS，支持模块化、压缩、文件导入等特性<br><code>style-loader</code>：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。<br><code>eslint-loader</code>：通过 ESLint 检查 JavaScript 代码<br><code>svg-inline-loader</code>：将压缩后的 SVG 内容注入代码中<br><code>json-loader</code> : 加载 JSON 文件（默认包含）<br><code>ts-loader</code> : 将 TypeScript 转换成 JavaScript<br><code>sass-loader</code>：将 CSS 代码注入 JavaScript 中，通过 DOM 操作去加载 CSS<br><code>vue-loader</code>：加载 Vue.js 单文件组件</p>
<h3 id="有哪些常见的-Plugin？他们是解决什么问题的？"><a href="#有哪些常见的-Plugin？他们是解决什么问题的？" class="headerlink" title="有哪些常见的 Plugin？他们是解决什么问题的？"></a>有哪些常见的 Plugin？他们是解决什么问题的？</h3><p><code>define-plugin</code>：定义环境变量<br><code>commons-chunk-plugin</code>：提取公共代码<br><code>terser-webpack-plugin</code> : 支持压缩 ES6 (Webpack4)<br><code>ignore-plugin</code>：忽略部分文件<br><code>html-webpack-plugin</code>：简化 HTML 文件创建 (依赖于 html-loader)<br><code>web-webpack-plugin</code>：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用<br><code>mini-css-extract-plugin</code> : 分离样式文件，CSS 提取为独立文件，支持按需加载<br><code>serviceworker-webpack-plugin</code>：为网页应用增加离线缓存功能<br><code>clean-webpack-plugin</code> : 删除打包文件<br><code>happypack</code>：实现多线程加速编译</p>
<h3 id="如何利用-webpack-来优化前端性能？"><a href="#如何利用-webpack-来优化前端性能？" class="headerlink" title="如何利用 webpack 来优化前端性能？"></a>如何利用 webpack 来优化前端性能？</h3><p>用 <code>webpack</code> 优化前端性能是指优化 <code>webpack</code> 的输出结果，让打包的最终结果在浏览器运行快速高效。</p>
<p>1.压缩代码。删除多余的代码、注释、简化代码的写法等等方式。<br>用 <code>UglifyJsPlugin</code>和<code>ParallelUglifyPlugin</code>   压缩 JS 文件<br>用 <code>mini-css-extract-plugin</code> 压缩 CSS</p>
<ol>
<li>利用 CDN 加速。在构建过程中，将引用的静态资源路径修改为 CDN 上对应的路径。可以利用 <code>webpack</code> 对于<code>output</code> 参数和各 <code>loader</code> 的 <code>publicPath</code> 参数来修改资源路径</li>
<li>删除死代码。JS 用 <code>Tree Shaking</code>，CSS 需要使用 <code>Purify-CSS</code></li>
<li>提取公共代码。用 <code>CommonsChunkPlugin</code> 插件</li>
</ol>
<h3 id="分别介绍-bundle，chunk，module-是什么"><a href="#分别介绍-bundle，chunk，module-是什么" class="headerlink" title="分别介绍 bundle，chunk，module 是什么"></a>分别介绍 bundle，chunk，module 是什么</h3><p><code>bundle</code>：是由 <code>webpack</code> 打包出来的文件，<br><code>chunk</code>：代码块，一个 <code>chunk</code> 由多个模块组合而成，用于代码的合并和分割。<br><code>module</code>：是开发中的单个模块，在 <code>webpack</code> 的世界，一切皆模块，一个模块对应一个文件，<code>webpack</code> 会从配置的 <code>entry</code> 中递归开始找出所有依赖的模块。</p>
<p>传值给后台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var params = new URLSearchParams();</span><br><span class="line">params.append(&quot;input&quot;, this.input);</span><br><span class="line">this.axios.post(   &quot;/personCustom_api/PersonTp5/public/index/bs/res_search&quot;,params</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> &lt;el-form ref=&quot;form&quot; :model=&quot;sizeForm&quot; label-width=&quot;80px&quot; :rules=&quot;rules&quot;&gt;</span><br><span class="line"> :rules=&quot;rules&quot; 绑定规则</span><br><span class="line"></span><br><span class="line">rules: &#123; //定制规则</span><br><span class="line">        name: [</span><br><span class="line">          &#123;</span><br><span class="line">            required: true,</span><br><span class="line">            message: &quot;不能为空&quot;,</span><br><span class="line">            trigger: &quot;blur&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        ok: [</span><br><span class="line">          &#123;</span><br><span class="line">            required: true,</span><br><span class="line">            message: &quot;请勾选&quot;,</span><br><span class="line">            trigger: &quot;blur&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">          info: [</span><br><span class="line">          &#123;</span><br><span class="line">            validator: info,</span><br><span class="line">            trigger: &quot;blur&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.$refs[form].validate(valid =&gt; &#123;//判断</span><br><span class="line">        if (valid) &#123;</span><br></pre></td></tr></table></figure>

<p>视频</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;video id=&quot;myVideo&quot; class=&quot;video-js&quot;&gt;</span><br><span class="line">&lt;source ref=&quot;videoPlay&quot; :src=&quot;videoURL&quot; type=&quot;video/mp4&quot; /&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure>

<p>访问 state 数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.state.user.username</span><br></pre></td></tr></table></figure>

<h2 id="axios-的封装"><a href="#axios-的封装" class="headerlink" title="axios 的封装"></a>axios 的封装</h2><p>为什么要封装 axios？<br>axios 封装了原生的 XHR，让我们发送请求更为简单，但假设在一个成百上千个 vue 文件的项目中，我们每一个 vue 文件都要写 axios.get()或 axios.post() 岂不是很麻烦？后期的维护也不方便，所以我们要对 axios 进行进一步的封装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//引入config.js文件中导出的GET和POST方法</span><br><span class="line">import &#123;</span><br><span class="line">    GET,</span><br><span class="line">    POST</span><br><span class="line">&#125; from &#x27;./config&#x27;</span><br><span class="line">//引入axios</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">//引入UI组件库</span><br><span class="line">import &#123; Message&#125; from &#x27;element-ui&#x27;</span><br><span class="line"></span><br><span class="line">//调用axios.create方法，配置一些属性，返回一个新的axios</span><br><span class="line">const instance = axios.create(&#123;</span><br><span class="line">    baseURL: &quot;https://api.it120.cc&quot;,//发送请求的时候，会在url前面拼接baseURL</span><br><span class="line">    timeout: 10000,//请求超时时间</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//设置拦截器（拦截器分为请求拦截和响应拦截）</span><br><span class="line"></span><br><span class="line">// 添加请求拦截器</span><br><span class="line">instance.interceptors.request.use(function (config) &#123;</span><br><span class="line">    // 在发送请求之前做些什么</span><br><span class="line">    return config;</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">    // 对请求错误做些什么</span><br><span class="line">    Message(&#123;</span><br><span class="line">        showClose: true,</span><br><span class="line">        message: error.message,</span><br><span class="line">        type: &quot;error&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 添加响应拦截器</span><br><span class="line">instance.interceptors.response.use(function (response) &#123;</span><br><span class="line">    // 对响应数据做点什么</span><br><span class="line">    return response;</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">    // 对响应错误做点什么</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//导出request  三个参数分别是：请求方式（get，post）、地址、参数</span><br><span class="line">export function request(method, url, params) &#123;</span><br><span class="line">	//switch遍历</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">        case GET:</span><br><span class="line">            return get(url, params);</span><br><span class="line">        case POST:</span><br><span class="line">            return post(url, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//get方法的封装</span><br><span class="line">function get(url, params) &#123;</span><br><span class="line">    return instance.get(url, params)</span><br><span class="line">&#125;</span><br><span class="line">//post方法的封装</span><br><span class="line">function post(url, params) &#123;</span><br><span class="line">    return instance.post(url, params)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="em-有什么缺点"><a href="#em-有什么缺点" class="headerlink" title="em 有什么缺点"></a>em 有什么缺点</h2><p>em 会继承父级元素的字体大小。</p>
<h2 id="行内元素产生水平空隙的原因及解决方案"><a href="#行内元素产生水平空隙的原因及解决方案" class="headerlink" title="行内元素产生水平空隙的原因及解决方案"></a>行内元素产生水平空隙的原因及解决方案</h2><p>1.浮动</p>
<p>2.删除代码中间的空格</p>
<p>3.设置负 px</p>
<p>4.设置父元素 font-size:0px</p>
<h2 id="JS-脚本阻塞问题"><a href="#JS-脚本阻塞问题" class="headerlink" title="JS 脚本阻塞问题"></a>JS 脚本阻塞问题</h2><ol>
<li>async(异步)<br> 如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 async。<br> （异步加载，立即执行：脚本下载完成后，会立即执行；无法保证脚本的执行顺序）</li>
<li>defer（延迟）<br> 如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 defer，将关联的脚本按所需顺序置于 HTML 中。<br> （异步加载，延后执行：脚本下载完成后，会等待页面下载解析完成后，再执行；可以保证脚本按书写顺序执行）</li>
</ol>
<h2 id="有一个页面，他必须实时展示最新的数据"><a href="#有一个页面，他必须实时展示最新的数据" class="headerlink" title="有一个页面，他必须实时展示最新的数据"></a>有一个页面，他必须实时展示最新的数据</h2><p>HTTP 轮询 也就是使用 Ajax 配合定时器定时请求数据更新</p>
<p>WebSocket 这个就是专门用来处理服务器端推送的长链接协议了。</p>
<h2 id="为什么-prototype-判断数组类型"><a href="#为什么-prototype-判断数组类型" class="headerlink" title="为什么 prototype 判断数组类型"></a>为什么 prototype 判断数组类型</h2><p>同样是检测对象 obj 调用 toString 方法，obj.toString()的结果和 Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p>
<p>这是因为 toString 为 Object 的原型方法，而 Array 、Function 等类型作为 Object 的实例，都重写了 toString 方法。</p>
<p>不同的对象类型调用 toString 方法时，根据原型链的知识，调用的是对应的重写之后的 toString 方法（Function 类型返回内容为函数体的字符串，Array 类型返回元素组成的字符串…..），而不会去调用 Object 上原型 toString 方法（返回对象的具体类型），所以采用 obj.toString()不能得到其对象类型，只能将 obj 转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用 Object 上原型 toString 方法。</p>
<p>我们可以验证一下，将数组的 toString 方法删除，看看会是什么结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3];</span><br><span class="line">console.log(Array.prototype.hasOwnProperty(&quot;toString&quot;));//true</span><br><span class="line">console.log(arr.toString());//1,2,3</span><br><span class="line">delete Array.prototype.toString;//delete操作符可以删除实例属性</span><br><span class="line">console.log(Array.prototype.hasOwnProperty(&quot;toString&quot;));//false</span><br><span class="line">console.log(arr.toString());//&quot;[object Array]&quot;</span><br></pre></td></tr></table></figure>

<p>删除了 Array 的 toString 方法后，同样再采用 arr.toString()方法调用时，不再有屏蔽 Object 原型方法的实例方法，因此沿着原型链，arr 最后调用了 Object 的 toString 方法，返回了和 Object.prototype.toString.call(arr)相同的结果。</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>原型对象有一个 constructor 属性，指向该原型对象对应的构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;&#125;;</span><br><span class="line">console.log(Foo.prototype.constructor === Foo);//true</span><br></pre></td></tr></table></figure>

<h2 id="js-如何判断数组是-Array-类型"><a href="#js-如何判断数组是-Array-类型" class="headerlink" title="js 如何判断数组是 Array 类型"></a>js 如何判断数组是 Array 类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">console.log(arr instanceof Array) //返回true</span><br><span class="line">console.log([].constructor == Array//true</span><br><span class="line">Array.isArray([]) //true</span><br><span class="line"></span><br><span class="line">使用Object.prototype.toString.call(arr) === &#x27;[object Array]&#x27;方法</span><br><span class="line">function isArray(o) &#123;</span><br><span class="line">　　return Object.prototype.toString.call(o);//这个方法就是可以区分什么类型的</span><br><span class="line">&#125;</span><br><span class="line">var arr=[2,5,6,8];</span><br><span class="line">var obj=&#123;name:&#x27;zhangsan&#x27;,age:25&#125;;</span><br><span class="line">var fn = function () &#123;&#125;</span><br><span class="line">console.log(isArray(arr)); //[object Array]</span><br><span class="line">console.log(isArray(obj)); //[object Object]</span><br><span class="line">console.log(isArray(fn));  //[object function]</span><br></pre></td></tr></table></figure>

<h2 id="清除浮动的最常用的四种方法"><a href="#清除浮动的最常用的四种方法" class="headerlink" title="清除浮动的最常用的四种方法"></a>清除浮动的最常用的四种方法</h2><p>1.额外标签法（在最后一个浮动标签后，新加一个标签，给其设置 clear：both；）（不推荐）</p>
<p>优点：通俗易懂，方便</p>
<p>缺点：添加无意义标签，语义化差</p>
<p>2.父级添加 overflow 属性（父元素添加 overflow:hidden）（不推荐）</p>
<p>优点：代码简洁</p>
<p>缺点：内容增多的时候容易造成不会自动换行导致内容被隐藏掉，无法显示要溢出的元素</p>
<p>3.使用 after 伪元素清除浮动（推荐使用）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;/*伪元素是行内元素 正常浏览器清除浮动方法*/</span><br><span class="line">       content: &quot;&quot;;</span><br><span class="line">       display: block;</span><br><span class="line">       height: 0;</span><br><span class="line">       clear:both;</span><br><span class="line">       visibility: hidden;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>优点：符合闭合浮动思想，结构语义化正确</p>
<p>4.使用 before 和 after 双伪元素清除浮动</p>
<h2 id="js-对象拷贝的三种方法"><a href="#js-对象拷贝的三种方法" class="headerlink" title="js 对象拷贝的三种方法"></a>js 对象拷贝的三种方法</h2><table>
<thead>
<tr>
<th>赋值</th>
<th>浅层拷贝</th>
<th>深层拷贝</th>
<th>getter/setter</th>
</tr>
</thead>
<tbody><tr>
<td>Object.assign</td>
<td>ok</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>JSON.stringify</td>
<td>ok</td>
<td>ok</td>
<td>no</td>
</tr>
<tr>
<td>Object.create</td>
<td>ok</td>
<td>no</td>
<td>ok</td>
</tr>
</tbody></table>
<p>解构运算符也是浅拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// new Object() 方式创建</span><br><span class="line">var a = &#123;  rep : &#x27;apple&#x27; &#125;</span><br><span class="line">var b = new Object(a)</span><br><span class="line">console.log(b) // &#123;rep: &quot;apple&quot;&#125;</span><br><span class="line">console.log(b.__proto__) // &#123;&#125;</span><br><span class="line">console.log(b.rep) // &#123;rep: &quot;apple&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>v-html 可以加载富文本：解析代码</p>
<h2 id="Vue-不同页面跳转时各页面生命周期的执行顺序"><a href="#Vue-不同页面跳转时各页面生命周期的执行顺序" class="headerlink" title="Vue 不同页面跳转时各页面生命周期的执行顺序"></a>Vue 不同页面跳转时各页面生命周期的执行顺序</h2><p>先新页面的 beforeCreate、created、beforeMount，然后旧页面的 beforeDestroy、destroyed，再然后新页面的 mounted 等。</p>
<h2 id="MongoDB-和关系型数据库"><a href="#MongoDB-和关系型数据库" class="headerlink" title="MongoDB 和关系型数据库"></a>MongoDB 和关系型数据库</h2><p><strong>①mongodb 不支持事务操作。</strong></p>
<p><strong>②mongodb 占用空间过大。</strong></p>
<p><strong>③MongoDB 没有如 MySQL 那样成熟的维护工具，这对于开发和 IT 运营都是个值得注意的地方。</strong></p>
<p>关系型数据库和非关系型数据库</p>
<p>数据库有记录有字段</p>
<h2 id="前端库"><a href="#前端库" class="headerlink" title="前端库"></a>前端库</h2><p>echart elemeny mint jquery Layer-Layui</p>
<p>库：库是更多是一个封装好的特定的集合，提供给开发者使用，而且是特定于某一方面的集合（方法和函数），库没有控制权，控制权在使用者手中，在库中查询需要的功能在自己的应用中使用，我们可以从封装的角度理解库；</p>
<p>框架：框架顾名思义就是一套架构，会基于自身的特点向用户提供一套相当于叫完整的解决方案，而且控制权的在框架本身，使用者要找框架所规定的某种规范进行开发。</p>
<h2 id="使用-CSS-实现一个梯形"><a href="#使用-CSS-实现一个梯形" class="headerlink" title="使用 CSS 实现一个梯形"></a>使用 CSS 实现一个梯形</h2><p>先构造三角形，再使用 transform: translate(-54px,10px)拼接</p>
<h2 id="栈与堆"><a href="#栈与堆" class="headerlink" title="栈与堆"></a>栈与堆</h2><p>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。<br>其操作方式类似于数据结构中的栈。</p>
<p>堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</p>
<h2 id="undefined-与-undeclared-的区别"><a href="#undefined-与-undeclared-的区别" class="headerlink" title="undefined 与 undeclared 的区别"></a>undefined 与 undeclared 的区别</h2><p>已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。</p>
<h4 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h4><ul>
<li>p.<strong>proto</strong></li>
<li>p.constructor.prototype</li>
<li>Object.getPrototypeOf(p)</li>
</ul>
<h2 id="watch，computed-怎么监听深层次的对象。"><a href="#watch，computed-怎么监听深层次的对象。" class="headerlink" title="watch，computed,怎么监听深层次的对象。"></a>watch，computed,怎么监听深层次的对象。</h2><p>开启深度监听</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">           a: &#123;</span><br><span class="line">               b: &#123;</span><br><span class="line">                   c :&#x27;张三&#x27;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        a: &#123;</span><br><span class="line">// deep 为true  意味着开启了深度监听 a对象里面任何数据变化都会触发handler函数,</span><br><span class="line">            deep: true,</span><br><span class="line">            handler(val, oldval)&#123;</span><br><span class="line">               // handler是一个固定写法</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串嵌套方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line"> data () &#123;</span><br><span class="line">     return &#123;</span><br><span class="line">        a: &#123;</span><br><span class="line">            b: &#123;</span><br><span class="line">                c :&#x27;张三&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> watch: &#123;</span><br><span class="line">     //想监听 c  此时 数据 是 a.b.c  比较深   深度监听</span><br><span class="line">     //用这种写法，就不要使用简写了</span><br><span class="line">     &quot;a.b.c&quot;: function (newValue, oldValue) &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTTP-请求-响应报文结构"><a href="#HTTP-请求-响应报文结构" class="headerlink" title="HTTP 请求/响应报文结构"></a>HTTP 请求/响应报文结构</h2><p>1.请求行</p>
<p>2.请求头部</p>
<p>3.空行</p>
<p>它的作用是通过一个空行，告诉服务器请求头部到此为止</p>
<p>4.请求数据</p>
<p>HTTP 响应报文</p>
<p>同样的，HTTP 响应报文也由三部分组成：响应行、响应头、响应体</p>
<h2 id="有哪些样式可以给子元素继承"><a href="#有哪些样式可以给子元素继承" class="headerlink" title="有哪些样式可以给子元素继承"></a>有哪些样式可以给子元素继承</h2><p>样式一般可继承</p>
<p>不可继承一般是会改变盒子模型的</p>
<h2 id="vue-cli-是什么"><a href="#vue-cli-是什么" class="headerlink" title="vue-cli 是什么"></a>vue-cli 是什么</h2><p>vue-cli 是有 Vue 提供的一个官方 cli，专门为单页面应用快速搭建繁杂的脚手架。它是用于自动生成 vue.js+webpack 的项目模板，是为现代前端工作流提供了 batteries-included 的构建设置。只需要几分钟的时间就可以运行起来并带有热重载，保存时 lint 校验，以及生产环境可用的构建版本</p>
<h2 id="setData-是异步还是同步？"><a href="#setData-是异步还是同步？" class="headerlink" title="setData 是异步还是同步？"></a>setData 是异步还是同步？</h2><p>（赋值同步，回调异步）</p>
<h1 id="xss-和-csrf-介绍"><a href="#xss-和-csrf-介绍" class="headerlink" title="xss 和 csrf 介绍"></a>xss 和 csrf 介绍</h1><ol>
<li>xss   跨站脚本攻击  csrf 是跨站请求伪造</li>
<li>xss<br>浏览器向服务器请求的时候被注入脚本攻击<br>分成三种类型   反射型（非持久型）， 存储型（持久型）， 基于 DOM<br>防范手段：</li>
<li>输入过滤</li>
<li>输出过滤</li>
<li>加 httponly 请求头   锁死 cookie</li>
<li>csrf<br>黑客通过网站 B 诱使用户去访问已经登录了的网站 A 进行一些违背用户意愿的请求   造成用户损失<br>防范手段：</li>
<li>服务器验证  http 请求的 refer 头信息</li>
<li>请求的时候 传 token</li>
<li>加验证码</li>
</ol>
<p>vue 请求数据放在 created 好还是 mounted 里好<br>建议放在 created 里<br>created:在模板渲染成 html 前调用，即通常初始化某些属性值，然后再渲染成视图。<br>mounted:在模板渲染成 html 后调用，通常是初始化页面完成后，再对 html 的 dom 节点进行一些需要的操作。</p>
<p>如果在 mounted 钩子函数中请求数据可能导致页面闪屏问题<br>其实就是加载时机问题，放在 created 里会比 mounted 触发早一点，如果在页面挂载完之前请求完成的话就不会看到闪屏了</p>
<p>vue 开发调试工具（vue-devtools）</p>
<p>谷歌浏览器调试工具</p>
<h2 id="一-先来认识一下这些按钮"><a href="#一-先来认识一下这些按钮" class="headerlink" title="一. 先来认识一下这些按钮"></a>一. 先来认识一下这些按钮</h2><p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/52af2165-aa3b-41ea-acdf-4c3fb7ba3b27.png#id=G1CxA&originHeight=168&originWidth=669&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>先来看这张图最上头的一行是一个功能菜单，每一个菜单都有它相应的功能和使用方法，依次从左往右来看</p>
<p><strong>1.箭头按钮</strong>：用于在页面选择一个元素来审查和查看它的相关信息，当我们在<strong>Elements</strong>这个按钮页面下点击某个 Dom 元素时，箭头按钮会变成选择状态</p>
<p><strong>2.设备图标</strong>：点击它可以切换到不同的终端进行开发模式，移动端和 pc 端的一个切换，可以选择不同的移动终端设备，同时可以选择不同的尺寸比例，chrome 浏览器的模拟移动设备和真实的设备相差不大，是非常好的选择</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/51d40eb1-3e74-4e27-9583-b3b50f332510.png#id=GSkMx&originHeight=224&originWidth=406&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>可选择的适配</p>
<p><strong>3.Elements</strong> 功能标签页：用来查看，修改页面上的元素，包括 DOM 标签，以及 css 样式的查看，修改，还有相关盒模型的图形信息，下图我们可以看到当我鼠标选择 id 为 lg_tar 的 div 元素时，右侧的 css 样式对应的会展示出此 id 的样式信息，此时可以在右侧进行一个修改，修改即可在页面上生效， 灰色的 element.style 样式同样可以进行添加和书写，唯一的区别是，在这里添加的样式是添加到了该元素内部，实现方式即：该 div 元素的 style 属性，这个页面的功能很强大，在我们做了相关的页面后，修改样式是一块很重要的工作，细微的差距都需要调整，但是不可能说做到每修改一点即编译一遍代码，再刷新浏览器查看效果，这样很低效，一次性在浏览器中修改之后，再到代码中进行修改</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/b548b239-eb00-447d-be60-29c1c3b3ce9b.png#id=lBkOy&originHeight=137&originWidth=551&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>对应的样式</li>
</ul>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/54802412-70df-4c69-8adb-cea9c52b2b09.png#id=axFkz&originHeight=478&originWidth=504&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>盒模型信息</li>
</ul>
<p>同时，当我们浏览网站看到某些特别炫酷的效果和难做的样式时候，打开这个功能，我们即可看到别人是如何实现的，学会它这知识就是你的了，仔细钻研也会有意想不到的收获</p>
<p><strong>4.Console 控制台</strong>：用于打印和输出相关的命令信息，其实 console 控制台除了我们熟知的报错，打印 console.log 信息外，还有很多相关的功能，下面简单介绍几个：</p>
<p>a: 一些对页面数据的指令操作，比如打断点正好执行到获取的数据上，由于数据都是层层嵌套的对象，这个时候查看里面的 key/value 不是很方便，即可用这个指令开查看，obj 的 json string 格式的 key/value，我们对于数据里面有哪些字段和属性即可一目了然</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/ac4fc806-f29a-44e2-bcf0-95b28c401790.png#id=bVnSe&originHeight=143&originWidth=371&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>其他功能</p>
<p>b: 除了 console.log 还有其他相关的指令可用</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/6e7f7867-9422-4238-a23b-d463e1f799d5.png#id=h2cBS&originHeight=211&originWidth=369&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>console 也有相关的 API</p>
<p><strong>5.Sources</strong> js 资源页面：这个页面内我们可以找到当然浏览器页面中的 js 源文件，方便我们查看和调试，在我还没有走出校园时候，我经常看一些大站的 js 代码，那时候其实基本都看不懂，但是最起码可以看看人家的代码风格，人家的命名方式，所有的代码都是压缩之后的代码，我们可以点击下面的{}大括号按钮将代码转成可读格式</p>
<p>Sources Panel 的左侧分别是 Sources 和 Content scripts 和 Snippets</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/a147d491-68bd-45d7-8403-6c25ce99201e.png#id=Yhr34&originHeight=351&originWidth=690&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>对应的源代码</li>
</ul>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/a8e61566-e44e-4a92-95e0-c872cf9a2cbb.png#id=YWP7R&originHeight=334&originWidth=736&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>格式化后的代码</li>
</ul>
<p>关于打断点调试的内容，下面介绍，先来说一些，其他平时基本没人用但是很有用的小点，比如当我们想不起某个方法的具体使用时候，会打开控制台随意写一些测试代码，或者想测试一下刚刚写的方法是否会出现期待的样子，但是控制台一打回车本想换行但是却执行刚写的半截代码，所以推荐使用<strong>Sources</strong>下面的左侧的 Sinppets 代码片段按钮，这时候点击创建一个新的片段文件，写完测试代码后把鼠标放在新建文件上 run，再结合控制台查看相关信息（<strong>新建了一个名叫：app.js 的片段代码，在你的项目环境页面内，该片段可执行项目内的方法</strong>）</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/f56570d0-2ec4-4970-8ba5-c1bf2b8abf2d.png#id=dpdtd&originHeight=255&originWidth=669&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>自己书写的片段</li>
</ul>
<p>Content scripts 是 Chrome 的一种扩展程序，它是按照扩展的 ID 来组织的，这些文件也是嵌入在页面中的资源，这类文件可以读写和操作我们的资源，需要调试这些扩展文件，则可以在这个目录下打开相关文件调试，但是几乎我们的项目还没有相关的扩展文件，所以啥也看不到，平时也不需要关心这块</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/e93f193c-3bf2-41ef-b300-e199a8a60d27.png#id=iKGWi&originHeight=186&originWidth=376&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>无结果</p>
<p><strong>6.Network</strong> 网络请求标签页：可以看到所有的资源请求，包括网络请求，图片资源，html,css，js 文件等请求，可以根据需求筛选请求项，一般多用于网络请求的查看和分析，分析后端接口是否正确传输，获取的数据是否准确，请求头，请求参数的查看</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/83a9003a-434c-4f11-a7d6-6ce2f5965106.png#id=RvY9l&originHeight=509&originWidth=925&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>所有的资源</li>
</ul>
<p>以上我选择了 All，就会把该页面所有资源文件请求下来，如果只选择 XHR 异步请求资源，则我们可以分析相关的请求信息</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/a36f5b9e-2e06-4593-9c77-a50d798bc8ea.png#id=cskGk&originHeight=461&originWidth=738&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>请求的相关信息</li>
</ul>
<p>打开一个 Ajax 异步请求，可以看到它的请求头信息，是一个 POST 请求，参数有哪些，还可以预览它的返回的结果数据，这些数据的使用和查看有利于我们很好的和后端工程师们联调数据，也方便我们前端更直观的分析数据</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/90ebfadd-e79a-4837-9873-5cbb0cd1b0f2.png#id=ArlxW&originHeight=473&originWidth=760&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>预览请求的数据</li>
</ul>
<p><strong>7.Timeline</strong>标签页可以显示 JS 执行时间、页面元素渲染时间，不做过多介绍</p>
<p><strong>8.Profiles</strong>标签页可以<strong>查看</strong>CPU 执行时间与内存占用，不做过多介绍</p>
<p><strong>9.Resources</strong>标签页会列出所有的资源，以及 HTML5 的 Database 和 LocalStore 等，你可以对存储的内容编辑和删除 不做过多介绍</p>
<p><strong>10.Security</strong>标签页 可以告诉你这个网站的安全性，查看有效的证书等</p>
<p><strong>11.Audits</strong>标签页 可以帮你分析页面性能，有助于优化前端页面，分析后得到的报告</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/2e0393c9-cc86-4a20-905e-3f80154f4f2f.png#id=eIGSY&originHeight=299&originWidth=727&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>分析结果</li>
</ul>
<h2 id="二-Sources-资源页面的断点调试"><a href="#二-Sources-资源页面的断点调试" class="headerlink" title="二.Sources 资源页面的断点调试"></a>二.Sources 资源页面的断点调试</h2><p><strong>1.如何调试</strong>：</p>
<p>调试 js 代码，肯定是我们常用的功能，那么如何打断点，找到要调试的文件，然后在内容源代码左侧的代码标记行处点击即可打上一个断点</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/0d2066b5-e10e-4562-b5f7-eef9ff2e9a02.png#id=aut2p&originHeight=321&originWidth=904&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><strong>2.断点与 js 代码修改</strong></p>
<p>看下面这张图，我在一个名为 toggleTab 的方法下打了两个断点，当开始执行我们的点击切换 tab 行为后，代码会在执行的断点出停下来，并把相关的数据展示一部分，此时可以在已经执行过得代码处，把鼠标放上去，即可查看相关的具体数据信息，同时我们可以使用右侧的功能键进行调试，右侧最上面一排分别是：暂停/继续、单步执行(<strong>F10 快捷键</strong>)、单步跳入此执行块(<strong>F11 快捷键</strong>)、单步跳出此执行块、禁用/启用所有断点。下面是各种具体的功能区</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/980c6de1-f378-48c3-90a5-6d865b46881f.png#id=gOkw2&originHeight=398&originWidth=814&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>在代码中打断点</li>
</ul>
<p>在当前的代码执行区域，在调试中如果发现需要修改的地方，也是可以立即修改的，修改后保存即可生效，这样就免去了再到代码中去书写，再刷新回看了</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/cce6a3d6-e055-43ea-9687-e3f1fa6854cf.png#id=NnCyJ&originHeight=294&originWidth=717&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>临时修改</p>
<p>**<br>**</p>
<p><strong>3.快速进入调试的方法</strong></p>
<p>当我们的代码执行到某个程序块方法处，这个方法上可能你并没有设置相关的断点，此时你可以 F11 进入此程序块，但是往往我们的项目都是经过很多源代码封装好的方法，有时候进入后，会走很多底层的封装方法，需要很多步骤才能真正进入这个函数块，此时将鼠标放在此函数上，会出现相关提示，会告诉你在该文件的哪一行代码处，点击即可直接看到这个函数，然后临时打上断点，按 F10 或者点击右上角的第二个按钮即可直接进入此函数的断点处</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/5130e68e-74c7-4b1a-9a12-7f5e7f5ceb6d.png#id=JIokE&originHeight=210&originWidth=586&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>**<br>**</p>
<p><strong>4.调试的功能区域</strong></p>
<p>每一个功能区，都有它相关的左右，先来看一张图，它都有哪些功能</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/bdb50caf-0484-47b9-a3ed-ec0aa9d38e67.png#id=DdZdp&originHeight=205&originWidth=339&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><strong>Call Stack 调用栈</strong>：当断点执行到某一程序块处停下来后，右侧调试区的 Call Stack 会显示当前断点所处的方法调用栈，从上到下由最新调用处依次往下排列，Call Stack 列表的下方是 Scope Variables 列表可以查看此时局部变量和全局变量的值。图中可以看出，我们最先走了 toggleTab 这个方法，然后走到了一个更新对象的方法上，当前调用在哪里，箭头会帮你指向哪里，同时我们可以点击，调用栈列表上的任意一处，即可回头再去看看代码</p>
<p><img src="http://www.igeekbar.com/igeekbar/networks/uploadimgthumb/8dd4193f-f723-4597-9633-1c789fbf474b.png#id=bpRfr&originHeight=304&originWidth=885&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>但是若你想从新从某个调用方法出执行，可以右键 Restart Frame， 断点就会跳到此处开头重新执行，<strong>Scope</strong> 中的变量值也会依据代码从新更改，这样就可以回退来从新调试，错过的调试也可以回过头来反复查看</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/c7ba0acc-7305-4a55-9790-6bc637922989.png#id=FxjMm&originHeight=143&originWidth=604&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><strong>Breakpoints</strong>关于断点：所有当前 js 的断点都会展示在这个区域，你可以点击按钮用来“去掉/加上”此处断点，也可以点击下方的代码表达式，调到相应的程序代码处，来查看</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/1cd4281f-4170-40e4-8bfa-cc0050af9a53.png#id=cfqLQ&originHeight=118&originWidth=559&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><strong>XHR Breakpoints</strong></p>
<p>在 XHR Breakpoints 处，点击右侧的+号，可以添加请求的 URL，一旦 XHR 调用触发时就会在 request.send() 的地方中断</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/238a0267-dbd8-4dd3-8598-b09895b5694e.png#id=KHqLV&originHeight=123&originWidth=783&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><strong>DOM Breakpoints:</strong></p>
<p>可以给你的 DOM 元素设置断点，有时候真的需要监听和查看某个元素的变化情况，赋值情况，但是我们并是不太关心哪一段代码对它做的修改，只想看看它的变化情况，那么可以给它来个监听事件，这个时候 DOM Breakpoints 中会如图</p>
<p><img src="http://igeekbar.com/igeekbar/networks/uploadimgthumb/da1c5b48-42db-4d5f-8a24-19389fa858f0.png#id=tXUqB&originHeight=476&originWidth=586&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>当要给 DOM 添加断点的时候，会出现选择项分别是如下三种修改 1.子节点修改 2.自身属性修改 3.自身节点被删除。选中之后，Sources Panel 中右侧的 DOM Breakpoints 列表中就会出现该 DOM 断点。一旦执行到要对该 DOM 做相应修改时，代码就会在那里停下来</p>
<p><strong>Event listener Breakpoints</strong></p>
<p>最后 Event Listener 列表，这里列出了各种可能的事件类型。勾选对应的事件类型，当触发了该类型的事件的 JavaScript 代码时就会自动中断</p>
<h2 id="前后端传值"><a href="#前后端传值" class="headerlink" title="前后端传值"></a>前后端传值</h2><h2 id="tp5-使用-jwt-生成-token-做-api-的用户认证"><a href="#tp5-使用-jwt-生成-token-做-api-的用户认证" class="headerlink" title="[tp5 使用 jwt 生成 token,做 api 的用户认证]"></a>[tp5 使用 jwt 生成 token,做 api 的用户认证]</h2><p>首先 composer 安装 firebase/php-jwt</p>
<p>github：<a target="_blank" rel="noopener" href="https://github.com/firebase/php-jwt">https://github.com/firebase/php-jwt</a></p>
<p>composer require firebase/php-jwt<br>使用</p>
<p>当用户登录时，如果有 token 并且没有过期，则得到用户信息，如果 token 过期，或者是新用户，则生成一个 token 具体业务自已看着办，这里只讨论使用</p>
<p>下面是为用户颁发 token</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public function getToken()&#123;</span><br><span class="line">        $key = &quot;hdj&quot;;  //这里是自定义的一个随机字串，应该写在config文件中的，解密时也会用，相当    于加密中常用的 盐  salt</span><br><span class="line">        $token = [</span><br><span class="line">            &quot;iss&quot;=&gt;&quot;&quot;,  //签发者 可以为空</span><br><span class="line">            &quot;aud&quot;=&gt;&quot;&quot;, //面象的用户，可以为空</span><br><span class="line">            &quot;iat&quot; =&gt; time(), //签发时间</span><br><span class="line">            &quot;nbf&quot; =&gt; time(), //在什么时候jwt开始生效</span><br><span class="line">            &quot;exp&quot; =&gt; time()+7200, //token 过期时间</span><br><span class="line">            &quot;user&quot; =&gt; [&#x27;id&#x27;=&gt;&#x27;123&#x27;,&#x27;name&#x27;=&gt;&#x27;hdj&#x27;,&#x27;age&#x27;=&gt;23] //记录的userid的信息，这里是自已添加上去的，如果有其它信息，可以再添加数组的键值对</span><br><span class="line">        ];</span><br><span class="line">        $jwt = JWT::encode($token,$key,&quot;HS256&quot;); //根据参数生成了 token</span><br><span class="line">        return json_encode([</span><br><span class="line">            &quot;token&quot;=&gt;$jwt</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面生成了 token 并返回给的客户端，以后客户端再访问时，就带上 token 信息，就可以知道用户的信息了</p>
<p>方法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public function check()&#123;</span><br><span class="line">        $jwt = input(&quot;token&quot;);  //上一步中返回给用户的token</span><br><span class="line">        $key = &quot;hdj&quot;;  //上一个方法中的 $key 本应该配置在 config文件中的</span><br><span class="line">        try &#123;</span><br><span class="line">            $info = JWT::decode($jwt, $key, [&quot;HS256&quot;]); //解密jwt</span><br><span class="line">            return json($info);</span><br><span class="line">        &#125;catch (\Exception $e)&#123;</span><br><span class="line">            echo $e-&gt;getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>前台获取 token：</p>
<p><a target="_blank" rel="noopener" href="http://192.168.7.68:5588/index/check/getToken">http://192.168.7.68:5588/index/check/getToken</a></p>
<p>返回：</p>
<p>{“token”:”eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJoZGoiLCJhdWQiOiIiLCJpYXQiOjE1ODk0Mjc4OTYsIm5iZiI6MTU4OTQyNzg5NiwiZXhwIjoxNTg5NDM1MDk2LCJ1c2VyIjp7ImlkIjoiMTIzIiwibmFtZSI6ImhkaiIsImFnZSI6MjN9fQ.sWwg3NwQ0UVzj05GqubdPQWkR5bsDM-qAFnZFOLINk8”}</p>
<p>后台验证：</p>
<p><a target="_blank" rel="noopener" href="http://192.168.7.68:5588/index/check/check?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJoZGoiLCJhdWQiOiIiLCJpYXQiOjE1ODk0Mjc4OTYsIm5iZiI6MTU4OTQyNzg5NiwiZXhwIjoxNTg5NDM1MDk2LCJ1c2VyIjp7ImlkIjoiMTIzIiwibmFtZSI6ImhkaiIsImFnZSI6MjN9fQ.sWwg3NwQ0UVzj05GqubdPQWkR5bsDM-qAFnZFOLINk8">http://192.168.7.68:5588/index/check/check?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJoZGoiLCJhdWQiOiIiLCJpYXQiOjE1ODk0Mjc4OTYsIm5iZiI6MTU4OTQyNzg5NiwiZXhwIjoxNTg5NDM1MDk2LCJ1c2VyIjp7ImlkIjoiMTIzIiwibmFtZSI6ImhkaiIsImFnZSI6MjN9fQ.sWwg3NwQ0UVzj05GqubdPQWkR5bsDM-qAFnZFOLINk8</a></p>
<p>返回：</p>
<p>{“iss”: “hdj”,”aud”: “”,”iat”: 1589427896,”nbf”: 1589427896,”exp”: 1589435096,”user”: {“id”: “123”,”name”: “hdj”,”age”: 23}}</p>
<h1 id="vuex-Getters-基本用法"><a href="#vuex-Getters-基本用法" class="headerlink" title="vuex Getters 基本用法"></a>vuex Getters 基本用法</h1><p><strong>一.什么是 getters?</strong><br>vuex 中的 getters 用于对 state 中存储的数据进行过滤操作。<br>比如等级：假设 1 代表初级，2 代表中级，3 代表高级。在 state 中存储 level 值为 1 或 2 或 3.想在页面中获取对应等级就需要进行转换。此时就需要用到 getters。</p>
<p><strong>二.使用 getters</strong><br><strong>1.在 store 文件夹下创建 getters.js 文件,并在 index 下引入</strong><br><img src="https://segmentfault.com/img/bVbCvL6#id=E23HW&originHeight=115&originWidth=227&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://segmentfault.com/img/bVbCvMB#id=z6g0W&originHeight=441&originWidth=683&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><strong>2.在 state.js 增加 userStatus</strong><br><img src="https://segmentfault.com/img/bVbCvSi#id=oSIqa&originHeight=134&originWidth=216&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="><br>其中 userStatus 代表等级，0 为普通会员，1 为 vip 会员，2 为高级会员<br><strong>3.getters 代码如下，对 userStatus 进行转换</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const getters =&#123;</span><br><span class="line">    memberInfo(state)&#123;</span><br><span class="line">        switch (state.userStatus) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                return &quot;普通会员&quot;</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                return &quot;vip会员&quot;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                return &quot;高级会员&quot;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default getters;</span><br></pre></td></tr></table></figure>

<p>此时控制台会展示<br><img src="https://segmentfault.com/img/bVbCvRV#id=kTLO8&originHeight=437&originWidth=542&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>4.界面中获取 userLevel 的值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;&#123;&#123; $store.getters.memberInfo &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>vuex 中提供了更简单的获取方法：<br><img src="https://segmentfault.com/img/bVbCvZS#id=HTc7j&originHeight=374&originWidth=525&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>

      
    </div>
    
  </div>
  
    
    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2022/01/23/%E5%90%84%E7%B1%BB%E5%87%BD%E6%95%B0/">
                    各类函数
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2022/01/23/%E7%AC%94%E8%AF%95%E9%A2%98/">
                    笔试题
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#es5-%E5%92%8C-es6-%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">es5 和 es6 的继承有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6-%EF%BC%88Event-Loop%EF%BC%89"><span class="toc-text">事件循环机制 （Event Loop）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E5%A4%96%E9%83%A8%E6%A0%B7%E5%BC%8F%E8%A1%A8%E6%96%87%E4%BB%B6%E5%92%8C%E5%A4%96%E9%83%A8%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84-HTML-%E8%BD%BD%E5%85%A5%E5%92%8C%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="toc-text">包含外部样式表文件和外部脚本文件的 HTML 载入和渲染过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-text">阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="toc-text">什么是阻塞？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="toc-text">为什么会阻塞？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%8E%A8%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%88%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%89"><span class="toc-text">1、推迟加载（延迟加载）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81defer-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD"><span class="toc-text">2、defer 延迟加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD"><span class="toc-text">3、异步加载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-text">宏任务和微任务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#call-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">call 的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-call"><span class="toc-text">手写 call</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">闭包的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3"><span class="toc-text">解决</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-text">JS 的垃圾回收机制了解吗?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE"><span class="toc-text">什么是垃圾?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%9F%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%9F"><span class="toc-text">什么放在内存中？什么不放在内存中？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E6%8E%92-reflow-%E5%92%8C%E9%87%8D%E7%BB%98-repaint"><span class="toc-text">重排(reflow)和重绘(repaint)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6"><span class="toc-text">浏览器的渲染机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%B5%81-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-text">事件与事件流(浏览器事件模型)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%88Event-Delegation%EF%BC%89%EF%BC%8C%E5%8F%88%E7%A7%B0%E4%B9%8B%E4%B8%BA%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-text">事件代理（Event Delegation），又称之为事件委托</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%B4%BE"><span class="toc-text">委派</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">事件机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#new-%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">new 一个函数发生了什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%A6%81%E7%94%A8-new-%E6%9D%A5%E8%B0%83%E7%94%A8%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-text">构造函数要用 new 来调用，而不是直接调用？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">箭头函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">原型链和原型链的继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#js-%E7%BB%A7%E6%89%BF"><span class="toc-text">js 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-text">一、原型链继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%EF%BC%88%E7%BB%84%E5%90%88%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF%E5%92%8C%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%EF%BC%89%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-text">三、组合继承（组合原型链继承和借用构造函数继承）（常用）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%93%8D%E4%BD%9C%E7%BB%A7%E6%89%BF"><span class="toc-text">类操作继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-text">类继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-text">语法糖</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">TCP 的三次握手和四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">为什么要三次握手</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Vue 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">vue 生命周期的应用场景：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E9%A1%B5"><span class="toc-text">分页</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BFC-%E8%A7%84%E8%8C%83"><span class="toc-text">BFC 规范</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#let-%E5%92%8C-const"><span class="toc-text">let 和 const</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="toc-text">函数操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%87%AA%E8%BA%AB%E5%B1%9E%E6%80%A7"><span class="toc-text">获取自身属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-text">集合操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy"><span class="toc-text">Proxy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflect-%E5%AF%B9%E8%B1%A1"><span class="toc-text">Reflect 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%A4%84%EF%BC%9A"><span class="toc-text">用处：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-text">map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reduce"><span class="toc-text">reduce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#some"><span class="toc-text">some</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filter"><span class="toc-text">filter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forEach-%E5%BE%AA%E7%8E%AF%E8%BF%AD%E4%BB%A3"><span class="toc-text">forEach 循环迭代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map-%E4%B8%8E-foreach"><span class="toc-text">map 与 foreach</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakSet"><span class="toc-text">WeakSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-text">增删改查</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#json"><span class="toc-text">json</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#generator"><span class="toc-text">generator</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#generator-yield-%E6%98%AF%E5%95%A5"><span class="toc-text">generator-yield 是啥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-%E5%87%BD%E6%95%B0"><span class="toc-text">async 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#await"><span class="toc-text">await</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-async-await-%E8%AF%9E%E7%94%9F%E7%9A%84%E5%88%9D%E8%A1%B7%EF%BC%88%E6%98%AF%E8%A6%81%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%EF%BC%89"><span class="toc-text">3. async&#x2F;await 诞生的初衷（是要解决什么问题？）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%B8%AA%E4%BA%BA%E5%AF%B9-async-await-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">四、个人对 async&#x2F;await 的理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#symbol"><span class="toc-text">symbol</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES7-%E9%A2%84%E8%A7%88"><span class="toc-text">ES7 预览</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#flex"><span class="toc-text">flex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E6%96%B9%E5%BC%8F"><span class="toc-text">排列方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%8D%A2%E8%A1%8C"><span class="toc-text">控制换行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%A7%E8%BD%B4%E6%96%B9%E5%90%91%E4%B8%8A%E7%9A%84%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%EF%BC%88%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%89"><span class="toc-text">侧轴方向上的对齐方式（垂直居中）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="toc-text">子元素属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#meta"><span class="toc-text">meta</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0"><span class="toc-text">块级元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0"><span class="toc-text">行内元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#less"><span class="toc-text">less</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E5%B5%8C%E5%A5%97"><span class="toc-text">可以嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-text">可以使用变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%BD%93%E5%89%8D%E5%B1%82%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">表示当前层的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88"><span class="toc-text">混合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-text">混合函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E5%92%8C%E5%BC%95%E5%85%A5"><span class="toc-text">运算和引入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Doctype-%E4%BD%9C%E7%94%A8%EF%BC%9F%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%BC%E5%AE%B9%E6%A8%A1%E5%BC%8F%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Doctype 作用？标准模式与兼容模式各有什么区别?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML5-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E9%9C%80%E8%A6%81%E5%86%99"><span class="toc-text">HTML5 为什么只需要写</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%AF%BC%E5%85%A5%E6%A0%B7%E5%BC%8F%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8-link-%E5%92%8C-import-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">页面导入样式时，使用 link 和@import 有什么区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#xhtml"><span class="toc-text">xhtml</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">浏览器的内核分别是什么?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#html5-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">html5 新特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">语义化的理解？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML5-%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%82%A8%E5%AD%98%EF%BC%9F"><span class="toc-text">HTML5 的离线储存？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B-cookies%EF%BC%8CsessionStorage-%E5%92%8C-localStorage-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">请描述一下 cookies，sessionStorage 和 localStorage 的区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#webSocket-%E5%A6%82%E4%BD%95%E5%85%BC%E5%AE%B9%E4%BD%8E%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9F"><span class="toc-text">webSocket 如何兼容低浏览器？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#POST-%E5%92%8C-GET-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">POST 和 GET 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5-url-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">用户输入 url 到页面呈现的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%EF%BC%88CORS%EF%BC%89"><span class="toc-text">跨域（CORS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-text">3.简单请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%9D%9E%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-text">4.非简单请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F"><span class="toc-text">解决跨域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http-%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-text">http 状态码有那些？分别代表是什么意思？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#http-%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6"><span class="toc-text">http 缓存控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-text">浏览器缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E4%B8%8E-HTTPS"><span class="toc-text">HTTP 与 HTTPS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%8D%8F%E8%AE%AE-%E4%B8%8E-TCP-%E5%8D%8F%E8%AE%AE-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">HTTP 协议 与 TCP 协议 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E4%B8%AD%E4%B8%8E%E7%BC%93%E5%AD%98%E6%9C%89%E5%85%B3%E8%AF%B7%E6%B1%82%E5%A4%B4%EF%BC%8C%E5%93%8D%E5%BA%94%E5%A4%B4%E5%AD%97%E6%AE%B5"><span class="toc-text">HTTP 中与缓存有关请求头，响应头字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-2-0-%E7%9B%B8%E6%AF%94-1-0-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E5%A4%A7%E6%94%B9%E8%BF%9B%EF%BC%9F"><span class="toc-text">HTTP&#x2F;2.0 相比 1.0 有哪些重大改进？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="toc-text">优化渲染过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-%E6%96%B9%E6%B3%95"><span class="toc-text">typeof 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Null"><span class="toc-text">Null</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Undefined"><span class="toc-text">Undefined</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-%E2%80%93-gt-%E6%95%B0%E5%AD%97"><span class="toc-text">字符串 –&gt; 数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94-%E2%80%93-gt-%E6%95%B0%E5%AD%97"><span class="toc-text">布尔 –&gt; 数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null-%E2%80%93-gt-%E6%95%B0%E5%AD%97-0"><span class="toc-text">null –&gt; 数字     0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined-%E2%80%93-gt-%E6%95%B0%E5%AD%97-NaN"><span class="toc-text">undefined –&gt; 数字 NaN</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Boolean-%E5%87%BD%E6%95%B0"><span class="toc-text">使用 Boolean()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97-%E2%80%94-gt-%E5%B8%83%E5%B0%94"><span class="toc-text">数字 —&gt; 布尔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-%E2%80%94-gt-%E5%B8%83%E5%B0%94"><span class="toc-text">字符串 —&gt; 布尔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null-%E5%92%8C-undefined-%E9%83%BD%E4%BC%9A%E8%BD%AC%E6%8D%A2%E4%B8%BA-false"><span class="toc-text">null 和 undefined 都会转换为 false</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#in-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">in 运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">全局作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">函数作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#this"><span class="toc-text">this</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-text">数组方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#slice"><span class="toc-text">slice()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#splice"><span class="toc-text">splice()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concat"><span class="toc-text">concat()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-text">join()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reverse"><span class="toc-text">reverse()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort"><span class="toc-text">sort()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="toc-text">数组遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arguments"><span class="toc-text">arguments</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-1"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#length-%E5%B1%9E%E6%80%A7"><span class="toc-text">length 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#indexof"><span class="toc-text">indexof()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#substring"><span class="toc-text">substring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#split"><span class="toc-text">split</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toUpperCase"><span class="toc-text">toUpperCase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toLowerCase-%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="toc-text">toLowerCase 大小写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-%E5%92%8C-instanceof"><span class="toc-text">typeof 和 instanceof</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof"><span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof"><span class="toc-text">instanceof</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D"><span class="toc-text">拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F-ajax"><span class="toc-text">原生 ajax</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">前端有哪些页面优化方法?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">浏览器渲染的主要流程是什么?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99-JavaScript-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83%EF%BC%9F"><span class="toc-text">说几条写 JavaScript 的基本规范？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined-%E5%92%8C-null-%E5%8C%BA%E5%88%AB"><span class="toc-text">undefined 和 null 区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IE-%E4%B8%8E%E7%81%AB%E7%8B%90%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">IE 与火狐的事件机制有什么区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84-JavaScript%EF%BC%9F"><span class="toc-text">如何编写高性能的 JavaScript？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">防抖和节流的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MVC-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-text">MVC 架构模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-css-%E6%94%BE%E5%9C%A8%E9%A1%B6%E9%83%A8%E8%80%8C-js-%E5%86%99%E5%9C%A8%E5%90%8E%E9%9D%A2"><span class="toc-text">为什么 css 放在顶部而 js 写在后面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E6%8B%9F-DOM-%E4%BC%9A%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD"><span class="toc-text">为什么虚拟 DOM 会提高性能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex"><span class="toc-text">vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vuex-%E6%98%AF-vue-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E3%80%82"><span class="toc-text">vuex 是 vue 框架中状态管理。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vuex-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B1%9E%E6%80%A7"><span class="toc-text">vuex 有哪几种属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-js-%E4%B8%AD-ajax-%E8%AF%B7%E6%B1%82%E4%BB%A3%E7%A0%81%E5%BA%94%E8%AF%A5%E5%86%99%E5%9C%A8%E7%BB%84%E4%BB%B6%E7%9A%84-methods-%E4%B8%AD%E8%BF%98%E6%98%AF-vuex-%E7%9A%84-actions-%E4%B8%AD%EF%BC%9F"><span class="toc-text">Vue.js 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 actions 中？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex-%E4%B8%AD-action-%E5%92%8C-mutation-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">vuex 中 action 和 mutation 有何区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%EF%BC%9F"><span class="toc-text">什么是前端路由？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#router-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">router 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router-%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F"><span class="toc-text">vue-router 常用的路由模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86"><span class="toc-text">前端路由原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hash-%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%9B%91%E5%90%AC%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80-hash-%E5%80%BC%E5%8F%98%E5%8C%96%EF%BC%8C%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84-js-%E6%94%B9%E5%8F%98%E7%BD%91%E9%A1%B5%E5%86%85%E5%AE%B9"><span class="toc-text">hash 模式：监听浏览器地址 hash 值变化，执行相应的 js 改变网页内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#history-%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%88%A9%E7%94%A8-history-API-%E5%AE%9E%E7%8E%B0-url-%E5%9C%B0%E5%9D%80%E6%94%B9%E5%8F%98%EF%BC%8C%E7%BD%91%E9%A1%B5%E5%86%85%E5%AE%B9%E6%94%B9%E5%8F%98"><span class="toc-text">history 模式：利用 history API 实现 url 地址改变，网页内容改变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#history-%E5%92%8C-hash-%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E6%AF%94%E8%BE%83"><span class="toc-text">history 和 hash 两种模式比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#history-%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-text">history 模式的一个问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%B8%8E%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8"><span class="toc-text">二、单页应用与多页应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">computed 和 watch 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%88%AB%E7%AE%80%E8%BF%B0-computed-%E5%92%8C-watch-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">分别简述 computed 和 watch 的使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">vue 项目性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-text">是服务端渲染</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-text">Vue 响应式原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">Vue 的基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">Vue 双向绑定的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%82%B9"><span class="toc-text">vue 的两个核心点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Proxy%EF%BC%88vue3"><span class="toc-text">使用 Proxy（vue3)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-text">观察者模式原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="toc-text">路由守卫</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90"><span class="toc-text">组件内的导航钩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router-%E4%BC%A0%E5%8F%82"><span class="toc-text">vue-router 传参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E4%BC%A0%E5%80%BC"><span class="toc-text">vue 传值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex-%E6%A8%A1%E5%9D%97%E5%8C%96-module-%E7%AE%A1%E7%90%86"><span class="toc-text">vuex 模块化 module 管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%8C%87%E4%BB%A4"><span class="toc-text">常用属性和指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Proxy-%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F"><span class="toc-text">使用 Proxy 代理跨域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-keep-alive-%E4%BD%BF%E7%94%A8"><span class="toc-text">Vue keep-alive 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E4%BA%86%E4%B9%8B%E5%90%8E-vuex-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B6%88%E5%A4%B1%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-text">页面刷新了之后 vuex 中的数据消失怎么解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E5%81%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-text">vue 做服务端渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%89%B4%E6%9D%83%E4%B8%80%E8%88%AC%E6%80%9D%E8%B7%AF"><span class="toc-text">前端鉴权一般思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-text">vue 数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9B%91%E5%90%AC-Vuex-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96"><span class="toc-text">如何在组件中监听 Vuex 的数据变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%92%8C%E5%A4%9A%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Vue 单页面和多页面的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#webpack"><span class="toc-text">webpack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack-%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">webpack 打包原理是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#npm-%E6%89%93%E5%8C%85%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-webpack-%E6%9D%A5%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%9E%84%E5%BB%BA%EF%BC%9F"><span class="toc-text">npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-loader-%E4%BB%80%E4%B9%88%E6%98%AF-plugin"><span class="toc-text">什么是 loader ? 什么是 plugin ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84-Loader-%EF%BC%9F%E4%BB%96%E4%BB%AC%E6%98%AF%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="toc-text">有哪些常见的 Loader ？他们是解决什么问题的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84-Plugin%EF%BC%9F%E4%BB%96%E4%BB%AC%E6%98%AF%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="toc-text">有哪些常见的 Plugin？他们是解决什么问题的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-webpack-%E6%9D%A5%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="toc-text">如何利用 webpack 来优化前端性能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8D-bundle%EF%BC%8Cchunk%EF%BC%8Cmodule-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">分别介绍 bundle，chunk，module 是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axios-%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">axios 的封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#em-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9"><span class="toc-text">em 有什么缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%BA%A7%E7%94%9F%E6%B0%B4%E5%B9%B3%E7%A9%BA%E9%9A%99%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">行内元素产生水平空隙的原因及解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-%E8%84%9A%E6%9C%AC%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98"><span class="toc-text">JS 脚本阻塞问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%BB%96%E5%BF%85%E9%A1%BB%E5%AE%9E%E6%97%B6%E5%B1%95%E7%A4%BA%E6%9C%80%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">有一个页面，他必须实时展示最新的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-prototype-%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">为什么 prototype 判断数组类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constructor-NaN"><span class="toc-text">constructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E6%98%AF-Array-%E7%B1%BB%E5%9E%8B"><span class="toc-text">js 如何判断数组是 Array 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">清除浮动的最常用的四种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">js 对象拷贝的三种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%8D%E5%90%8C%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%97%B6%E5%90%84%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">Vue 不同页面跳转时各页面生命周期的执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MongoDB-%E5%92%8C%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">MongoDB 和关系型数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%BA%93"><span class="toc-text">前端库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-CSS-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A2%AF%E5%BD%A2"><span class="toc-text">使用 CSS 实现一个梯形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E5%A0%86"><span class="toc-text">栈与堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined-%E4%B8%8E-undeclared-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">undefined 与 undeclared 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#js-%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">js 获取原型的方法？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watch%EF%BC%8Ccomputed-%E6%80%8E%E4%B9%88%E7%9B%91%E5%90%AC%E6%B7%B1%E5%B1%82%E6%AC%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%82"><span class="toc-text">watch，computed,怎么监听深层次的对象。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-text">HTTP 请求&#x2F;响应报文结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%B7%E5%BC%8F%E5%8F%AF%E4%BB%A5%E7%BB%99%E5%AD%90%E5%85%83%E7%B4%A0%E7%BB%A7%E6%89%BF"><span class="toc-text">有哪些样式可以给子元素继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-cli-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">vue-cli 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setData-%E6%98%AF%E5%BC%82%E6%AD%A5%E8%BF%98%E6%98%AF%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-text">setData 是异步还是同步？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#xss-%E5%92%8C-csrf-%E4%BB%8B%E7%BB%8D"><span class="toc-text">xss 和 csrf 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%85%88%E6%9D%A5%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8B%E8%BF%99%E4%BA%9B%E6%8C%89%E9%92%AE"><span class="toc-text">一. 先来认识一下这些按钮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-Sources-%E8%B5%84%E6%BA%90%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95"><span class="toc-text">二.Sources 资源页面的断点调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E5%80%BC"><span class="toc-text">前后端传值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tp5-%E4%BD%BF%E7%94%A8-jwt-%E7%94%9F%E6%88%90-token-%E5%81%9A-api-%E7%9A%84%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81"><span class="toc-text">[tp5 使用 jwt 生成 token,做 api 的用户认证]</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vuex-Getters-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">vuex Getters 基本用法</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="Hide"  title="Show or Hide Table of Contents">

    <script>
        yiliaConfig.toc = ["Hide", "Show", !!"false"];
    </script>





    <div class="scroll" id="post-nav-button">
        
            <a href="/2022/01/23/%E5%90%84%E7%B1%BB%E5%87%BD%E6%95%B0/" title="Pre: 各类函数">
                <i class="iconfont icon-jiantouzuo"></i>
            </a>
        
        <a title="Mini Archives"><i class="iconfont icon-home"></i></a>
        
            <a href="/2022/01/23/%E7%AC%94%E8%AF%95%E9%A2%98/" title="Next: 笔试题">
                <i class="iconfont icon-jiantouyou"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/01/07/%E6%97%A0%E6%A0%87%E9%A2%98/">无标题</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">计算机组成思维导图</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">计算机网络思维导图</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">操作系统思维导图</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">数据结构思维导图</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/19/%E6%9C%89%E7%82%B9%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0/">有点问题学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/13/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">实用工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/13/vue%E4%BD%BF%E7%94%A8/">vue使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/13/less%E4%BD%BF%E7%94%A8/">less使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/07/vscode/">vscode</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/28/promise/">promise</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89/">算法题（重要）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89/">面试准备（重要）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E5%90%84%E7%B1%BB%E5%87%BD%E6%95%B0/">各类函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89/">个人总结（重要）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E7%AC%94%E8%AF%95%E9%A2%98/">笔试题</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E7%AC%94%E8%AE%B0/">笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/%E6%AF%94%E8%BE%83%E5%81%8F/">比较偏</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/xss%E5%92%8Ccsrf%20%E4%BB%8B%E7%BB%8D/">xss和csrf 介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/webpack/">webpack</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/vue%E7%90%86%E8%AE%BA/">vue理论</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/node/">node</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/js%E7%90%86%E8%AE%BA/">js理论</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/jS/">jS</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/jquery/">jquery</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/http/">http</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/html%E7%90%86%E8%AE%BA/">html理论</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/html-css/">html-css</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/css%E5%B8%83%E5%B1%80/">css布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/fetch%E5%92%8Caxios%E5%92%8Cneedle/">fetch和axios和needle</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/ES6/">ES6</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/DOM/">DOM</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/css%E7%90%86%E8%AE%BA/">css理论</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/css3/">css3</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/23/BOM/">BOM</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/02/npm/">npm</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/02/hexo%E4%BD%BF%E7%94%A8/">hexo使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/02/%E8%AF%AD%E9%9B%80%E4%BD%BF%E7%94%A8/">语雀使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/01/win11%E4%BD%BF%E7%94%A8/">win11使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/01/%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%20%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85/">学习内容 要做的事情</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/08/git%E4%BD%BF%E7%94%A8/">git使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">计算机操作系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%83%8C%E8%AF%B5/">操作系统背诵</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/14/%E4%BD%9C%E6%96%87%E8%8C%83%E6%96%87/">作文范文</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/14/%E4%BD%9C%E6%96%87%E6%A8%A1%E6%9D%BF/">作文模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/14/%E8%8B%B1%E8%AF%AD%E4%BD%9C%E6%96%87%E7%A7%AF%E7%B4%AF/">英语作文积累</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/16/%F0%9F%92%A1%201%20%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%AC%E8%AF%AD%E9%9B%80%E6%96%87%E6%A1%A3/">💡 1 分钟玩转语雀文档</a></li></ul>




    <script>
        ""
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="iconfont icon-copyright"></i> 
                2021-2023 John Doe
            </div>
        </div>
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="/plugins/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = "5";
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>

<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="iconfont icon-shangjiantou"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="iconfont icon-xiajiantou"></i></a>
</div>
  </div>
</body>
</html>