
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>代码运行题 | 后知后觉的个人主页</title>
        <meta name="author" content="知乐" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>后知后觉的个人主页</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;首页</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;文档中心</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;后知后觉的个人主页</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenuItems">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">首页</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">文档中心</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

            <transition name="into">
            <div id="main" v-show="!loading">
                <div class="article">
    <div>
        <h1>代码运行题</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/12
        </span>
        
        
    </div>

    <div class="content" v-pre>
        <h3 id="描述下列代码的执行结果（执行上下文）"><a href="#描述下列代码的执行结果（执行上下文）" class="headerlink" title="描述下列代码的执行结果（执行上下文）"></a>描述下列代码的执行结果（执行上下文）</h3><pre><code class="plain">foo(typeof a);
function foo(p) &#123;
    console.log(this);
    console.log(p);
    console.log(typeof b);
    let b = 0;
&#125;


typeof a 由于a没有定义 会得到undefined
</code></pre>
<p>报错，报错的位置在 console.log(typeof b);</p>
<p>报错原因：ReferenceError: Cannot access ‘b’ before initialization</p>
<h3 id="描述下列代码的执行结果（API-与类）"><a href="#描述下列代码的执行结果（API-与类）" class="headerlink" title="描述下列代码的执行结果（API 与类）"></a>描述下列代码的执行结果（API 与类）</h3><pre><code class="plain">class Foo &#123;
    constructor(arr) &#123;
        this.arr = arr;
    &#125;
    bar(n) &#123;
        return this.arr.slice(0, n);
    &#125;
&#125;
var f = new Foo([0, 1, 2, 3]);
console.log(f.bar(1));
console.log(f.bar(2).splice(1, 1));
console.log(f.arr);
</code></pre>
<p>参考答案：</p>
<p>[ 0 ]</p>
<p>[ 1 ]</p>
<p>[ 0, 1, 2, 3 ]</p>
<h3 id="描述下列代码的执行结果（运算符）"><a href="#描述下列代码的执行结果（运算符）" class="headerlink" title="描述下列代码的执行结果（运算符）"></a>描述下列代码的执行结果（运算符）</h3><pre><code class="plain">var a = 2;
var b = 5;
console.log(a === 2 || 1 &amp;&amp; b === 3 || 4);
</code></pre>
<p>true</p>
<p>考察的是逻辑运算符。在 || 里面，只要有一个为真，后面的直接短路，都不用去计算。所以 a === 2 得到 true 之后直接短路了，返回 true。</p>
<h3 id="描述下列代码的执行结果（Promise）"><a href="#描述下列代码的执行结果（Promise）" class="headerlink" title="描述下列代码的执行结果（Promise）"></a>描述下列代码的执行结果（Promise）</h3><pre><code class="plain">const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123;
    console.log(3);
    let p = new Promise((resolve, reject) =&gt; &#123;
        console.log(7);
        setTimeout(() =&gt; &#123;
            console.log(1);
        &#125;, 0);
        setTimeout(() =&gt; &#123;
            console.log(2);
            resolve(3);
        &#125;, 0)
        resolve(4);
    &#125;);
    resolve(2);
    p.then((arg) =&gt; &#123;
        console.log(arg, 5); // 1 bb
    &#125;);
    setTimeout(() =&gt; &#123;
        console.log(6);
    &#125;, 0);
&#125;))
first().then((arg) =&gt; &#123;
    console.log(arg, 7); // 2 aa
    setTimeout(() =&gt; &#123;
        console.log(8);
    &#125;, 0);
&#125;);
setTimeout(() =&gt; &#123;
    console.log(9);
&#125;, 0);
console.log(10);
</code></pre>
<p>参考答案：</p>
<p>3 7 10 4 5 2 7 1 2 6 9 8</p>
<h3 id="描述下列代码的执行结果（Promise）-1"><a href="#描述下列代码的执行结果（Promise）-1" class="headerlink" title="描述下列代码的执行结果（Promise）"></a>描述下列代码的执行结果（Promise）</h3><pre><code class="markdown">async function m1()&#123;
return 1;
&#125;

async function m2()&#123;
const n = await m1();
console.log(n)
return 2;
&#125;

async function m3()&#123;
const n = m2();
console.log(n);
return 3;
&#125;

m3().then(n=&gt;&#123;
console.log(n);
&#125;);

m3();

console.log(4);
</code></pre>
<p>参考答案：</p>
<p><img src="1726111532395-a5e62339-ac18-4d77-9ce9-a0abbc33c111.png"></p>
<h3 id="描述下列代码的执行结果（Promise）-2"><a href="#描述下列代码的执行结果（Promise）-2" class="headerlink" title="描述下列代码的执行结果（Promise）"></a>描述下列代码的执行结果（Promise）</h3><pre><code class="markdown">Promise.resolve(1)
.then(2)
.then(Promise.resolve(3))
.then(console.log)
</code></pre>
<p>参考答案：1</p>
<h3 id="描述下列代码的执行结果（Promise）-3"><a href="#描述下列代码的执行结果（Promise）-3" class="headerlink" title="描述下列代码的执行结果（Promise）"></a>描述下列代码的执行结果（Promise）</h3><pre><code class="javascript">new Promise((resolve, reject) =&gt; &#123;
  reject(1);
  console.log(2);
  resolve(3);
  console.log(4);
&#125;)
  .then((res) =&gt; &#123;
    console.log(res);
  &#125;)
  .catch((res) =&gt; &#123;
    console.log(&quot;reject1&quot;);
  &#125;);

try &#123;
  new Promise((resolve, reject) =&gt; &#123;
    throw &quot;error&quot;;
  &#125;)
    .then((res) =&gt; &#123;
      console.log(res);
    &#125;)
    .catch((res) =&gt; &#123;
      console.log(&quot;reject2&quot;);
    &#125;);
&#125; catch (err) &#123;
  console.log(err);
&#125;
</code></pre>
<p>参考答案：</p>
<p>2 4 reject1 reject2</p>
<h3 id="‘1’-‘2’-‘3’-map-parseInt-结果是什么，为什么"><a href="#‘1’-‘2’-‘3’-map-parseInt-结果是什么，为什么" class="headerlink" title="[‘1’, ‘2’, ‘3’].map(parseInt) 结果是什么，为什么"></a>[‘1’, ‘2’, ‘3’].map(parseInt) 结果是什么，为什么</h3><p>[1, NaN, NaN]</p>
<p>解析：</p>
<p>一、为什么会是这个结果？</p>
<ol>
<li>map 函数</li>
</ol>
<p>将数组的每个元素传递给指定的函数处理，并返回处理后的数组，所以 [‘1’,’2’,’3’].map(parseInt) 就是将字符串 1，2，3 作为元素；0，1，2 作为下标分别调用 parseInt 函数。即分别求出 parseInt(‘1’,0), parseInt(‘2’,1), parseInt(‘3’,2) 的结果。</p>
<ol>
<li>parseInt 函数（重点）</li>
</ol>
<p>概念：以第二个参数为基数来解析第一个参数字符串，通常用来做十进制的向上取整（省略小数）如：parseInt(2.7) //结果为 2</p>
<p>特点：接收两个参数 parseInt(string,radix)</p>
<p>string：字母（大小写均可）、数组、特殊字符（不可放在开头,特殊字符及特殊字符后面的内容不做解析）的任意字符串，如 ‘2’、’2w’、’2!’</p>
<p>radix：解析字符串的基数，基数规则如下：</p>
<p>1） 区间范围介于 2~36 之间；</p>
<p>2 ） 当参数为 0，parseInt( ) 会根据十进制来解析；</p>
<p>3 ） 如果忽略该参数，默认的基数规则：</p>
<p>如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数；</p>
<p>parseInt(“0xf”) // 15</p>
<p>如果 string 以 0 开头，其后的字符解析为八进制或十六进制的数字；</p>
<p>parseInt(“08”) // 8</p>
<p>如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数；</p>
<p>parseInt(“88.99f”) // 88</p>
<p>只有字符串中的第一个数字会被返回。</p>
<p>parseInt(“10.33”) // 返回 10；</p>
<p>开头和结尾的空格是允许的。</p>
<p>parseInt(“ 69 10 “) // 返回 69</p>
<p>如果字符串的第一个字符不能被转换为数字，返回 NaN。</p>
<p>parseInt(“f”) // 返回 NaN</p>
<p>parseInt(“f”，16) // 返回 15</p>
<p>二、parseInt 方法解析的运算过程</p>
<p>parseInt(‘101.55’,10); // 以十进制解析，运算过程：向上取整数(不做四舍五入，省略小数)，结果为 101。</p>
<p>parseInt(‘101’,2); // 以二进制解析，运算过程：12 的 2 次方+02 的 1 次方+1*2 的 0 次方=4+0+1=5，结果为 5。</p>
<p>parseInt(‘101’,8); // 以八进制解析，运算过程：18 的 2 次方+08 的 1 次方+1*8 的 0 次方=64+0+1=65，结果为 65。</p>
<p>parseInt(‘101’,16); // 以十六进制解析，运算过程：116 的 2 次方+016 的 1 次方+1*16 的 0 次方=256+0+1=257，结果为 257。</p>
<p>三、再来分析一下结果</p>
<p>[‘1’,’2’,’3’].map(parseInt) 即</p>
<p>parseInt(‘1’,0); radix 为 0，parseInt( ) 会根据十进制来解析，所以结果为 1；</p>
<p>parseInt(‘2’,1); radix 为 1，超出区间范围，所以结果为 NaN；</p>
<p>parseInt(‘3’,2); radix 为 2，用 2 进制来解析，应以 0 和 1 开头，所以结果为 NaN。</p>
<h3 id="描述下列代码的执行结果（执行上下文）-1"><a href="#描述下列代码的执行结果（执行上下文）-1" class="headerlink" title="描述下列代码的执行结果（执行上下文）"></a>描述下列代码的执行结果（执行上下文）</h3><pre><code class="javascript">alert(a);
a();
var a = 3;
function a() &#123;
  alert(10);
&#125;
alert(a);
a = 6;
a();
</code></pre>
<p>首先打印 function a() {alert(10);};</p>
<p>然后打印 10</p>
<p>最后打印 3</p>
<p>解析：</p>
<p>首先 a 变量会被提升到该全局作用域的最顶端，然后值为对应的函数，所以第一次打印出来的是函数。</p>
<p>接下来调用这个 a 函数，所以打印出 10</p>
<p>最后给这个 a 赋值为 3，然后又 alert，所以打印出 3。</p>
<p>之后 a 的值还会发生改变，但是由于没有 alert，说明不会再打印出其他值了。</p>
<h3 id="描述下列代码的执行结果（Promise）-4"><a href="#描述下列代码的执行结果（Promise）-4" class="headerlink" title="描述下列代码的执行结果（Promise）"></a>描述下列代码的执行结果（Promise）</h3><pre><code class="javascript">setTimeout(function () &#123;
  console.log(&quot;set1&quot;);
  new Promise(function (resolve) &#123;
    resolve();
  &#125;).then(function () &#123;
    new Promise(function (resolve) &#123;
      resolve();
    &#125;).then(function () &#123;
      console.log(&quot;then4&quot;);
    &#125;);
    console.log(&quot;then2&quot;);
  &#125;);
&#125;);
new Promise(function (resolve) &#123;
  console.log(&quot;pr1&quot;);
  resolve();
&#125;).then(function () &#123;
  console.log(&quot;then1&quot;);
&#125;);

setTimeout(function () &#123;
  console.log(&quot;set2&quot;);
&#125;);
console.log(2);

new Promise(function (resolve) &#123;
  resolve();
&#125;).then(function () &#123;
  console.log(&quot;then3&quot;);
&#125;);
</code></pre>
<p>参考答案：</p>
<p>打印结果为：</p>
<p>pr1 2 then1 then3 set1 then2 then4 set2</p>
<h3 id="下列代码的执行结果-（Promise-async）"><a href="#下列代码的执行结果-（Promise-async）" class="headerlink" title="下列代码的执行结果 （Promise async）"></a>下列代码的执行结果 （Promise async）</h3><pre><code class="javascript">async function async1() &#123;
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
&#125;
async function async2() &#123;
  console.log(&quot;async2&quot;);
&#125;
console.log(&quot;script start&quot;);
setTimeout(function () &#123;
  console.log(&quot;setTimeout&quot;);
&#125;, 0);
async1();
new Promise(function (resolve) &#123;
  console.log(&quot;promise1&quot;);
  resolve();
&#125;).then(function () &#123;
  console.log(&quot;promise2&quot;);
&#125;);
console.log(&quot;script end&quot;);
</code></pre>
<p>参考答案：</p>
<p>script start，async1 start，async2，promise1，script end，async1 end，promise2，setTimeout</p>
<p>解析：</p>
<p>在此之前我们需要知道以下几点：</p>
<ul>
<li>setTimeout 属于宏任务</li>
<li>Promise 本身是同步的立即执行函数，Promise.then 属于微任务</li>
<li>async 方法执行时，遇到 await 会立即执行表达式，表达式之后的代码放到微任务执行</li>
</ul>
<p><strong>第一次执行</strong>：执行同步代码</p>
<pre><code class="plain">Tasks(宏任务)：run script、 setTimeout callback
Microtasks(微任务)：await、Promise then
JS stack(执行栈): script
Log: script start、async1 start、async2、promise1、script end
</code></pre>
<p><strong>第二次执行</strong>：执行宏任务后，检测到<strong>微任务</strong>队列中不为空、一次性执行完所有微任务</p>
<pre><code class="plain">Tasks(宏任务)：run script、 setTimeout callback
Microtasks(微任务)：Promise then
JS stack(执行栈): await
Log: script start、async1 start、async2、promise1、script end、async1 end、promise2
</code></pre>
<p><strong>第三次执行</strong>：当<strong>微任务</strong>队列中为空时，执行<strong>宏任务</strong>，执行 setTimeout callback，打印日志。</p>
<pre><code class="plain">Tasks(宏任务)：null
Microtasks(微任务)：null
JS stack(执行栈):setTimeout callback
Log: script start、async1 start、async2、promise1、script end、async1 end、promise2、setTimeout
</code></pre>
<h3 id="下面代码的输出是什么？（-D-）"><a href="#下面代码的输出是什么？（-D-）" class="headerlink" title="下面代码的输出是什么？（ D ）"></a>下面代码的输出是什么？（ D ）</h3><pre><code class="javascript">function sayHi() &#123;
  console.log(name);
  console.log(age);
  var name = &quot;Lydia&quot;;
  let age = 21;
&#125;

sayHi();
</code></pre>
<ul>
<li>A: Lydia 和 undefined</li>
<li>B: Lydia 和 ReferenceError</li>
<li>C: ReferenceError 和 21</li>
<li>D: undefined 和 ReferenceError</li>
</ul>
<p><strong>分析：</strong></p>
<p>在 sayHi 函数内部，通过 var 声明的变量 name 会发生变量提升，var name 会提升到函数作用域的顶部，其默认值为 undefined*。因此输出 *name 时得到的值为 undefined；</p>
<p>let 声明的 age 不会发生变量提升，在输出 age 时该变量还未声明，因此会抛出 ReferenceError 的报错。</p>
<h3 id="下面代码的输出是什么？（-C-）"><a href="#下面代码的输出是什么？（-C-）" class="headerlink" title="下面代码的输出是什么？（ C ）"></a>下面代码的输出是什么？（ C ）</h3><pre><code class="javascript">for (var i = 0; i &lt; 3; i++) &#123;
  setTimeout(() =&gt; console.log(i), 1);
&#125;

for (let i = 0; i &lt; 3; i++) &#123;
  setTimeout(() =&gt; console.log(i), 1);
&#125;
</code></pre>
<ul>
<li>A: 0 1 2 和 0 1 2</li>
<li>B: 0 1 2 和 3 3 3</li>
<li>C: 3 3 3 和 0 1 2</li>
</ul>
<p>分析：</p>
<p>JavaScript 中的执行机制，setTimeout 为异步代码，因此在 setTimeout 执行时，for 循环已经执行完毕。</p>
<p>第一个 for 循环中的变量 i 通过 var 声明， 为全局变量，因此每一次的 i++ 都会将全局变量 i 的值加 1，当第一个 for 执行完成后 i 的值为 3。所以再执行 setTimeout 时，输出 i 的值都为 3；</p>
<p>第二个 for 循环中的变量 i 通过 let 声明，为局部变量，因此每一次 for 循环时都会产生一个块级作用域，用来存储本次循环中新产生的 i 的值。当循环结束后，setTimeout 会沿着作用域链去对应的块级作用域中寻找对应的 i 值。</p>
<h3 id="下面代码的输出是什么？（-B-）"><a href="#下面代码的输出是什么？（-B-）" class="headerlink" title="下面代码的输出是什么？（ B ）"></a>下面代码的输出是什么？（ B ）</h3><pre><code class="javascript">const shape = &#123;
  radius: 10,
  diameter() &#123;
    return this.radius * 2;
  &#125;,
  perimeter: () =&gt; 2 * Math.PI * this.radius,
&#125;;

shape.diameter();
shape.perimeter();
</code></pre>
<ul>
<li>A: 20 和 62.83185307179586</li>
<li>B: 20 和 NaN</li>
<li>C: 20 和 63</li>
<li>D: NaN 和 63</li>
</ul>
<p><strong>分析：</strong></p>
<p>diameter 作为对象的方法，其内部的 this 指向调用该方法的对象，因此 this.raduus 获取到的是 shape.radius 的值 10，再乘以 2 输出的值即为 20；</p>
<p>perimeter 是一个箭头函数，其内部的 this 应该继承声明时所在上下文中的 this，在这里即继承全局的 this，因此 this.radius 值的为 undefined，undefined 与数值相乘后值为 NaN。</p>
<h3 id="下面代码的输出是什么？（-A-）"><a href="#下面代码的输出是什么？（-A-）" class="headerlink" title="下面代码的输出是什么？（ A ）"></a>下面代码的输出是什么？（ A ）</h3><pre><code class="plain">+true;
!&quot;Lydia&quot;;
</code></pre>
<ul>
<li>A: 1 和 false</li>
<li>B: false 和 NaN</li>
<li>C: false 和 false</li>
</ul>
<p><strong>分析：</strong></p>
<p>一元加号会将数据隐式转换为 number 类型，true 转换为数值为 1；</p>
<p>非运算符 ! 会将数据隐式转换为 boolean 类型后进行取反，_”Lydia”_ 转换为布尔值为 true，取反后为 false。</p>
<h3 id="哪个选项是不正确的？（-A-）"><a href="#哪个选项是不正确的？（-A-）" class="headerlink" title="哪个选项是不正确的？（ A ）"></a>哪个选项是不正确的？（ A ）</h3><pre><code class="javascript">const bird = &#123;
  size: &quot;small&quot;,
&#125;;

const mouse = &#123;
  name: &quot;Mickey&quot;,
  small: true,
&#125;;
</code></pre>
<ul>
<li>A: mouse.bird.size</li>
<li>B: mouse[bird.size]</li>
<li>C: mouse[bird[“size”]]</li>
<li>D: 以上选项都对</li>
</ul>
<p><strong>分析：</strong></p>
<p>mouse 对象中没有 bird 属性，当访问一个对象不存在的属性时值为 undefined*，因此 <em>mouse.bird 的值为 undefined</em>，而 *undefined 作为原始数据类型没有 size 属性，因此再访问 undefined.size 时会报错。</p>
<h3 id="下面代码的输出是什么？（-A-）-1"><a href="#下面代码的输出是什么？（-A-）-1" class="headerlink" title="下面代码的输出是什么？（ A ）"></a>下面代码的输出是什么？（ A ）</h3><pre><code class="javascript">let c = &#123; greeting: &quot;Hey!&quot; &#125;;
let d;

d = c;
c.greeting = &quot;Hello&quot;;
console.log(d.greeting);
</code></pre>
<ul>
<li>A: Hello</li>
<li>B: undefined</li>
<li>C: ReferenceError</li>
<li>D: TypeError</li>
</ul>
<p><strong>分析：</strong></p>
<p>在 JavaScript 中，复杂类型数据在进行赋值操作时，进行的是「引用传递」，因此变量 d 和 c 指向的是同一个引用。当 c 通过引用去修改了数据后，d 再通过引用去访问数据，获取到的实际就是 c 修改后的数据。</p>
<h3 id="下面代码的输出是什么？（-C-）-1"><a href="#下面代码的输出是什么？（-C-）-1" class="headerlink" title="下面代码的输出是什么？（ C ）"></a>下面代码的输出是什么？（ C ）</h3><pre><code class="plain">let a = 3;
let b = new Number(3);
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
</code></pre>
<ul>
<li>A: true false true</li>
<li>B: false false true</li>
<li>C: true false false</li>
<li>D: false true true</li>
</ul>
<p><strong>分析：</strong></p>
<p>new Number() 是 JavaScript 中一个内置的构造函数。变量 b 虽然看起来像一个数字，但它并不是一个真正的数字：它有一堆额外的功能，是一个对象。</p>
<p>== 会触发隐式类型转换，右侧的对象类型会自动转换为 Number 类型，因此最终返回 true。</p>
<p>=== 不会触发隐式类型转换，因此在比较时由于数据类型不相等而返回 false。</p>
<h3 id="下面代码的输出是什么？（-D-）-1"><a href="#下面代码的输出是什么？（-D-）-1" class="headerlink" title="下面代码的输出是什么？（ D ）"></a>下面代码的输出是什么？（ D ）</h3><pre><code class="plain">class Chameleon &#123;
  static colorChange(newColor) &#123;
    this.newColor = newColor;
  &#125;

  constructor(&#123; newColor = &quot;green&quot; &#125; = &#123;&#125;) &#123;
    this.newColor = newColor;
  &#125;
&#125;

const freddie = new Chameleon(&#123; newColor: &quot;purple&quot; &#125;);
freddie.colorChange(&quot;orange&quot;);
</code></pre>
<ul>
<li>A: orange</li>
<li>B: purple</li>
<li>C: green</li>
<li>D: TypeError</li>
</ul>
<p><strong>分析</strong>：</p>
<p>colorChange 方法是静态的。 静态方法仅在创建它们的构造函数中存在，并且不能传递给任何子级。 由于 freddie 是一个子级对象，函数不会传递，所以在 freddie 实例上不存在 colorChange 方法：抛出 TypeError。</p>
<h3 id="下面代码的输出是什么？（-A-）-2"><a href="#下面代码的输出是什么？（-A-）-2" class="headerlink" title="下面代码的输出是什么？（ A ）"></a>下面代码的输出是什么？（ A ）</h3><pre><code class="plain">let greeting;
greetign = &#123;&#125;; // Typo!
console.log(greetign);
</code></pre>
<ul>
<li>A: {}</li>
<li>B: ReferenceError: greetign is not defined</li>
<li>C: undefined</li>
</ul>
<p><strong>分析：</strong></p>
<p>控制台会输出空对象，因为我们刚刚在全局对象上创建了一个空对象！</p>
<p>当我们错误地将 greeting 输入为 greetign 时，JS 解释器实际上在浏览器中将其视为 window.greetign = {}。</p>
<h3 id="当我们执行以下代码时会发生什么？（-A-）"><a href="#当我们执行以下代码时会发生什么？（-A-）" class="headerlink" title="当我们执行以下代码时会发生什么？（ A ）"></a>当我们执行以下代码时会发生什么？（ A ）</h3><pre><code class="plain">function bark() &#123;
  console.log(&quot;Woof!&quot;);
&#125;

bark.animal = &quot;dog&quot;;
</code></pre>
<ul>
<li>A 什么都不会发生</li>
<li>B: SyntaxError. You cannot add properties to a function this way.</li>
<li>C: undefined</li>
<li>D: ReferenceError<strong>分析：</strong>因为函数也是对象！（原始类型之外的所有东西都是对象）函数是一种特殊类型的对象，我们可以给函数添加属性，且此属性是可调用的。</li>
</ul>
<h3 id="下面代码的输出是什么？（-A-）-3"><a href="#下面代码的输出是什么？（-A-）-3" class="headerlink" title="下面代码的输出是什么？（ A ）"></a>下面代码的输出是什么？（ A ）</h3><pre><code class="plain">function Person(firstName, lastName) &#123;
  this.firstName = firstName;
  this.lastName = lastName;
&#125;

const member = new Person(&quot;Lydia&quot;, &quot;Hallie&quot;);
Person.getFullName = () =&gt; this.firstName + this.lastName;

console.log(member.getFullName());
</code></pre>
<ul>
<li>A: TypeError</li>
<li>B: SyntaxError</li>
<li>C: Lydia Hallie</li>
<li>D: undefined undefined</li>
</ul>
<p><strong>分析：</strong></p>
<p>Person.getFullName 是将方法添加到了函数身上，因此当我们通过实例对象 member 去调用该方法时并不能找到该方法。</p>
<h3 id="下面代码的输出是什么？（-A-）-4"><a href="#下面代码的输出是什么？（-A-）-4" class="headerlink" title="下面代码的输出是什么？（ A ）"></a>下面代码的输出是什么？（ A ）</h3><pre><code class="plain">function Person(firstName, lastName) &#123;
  this.firstName = firstName;
  this.lastName = lastName;
&#125;

const lydia = new Person(&quot;Lydia&quot;, &quot;Hallie&quot;);
const sarah = Person(&quot;Sarah&quot;, &quot;Smith&quot;);

console.log(lydia);
console.log(sarah);
</code></pre>
<ul>
<li>A: Person { firstName: “Lydia”, lastName: “Hallie” } 和 undefined</li>
<li>B: Person { firstName: “Lydia”, lastName: “Hallie” } 和 Person { firstName: “Sarah”, lastName: “Smith” }</li>
<li>C: Person { firstName: “Lydia”, lastName: “Hallie” } 和 {}</li>
<li>D: Person { firstName: “Lydia”, lastName: “Hallie” } 和 ReferenceError</li>
</ul>
<p><strong>分析：</strong></p>
<p>lydia 是调用构造函数后得到的实例对象，拥有 firstName 和 lastName 属性；</p>
<p>sarah 是调用普通函数后得到的返回值，而 Person 作为普通函数没有返回值；</p>
<h3 id="事件传播的三个阶段是什么？（-D-）"><a href="#事件传播的三个阶段是什么？（-D-）" class="headerlink" title="事件传播的三个阶段是什么？（ D ）"></a>事件传播的三个阶段是什么？（ D ）</h3><ul>
<li>A: 目标 &gt; 捕获 &gt; 冒泡</li>
<li>B: 冒泡 &gt; 目标 &gt; 捕获</li>
<li>C: 目标 &gt; 冒泡 &gt; 捕获</li>
<li>D: 捕获 &gt; 目标 &gt; 冒泡</li>
</ul>
<h3 id="下面代码的输出是什么？（-C-）-2"><a href="#下面代码的输出是什么？（-C-）-2" class="headerlink" title="下面代码的输出是什么？（ C ）"></a>下面代码的输出是什么？（ C ）</h3><pre><code class="plain">function sum(a, b) &#123;
  return a + b;
&#125;

sum(1, &quot;2&quot;);
</code></pre>
<ul>
<li>A: NaN</li>
<li>B: TypeError</li>
<li>C: <em>“12”</em></li>
<li>D: 3</li>
</ul>
<p><strong>分析：</strong></p>
<p>任意数据类型在跟 String 做 + 运算时，都会隐式转换为 String 类型。</p>
<p>即 a 所对应的 Number 值 1，被隐式转换为了 String 值 “1”，最终字符串拼接的到 “12”。</p>
<h3 id="下面代码的输出是什么？（-C-）-3"><a href="#下面代码的输出是什么？（-C-）-3" class="headerlink" title="下面代码的输出是什么？（ C ）"></a>下面代码的输出是什么？（ C ）</h3><pre><code class="plain">let number = 0;
console.log(number++);
console.log(++number);
console.log(number);
</code></pre>
<ul>
<li>A: 1 1 2</li>
<li>B: 1 2 2</li>
<li>C: 0 2 2</li>
<li>D: 0 1 2</li>
</ul>
<p><strong>分析：</strong></p>
<p>++ 后置时，先输出，后加 1；++ 前置时，先加 1，后输出；</p>
<p>第一次输出的值为 0，输出完成后 number 加 1 变为 1。</p>
<p>第二次输出，number 先加 1 变为 2，然后输出值 2。</p>
<p>第三次输出，number 值没有变化，还是 2。</p>
<h3 id="下面代码的输出是什么？（-B-）-1"><a href="#下面代码的输出是什么？（-B-）-1" class="headerlink" title="下面代码的输出是什么？（ B ）"></a>下面代码的输出是什么？（ B ）</h3><pre><code class="plain">function getPersonInfo(one, two, three) &#123;
  console.log(one);
  console.log(two);
  console.log(three);
&#125;

const person = &quot;Lydia&quot;;
const age = 21;

getPersonInfo`$&#123;person&#125; is $&#123;age&#125; years old`;
</code></pre>
<ul>
<li>A: Lydia21[“”, “is”, “years old”]</li>
<li>B: [“”, “is”, “years old”]Lydia21</li>
<li>C: Lydia[“”, “is”, “years old”]21</li>
</ul>
<p><strong>分析：</strong></p>
<p>如果使用标记的模板字符串，则第一个参数的值始终是字符串值的数组。 其余参数获取传递到模板字符串中的表达式的值！</p>
<h3 id="下面代码的输出是什么？（-C-）-4"><a href="#下面代码的输出是什么？（-C-）-4" class="headerlink" title="下面代码的输出是什么？（ C ）"></a>下面代码的输出是什么？（ C ）</h3><pre><code class="plain">function checkAge(data) &#123;
  if (data === &#123; age: 18 &#125;) &#123;
    console.log(&quot;You are an adult!&quot;);
  &#125; else if (data == &#123; age: 18 &#125;) &#123;
    console.log(&quot;You are still an adult.&quot;);
  &#125; else &#123;
    console.log(`Hmm.. You don&#39;t have an age I guess`);
  &#125;
&#125;

checkAge(&#123; age: 18 &#125;);
</code></pre>
<ul>
<li>A: You are an adult!</li>
<li>B: You are still an adult.</li>
<li>C: Hmm.. You don’t have an age I guess</li>
</ul>
<p><strong>分析：</strong></p>
<p>在比较相等性时，原始类型通过它们的值进行比较，而对象通过它们的引用进行比较。</p>
<p>data 和条件中的 { age: 18 } 两个不同引用的对象，因此永远都不相等。</p>
<h3 id="下面代码的输出是什么？（-C-）-5"><a href="#下面代码的输出是什么？（-C-）-5" class="headerlink" title="下面代码的输出是什么？（ C ）"></a>下面代码的输出是什么？（ C ）</h3><pre><code class="plain">function getAge(...args) &#123;
  console.log(typeof args);
&#125;

getAge(21);
</code></pre>
<ul>
<li>A: <em>“number”</em></li>
<li>B: <em>“array”</em></li>
<li>C: <em>“object”</em></li>
<li>D: <em>“NaN”</em></li>
</ul>
<p><strong>分析：</strong></p>
<p>ES6 中的不定参数（…args）返回的是一个数组。</p>
<p>typeof 检查数组的类型返回的值是 object。</p>
<h3 id="下面代码的输出是什么？（-C-）-6"><a href="#下面代码的输出是什么？（-C-）-6" class="headerlink" title="下面代码的输出是什么？（ C ）"></a>下面代码的输出是什么？（ C ）</h3><pre><code class="plain">function getAge() &#123;
  &quot;use strict&quot;;
  age = 21;
  console.log(age);
&#125;

getAge();
</code></pre>
<ul>
<li>A: 21</li>
<li>B: undefined</li>
<li>C: ReferenceError</li>
<li>D: TypeError</li>
</ul>
<p><strong>分析：</strong></p>
<p><em>“use strict”</em> 严格模式中，使用未声明的变量会引发报错。</p>
<h3 id="下面代码的输出是什么？（-A-）-5"><a href="#下面代码的输出是什么？（-A-）-5" class="headerlink" title="下面代码的输出是什么？（ A ）"></a>下面代码的输出是什么？（ A ）</h3><pre><code class="plain">const sum = eval(&quot;10*10+5&quot;);
</code></pre>
<ul>
<li>A: 105</li>
<li>B: <em>“105”</em></li>
<li>C: TypeError</li>
<li>D: <em>“10</em>10+5”*</li>
</ul>
<p><strong>分析：</strong></p>
<p>eval 方法会将字符串当作 JavaScript 代码进行解析。</p>
<h3 id="下面代码的输出是什么？（-B-）-2"><a href="#下面代码的输出是什么？（-B-）-2" class="headerlink" title="下面代码的输出是什么？（ B ）"></a>下面代码的输出是什么？（ B ）</h3><pre><code class="plain">var num = 8;
var num = 10;

console.log(num);
</code></pre>
<ul>
<li>A: 8</li>
<li>B: 10</li>
<li>C: SyntaxError</li>
<li>D: ReferenceError</li>
</ul>
<p><strong>分析：</strong></p>
<p>var 声明的变量允许重复声明，但后面的值会覆盖前面的值。</p>
<h3 id="下面代码的输出是什么？（-C-）-7"><a href="#下面代码的输出是什么？（-C-）-7" class="headerlink" title="下面代码的输出是什么？（ C ）"></a>下面代码的输出是什么？（ C ）</h3><pre><code class="plain">const obj = &#123; 1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot; &#125;;
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty(&quot;1&quot;);
obj.hasOwnProperty(1);
set.has(&quot;1&quot;);
set.has(1);
</code></pre>
<ul>
<li>A: falsetruefalsetrue</li>
<li>B: falsetruetruetrue</li>
<li>C: truetruefalsetrue</li>
<li>D: truetruetruetrue</li>
</ul>
<h3 id="下面代码的输出是什么？（-C-）-8"><a href="#下面代码的输出是什么？（-C-）-8" class="headerlink" title="下面代码的输出是什么？（ C ）"></a>下面代码的输出是什么？（ C ）</h3><pre><code class="plain">const obj = &#123; a: &quot;one&quot;, b: &quot;two&quot;, a: &quot;three&quot; &#125;;
console.log(obj);
</code></pre>
<ul>
<li>A: { a: “one”, b: “two” }</li>
<li>B: { b: “two”, a: “three” }</li>
<li>C: { a: “three”, b: “two” }</li>
<li>D: SyntaxError</li>
</ul>
<p><strong>分析：</strong></p>
<p>如果对象有两个具有相同名称的键，则后面的将替前面的键。它仍将处于第一个位置，但具有最后指定的值。</p>
<h3 id="下面代码的输出是什么？（-C-）-9"><a href="#下面代码的输出是什么？（-C-）-9" class="headerlink" title="下面代码的输出是什么？（ C ）"></a>下面代码的输出是什么？（ C ）</h3><pre><code class="plain">for (let i = 1; i &lt; 5; i++) &#123;
  if (i === 3) continue;
  console.log(i);
&#125;
</code></pre>
<ul>
<li>A: 1 2</li>
<li>B: 1 2 3</li>
<li>C: 1 2 4</li>
<li>D: 1 3 4</li>
</ul>
<p><strong>分析：</strong></p>
<p>当 i 的值为 3 时，进入 if 语句执行 continue，结束本次循环，立即进行下一次循环。</p>
<h3 id="下面代码的输出是什么？（-A-）-6"><a href="#下面代码的输出是什么？（-A-）-6" class="headerlink" title="下面代码的输出是什么？（ A ）"></a>下面代码的输出是什么？（ A ）</h3><pre><code class="plain">String.prototype.giveLydiaPizza = () =&gt; &#123;
  return &quot;Just give Lydia pizza already!&quot;;
&#125;;

const name = &quot;Lydia&quot;;

name.giveLydiaPizza();
</code></pre>
<ul>
<li>A: <em>“Just give Lydia pizza already!”</em></li>
<li>B: TypeError: not a function</li>
<li>C: SyntaxError</li>
<li>D: undefined</li>
</ul>
<p><strong>分析：</strong></p>
<p>String 是一个内置的构造函数，我们可以为它添加属性。 我们给它的原型添加了一个方法。 原始类型的字符串自动转换为字符串对象，由字符串原型函数生成。 因此，所有字符串（字符串对象）都可以访问该方法！</p>
<p>当使用基本类型的字符串调用 giveLydiaPizza 时，实际上发生了下面的过程：</p>
<ul>
<li>创建一个 String 的包装类型实例</li>
<li>在实例上调用 substring 方法</li>
<li>销毁实例</li>
</ul>
<h3 id="下面代码的输出是什么？（-B-）-3"><a href="#下面代码的输出是什么？（-B-）-3" class="headerlink" title="下面代码的输出是什么？（ B ）"></a>下面代码的输出是什么？（ B ）</h3><pre><code class="plain">const a = &#123;&#125;;
const b = &#123; key: &quot;b&quot; &#125;;
const c = &#123; key: &quot;c&quot; &#125;;

a[b] = 123;
a[c] = 456;

console.log(a[b]);
</code></pre>
<ul>
<li>A: 123</li>
<li>B: 456</li>
<li>C: undefined</li>
<li>D: ReferenceError</li>
</ul>
<p><strong>分析：</strong></p>
<p>当 b 和 c 作为一个对象的键时，会自动转换为字符串，而对象自动转换为字符串化时，结果都为 [Object object]*。因此 *a[b] 和 a[c] 其实都是同一个属性 a[“Object object”]。</p>
<p>对象同名的属性后面的值会覆盖前面的，因此最终 a[“Object object”] 的值为 456。</p>
<h3 id="下面代码的输出是什么？（-B-）-4"><a href="#下面代码的输出是什么？（-B-）-4" class="headerlink" title="下面代码的输出是什么？（ B ）"></a>下面代码的输出是什么？（ B ）</h3><pre><code class="plain">const foo = () =&gt; console.log(&quot;First&quot;);
const bar = () =&gt; setTimeout(() =&gt; console.log(&quot;Second&quot;));
const baz = () =&gt; console.log(&quot;Third&quot;);

bar();
foo();
baz();
</code></pre>
<ul>
<li>A: First Second Third</li>
<li>B: First Third Second</li>
<li>C: Second First Third</li>
<li>D: Second Third First</li>
</ul>
<p><strong>分析：</strong></p>
<p>bar 函数中执行的是一段异步代码，按照 JavaScript 中的事件循环机制，主线程中的所有同步代码执行完成后才会执行异步代码。因此 <em>“Second”</em> 最后输出。</p>
<h3 id="单击按钮时-event-target-是什么？（-C-）"><a href="#单击按钮时-event-target-是什么？（-C-）" class="headerlink" title="单击按钮时 event.target 是什么？（ C ）"></a>单击按钮时 event.target 是什么？（ C ）</h3><pre><code class="html">&lt;div onclick=&quot;console.log(&#39;first div&#39;)&quot;&gt;
  &lt;div onclick=&quot;console.log(&#39;second div&#39;)&quot;&gt;
    &lt;button onclick=&quot;console.log(&#39;button&#39;)&quot;&gt;Click!&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<ul>
<li>A: div 外部</li>
<li>B: div 内部</li>
<li>C: button</li>
<li>D: 所有嵌套元素的数组</li>
</ul>
<p><strong>分析：</strong></p>
<p>event.target 指向的是事件目标，即触发事件的元素。因此点击 <button> 触发事件的也就是 <button>。</p>
<h3 id="单击下面的-html-片段打印的内容是什么？（-A-）"><a href="#单击下面的-html-片段打印的内容是什么？（-A-）" class="headerlink" title="单击下面的 html 片段打印的内容是什么？（ A ）"></a>单击下面的 html 片段打印的内容是什么？（ A ）</h3><pre><code class="html">&lt;div onclick=&quot;console.log(&#39;div&#39;)&quot;&gt;
  &lt;p onclick=&quot;console.log(&#39;p&#39;)&quot;&gt;Click here!&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<ul>
<li>A: pdiv</li>
<li>B: divp</li>
<li>C: p</li>
<li>D: div</li>
</ul>
<p><strong>分析：</strong></p>
<p>onclick 绑定的事件为冒泡型事件。因此当点击 p 标签时，事件会从事件目标开始依次往外触发。</p>
<h3 id="下面代码的输出是什么？（-D-）-2"><a href="#下面代码的输出是什么？（-D-）-2" class="headerlink" title="下面代码的输出是什么？（ D ）"></a>下面代码的输出是什么？（ D ）</h3><pre><code class="plain">const person = &#123; name: &quot;Lydia&quot; &#125;;

function sayHi(age) &#123;
  console.log(`$&#123;this.name&#125; is $&#123;age&#125;`);
&#125;

sayHi.call(person, 21);
sayHi.bind(person, 21);
</code></pre>
<ul>
<li>A: undefined is 21Lydia is 21</li>
<li>B: functionfunction</li>
<li>C: Lydia is 21Lydia is 21</li>
<li>D: Lydia is 21function</li>
</ul>
<p><strong>分析：</strong></p>
<p>call 和 bind 都可以修改 this 的指向，但区别在于 call 方法会立即执行，而 bind 会返回一个修改后的新函数。</p>
<h3 id="下面代码的输出是什么？（-B-）-5"><a href="#下面代码的输出是什么？（-B-）-5" class="headerlink" title="下面代码的输出是什么？（ B ）"></a>下面代码的输出是什么？（ B ）</h3><pre><code class="plain">function sayHi() &#123;
  return (() =&gt; 0)();
&#125;

typeof sayHi();
</code></pre>
<ul>
<li>A: <em>“object”</em></li>
<li>B: <em>“number”</em></li>
<li>C: <em>“function”</em></li>
<li>D: <em>“undefined”</em></li>
</ul>
<p><strong>分析：</strong></p>
<p>return 后是一个 IIFE*，其返回值是 0，因此 *sayHi 函数中返回的是一个 0。typeof 检测 sayHi 返回值类型即为 number。</p>
<h3 id="下面这些值哪些是假值？（-A-）"><a href="#下面这些值哪些是假值？（-A-）" class="headerlink" title="下面这些值哪些是假值？（ A ）"></a>下面这些值哪些是假值？（ A ）</h3><pre><code class="plain">0;
new Number(0);
(&quot;&quot;);
(&quot; &quot;);
new Boolean(false);
undefined;
</code></pre>
<ul>
<li>A: 0 <em>“”</em> undefined</li>
<li>B: 0new Number(0) <em>“”</em> new Boolean(false)undefined</li>
<li>C: 0 <em>“”</em> new Boolean(false)undefined</li>
<li>D: 所有都是假值。</li>
</ul>
<p><strong>分析：</strong></p>
<p>JavaScript 中假值只有 6 个：false<em>、””<em>、null</em>、undefined、NaN、</em>0</p>
<h3 id="下面代码的输出是什么？（-B-）-6"><a href="#下面代码的输出是什么？（-B-）-6" class="headerlink" title="下面代码的输出是什么？（ B ）"></a>下面代码的输出是什么？（ B ）</h3><pre><code class="plain">console.log(typeof typeof 1);
</code></pre>
<ul>
<li>A: <em>“number”</em></li>
<li>B: <em>“string”</em></li>
<li>C: <em>“object”</em></li>
<li>D: <em>“undefined”</em></li>
</ul>
<p>分析：</p>
<p>typeof 1 返回 _”number”_，typeof “number” 返回 <em>“string”</em></p>
<h3 id="下面代码的输出是什么？（-C-）-10"><a href="#下面代码的输出是什么？（-C-）-10" class="headerlink" title="下面代码的输出是什么？（ C ）"></a>下面代码的输出是什么？（ C ）</h3><pre><code class="plain">const numbers = [1, 2, 3];
numbers[10] = 11;
console.log(numbers);
</code></pre>
<ul>
<li>A: [1, 2, 3, 7 x null, 11]</li>
<li>B: [1, 2, 3, 11]</li>
<li>C: [1, 2, 3, 7 x empty, 11]</li>
<li>D: SyntaxError</li>
</ul>
<p><strong>分析：</strong></p>
<p>当你为数组中的元素设置一个超过数组长度的值时，JavaScript 会创建一个名为“空插槽”的东西。 这些位置的值实际上是 undefined，但你会看到类似的东西：</p>
<pre><code class="plain">[1, 2, 3, 7 x empty, 11]
</code></pre>
<p>这取决于你运行它的位置（每个浏览器有可能不同）。</p>
<h3 id="下面代码的输出是什么？（-A-）-7"><a href="#下面代码的输出是什么？（-A-）-7" class="headerlink" title="下面代码的输出是什么？（ A ）"></a>下面代码的输出是什么？（ A ）</h3><pre><code class="plain">(() =&gt; &#123;
  let x, y;
  try &#123;
    throw new Error();
  &#125; catch (x) &#123;
    (x = 1), (y = 2);
    console.log(x);
  &#125;
  console.log(x);
  console.log(y);
&#125;)();
</code></pre>
<ul>
<li>A: 1undefined2</li>
<li>B: undefinedundefinedundefined</li>
<li>C: 112</li>
<li>D: 1undefinedundefined</li>
</ul>
<p><strong>分析：</strong></p>
<p>catch 块接收参数 x。当我们传递参数时，这与变量的 x 不同。这个变量 x 是属于 catch 作用域的。</p>
<p>之后，我们将这个块级作用域的变量设置为 1，并设置变量 y 的值。 现在，我们打印块级作用域的变量 x，它等于 1。</p>
<p>在 catch 块之外，x 仍然是 undefined*，而 <em>y 是 2。 当我们想在 catch 块之外的 console.log(x) 时，它返回 undefined</em>，而 *y 返回 2。</p>
<h3 id="下面代码的输出是什么"><a href="#下面代码的输出是什么" class="headerlink" title="下面代码的输出是什么?"></a>下面代码的输出是什么?</h3><pre><code class="plain">[[0, 1], [2, 3]].reduce(
  (acc, cur) =&gt; &#123;
    return acc.concat(cur);
  &#125;,
  [1, 2]
);
</code></pre>
<ul>
<li>A: [0, 1, 2, 3, 1, 2]</li>
<li>B: [6, 1, 2]</li>
<li>C: [1, 2, 0, 1, 2, 3]</li>
<li>D: [1, 2, 6]</li>
</ul>
<p><strong>分析：</strong></p>
<p>[1,2] 是我们的初始值。 这是我们开始执行 reduce 函数的初始值，以及第一个 acc 的值。 在第一轮中，acc 是 [1,2]<em>，</em>cur 是 _[0,1]。 我们将它们连接起来，结果是 _[1,2,0,1]。</p>
<p>然后，acc 的值为 [1,2,0,1]<em>，</em>cur 的值为 _[2,3]。 我们将它们连接起来，得到 _[1,2,0,1,2,3]。</p>
<h3 id="下面代码的输出是什么？（-B-）-7"><a href="#下面代码的输出是什么？（-B-）-7" class="headerlink" title="下面代码的输出是什么？（ B ）"></a>下面代码的输出是什么？（ B ）</h3><pre><code class="plain">!!null;
!!&quot;&quot;;
!!1;
</code></pre>
<ul>
<li>A: false true false</li>
<li>B: false false true</li>
<li>C: false true true</li>
<li>D: true true false</li>
</ul>
<p><strong>分析：</strong></p>
<p>null 是假值。 !null 返回 true*。 *!true 返回 false。</p>
<p><em>“”</em> 是假值。 !”” 返回 true*。 *!true 返回 false。</p>
<p>1 是真值。 !1 返回 false*。 *!false 返回 true。</p>
<h3 id="setInterval-方法的返回值什么？（-A-）"><a href="#setInterval-方法的返回值什么？（-A-）" class="headerlink" title="setInterval 方法的返回值什么？（ A ）"></a>setInterval 方法的返回值什么？（ A ）</h3><pre><code class="plain">setInterval(() =&gt; console.log(&quot;Hi&quot;), 1000);
</code></pre>
<ul>
<li>A：一个唯一的 id</li>
<li>B：指定的毫秒数</li>
<li>C：传递的函数</li>
<li>D：undefined</li>
</ul>
<p><strong>分析：</strong></p>
<p>它返回一个唯一的 id*。 此 *id 可用于使用 clearInterval() 函数清除该定时器。</p>
<h3 id="下面代码的返回值是什么？（-A-）"><a href="#下面代码的返回值是什么？（-A-）" class="headerlink" title="下面代码的返回值是什么？（ A ）"></a>下面代码的返回值是什么？（ A ）</h3><pre><code class="plain">[...&quot;Lydia&quot;];
</code></pre>
<ul>
<li>A: [“L”, “y”, “d”, “i”, “a”]</li>
<li>B: [“Lydia”]</li>
<li>C: [[], “Lydia”]</li>
<li>D: [[“L”, “y”, “d”, “i”, “a”]]</li>
</ul>
<p><strong>分析：</strong></p>
<p>字符串是可迭代的。 扩展运算符将迭代的每个字符映射到一个元素。</p>
<h3 id="分析以下代码的执行结果并解释为什么。"><a href="#分析以下代码的执行结果并解释为什么。" class="headerlink" title="分析以下代码的执行结果并解释为什么。"></a>分析以下代码的执行结果并解释为什么。</h3><pre><code class="plain">var a = &#123;n: 1&#125;;
var b = a;
a.x = a = &#123;n: 2&#125;;

console.log(a.x)
console.log(b.x)
</code></pre>
<p>运行结果：</p>
<p>undefined<em>、{n: 2}</em></p>
<p>分析：</p>
<p>首先，a 和 b 同时引用了 {n: 1} 对象，接着执行到 a.x = a = {n: 2} 语句，虽然赋值是从右到左执行，但是点（.）的优先级比赋值符（=）要高，所以这里首先执行 a.x*，相当于为 a（或者 b）所指向的 *{n:1} 对象新增了一个属性 x，即此时对象将变为 {n: 1; x: undefined}*。然后按正常情况，从右到左进行赋值，此时执行 *a = {n: 2} 的时候，a 的引用改变，指向了新对象 {n: 2}*，而 *b 依然指向的是旧对象 {n: 1; x: undefined}*。之后再执行 *a.x = {n: 2} 的时候，并不会重新解析一遍 a，而是沿用最初解析 a.x 时候的 a，即旧对象 {n: 1; x: undefined}*，故此时旧对象的 <em>x 的值变为</em>{n: 2}，旧对象为 {n: 1; x: {n: 2}}，它依然被 *b 引用着。</p>
<p>最后，a 指向的对象为 {n: 2}<em>，</em>b 指向的对象为 {n: 1; x: {n: 2}}*。因此输出 <em>a.x 值为 undefined</em>，输出 *b.x 值为 {n: 2}。</p>
<h3 id="分析以下代码的执行结果并解释为什么。-1"><a href="#分析以下代码的执行结果并解释为什么。-1" class="headerlink" title="分析以下代码的执行结果并解释为什么。"></a>分析以下代码的执行结果并解释为什么。</h3><pre><code class="plain">// example 1
var a = &#123;&#125;, b = &#39;123&#39;, c = 123;
a[b] = &#39;b&#39;;
a[c] = &#39;c&#39;;
console.log(a[b]);

// example 2
var a = &#123;&#125;, b = Symbol(&#39;123&#39;), c = Symbol(&#39;123&#39;);
a[b] = &#39;b&#39;;
a[c] = &#39;c&#39;;
console.log(a[b]);

// example 3
var a = &#123;&#125;, b = &#123;key:&#39;123&#39;&#125;, c = &#123;key:&#39;456&#39;&#125;;
a[b] = &#39;b&#39;;
a[c] = &#39;c&#39;;
console.log(a[b]);
</code></pre>
<p>运行结果：</p>
<p>example 1<em>：</em>c</p>
<p>example 2<em>：</em>b</p>
<p>example 3<em>：</em>c</p>
<p>分析：</p>
<p>这题考察的是对象的键名的转换。</p>
<ul>
<li>对象的键名只能是字符串和 Symbol 类型。</li>
<li>其他类型的键名会被转换成字符串类型。</li>
<li>对象转字符串默认会调用 String 方法。</li>
</ul>
<p>因此 example 1 中 c 作为键名后也是 ‘123’*，直接覆盖 *a[b] 的值；而 example 2 中，Symbol 作为 ES6 中新增的基本数据类型，它的特点就是唯一，Symbol() 方法生成的值都是唯一的，里面的参数不会影响结果。因此在 example 2 中 b 和 c 是两个不同的键名；example 3 中，对象不能作为键名，因此 b 和 c 都会通过 String() 方法转为字符串 _[object Object]_。</p>
<h3 id="下面的代码的输出是什么-不知道，偏"><a href="#下面的代码的输出是什么-不知道，偏" class="headerlink" title="下面的代码的输出是什么(不知道，偏)"></a>下面的代码的输出是什么(不知道，偏)</h3><pre><code class="plain">var b = 10;
(function b() &#123;
  b = 20;
  console.log(b)
&#125;)()
</code></pre>
<p>运行结果：</p>
<p>function b() { b = 20; console.log(b) } 分析：</p>
<p>当 JavaScript 解释器遇到非匿名立即执行函数（题目中的 b）时，会创建一个辅助的特定对象，然后将函数名称当作这个对象的属性，因此函数内部可以访问到 b，但是这个值又是只读的，所以对他的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。</p>
<h3 id="下面代码中，a-在什么情况下会执行输出语句打印-1-？"><a href="#下面代码中，a-在什么情况下会执行输出语句打印-1-？" class="headerlink" title="下面代码中，a 在什么情况下会执行输出语句打印 1 ？"></a>下面代码中，a 在什么情况下会执行输出语句打印 1 ？</h3><pre><code class="plain">var a = ?;
if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123;
     console.log(1);
&#125;
</code></pre>
<p>分析：</p>
<p>这道题考查的知识点是：相等运算符（==）在作比较时会进行隐式转换，而如果操作数是引用类型，则会调用 toString() 或 valueOf() 方法对引用类型数据进行隐式转换。</p>
<pre><code class="plain">// 方法一：利用 toString()
let a = &#123;
  i: 1,
  toString () &#123;
    return a.i++;
  &#125;
&#125;
if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;
  console.log(&#39;1&#39;);
&#125;

// 方法二：利用 valueOf()
let a = &#123;
  i: 1,
  valueOf () &#123;
    return a.i++
  &#125;
&#125;
if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;
  console.log(&#39;1&#39;);
&#125;

// 方法三：利用数组（这个是真的骚）
var a = [1,2,3];
a.join = a.shift;
if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;
  console.log(&#39;1&#39;);
&#125;

// 方法四：利用 Symbol
let a = &#123;[Symbol.toPrimitive]: ((i) =&gt; () =&gt; ++i) (0)&#125;;
if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;
  console.log(&#39;1&#39;);
&#125;
</code></pre>
<p>方法一和方法二没啥解释的了，解释下方法三和方法四。</p>
<p>方法三：</p>
<p>a.join = a.shift 的目的是将数组的 join 方法替换成 shift 方法。因为数组在参与相等比较时也会通过 toString() 将数组转为字符串，而该字符串实际上是数组中每个元素的 toString() 返回值经调用 join() 方法拼接（由逗号隔开）组成。现在我们将 join() 方法替换为了 shift() 方法，也就意味着数组在通过 toString() 隐式转换后，得到是 shift() 的返回值，每次返回数组中的第一个元素，而原数组删除第一个值，正好可以使判断成立。</p>
<p>方法四：</p>
<p>ES6 中提供了 11 个内置的 Symbo 值，指向语言内部使用的方法。Symbol.toPrimitive 就是其中一个，它指向一个方法，当该对象被转为原始类型的值时，会调用这个方法，并返回该对象对应的原始类型值。这里就是改变这个属性，把它的值改为一个闭包返回的函数。</p>

    </div>
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 后知后觉的个人主页
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;知乐
        </div>
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src='/js/main.js'></script>
    </body>
</html>
