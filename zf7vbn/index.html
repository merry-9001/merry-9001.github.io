
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>ES6 | 后知后觉的个人主页</title>
        <meta name="author" content="知乐" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>后知后觉的个人主页</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;首页</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;文档中心</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;后知后觉的个人主页</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenuItems">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">首页</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">文档中心</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

            <transition name="into">
            <div id="main" v-show="!loading">
                <div class="article">
    <div>
        <h1>ES6</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/1/23
        </span>
        
        
    </div>

    <div class="content" v-pre>
        <h1 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h1><p>解决问题</p>
<p>var 不能用于定义常量</p>
<p>var 可以重复声明变量</p>
<p>var 存在变量提升</p>
<p>var 不支持块级作用域</p>
<p>不可以重复声明变量</p>
<pre><code>let site = &#39;itLike&#39;;

let site = &#39;itLike&#39;;

console.log(site);
</code></pre>
<p>不存在变量提升</p>
<pre><code>console.log(site);
let site = &#39;itLike&#39;;
</code></pre>
<p>const 用来定义常量</p>
<pre><code>const E = 2.718;
</code></pre>
<p>块级作用域用一组大括号定义一个块，使用 let 定义的变量在大括号的外部是访问不到的，此外，let 声明的变量不会污染全局作用域。（let 拥有块级作用域）</p>
<p>const 定义的基本类型不能改变，但是定义的对象是可以通过修改对象属性等方法来改变的。</p>
<pre><code>&#123;let site = &#39;itLike&#39;;&#125;
</code></pre>
<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>对象解构允许我们使用变量的名字匹配对象的属性 匹配成功 将对象属性的值赋值给变量</p>
<pre><code>    let person = &#123;name: &#39;lisi&#39;, age: 30, sex: &#39;男&#39;&#125;;
    let &#123;name: myName&#125; = person;
    console.log(myName)
</code></pre>
<pre><code>let [a, b, c] = [1, 2, 3]
console.log(a, b, c)
let [json, arr, num, str] = [&#123; a: 1, b: 2 &#125;, [1, 2, 3], 8, &#39;str&#39;]
console.log(json, arr, num, str)
let [name1, name2, name3] = nameArr;
let &#123;name: lkName, age: lkAge, sex: lkSex&#125;= &#123;name: &#39;小煤球&#39;, age: 1, sex: &#39;公&#39;&#125;;
</code></pre>
<ul>
<li>解构赋值<ul>
<li>左右两个边结构必须一样</li>
<li>右边必须是个东西</li>
<li>声明和赋值赋值不能分开，必须在一句话里</li>
</ul>
</li>
</ul>
<h1 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h1><h2 id="获取自身属性"><a href="#获取自身属性" class="headerlink" title="获取自身属性"></a>获取自身属性</h2><pre><code>        // 用于获取对象自身所有的属性
        var obj = &#123;
            id: 1,
            pname: &#39;小米&#39;,
            price: 1999,
            num: 2000
        &#125;;
        var arr = Object.keys(obj);
        console.log(arr);
</code></pre>
<h1 id="类操作"><a href="#类操作" class="headerlink" title="类操作"></a>类操作</h1><p>在之前定义类是通过构造函数来操作的，es6 新增了 class 关键字，此时，我们也可以像其它语言一样来创建各种类了。</p>
<pre><code>    class Person&#123;
        constructor(name, age)&#123;
            this.name = name;
            this.age = age;
        &#125;
        print()&#123;
            console.log(&#39;我叫&#39; + this.name + &#39;,今年&#39; + this.age + &#39;岁&#39;);
        &#125;
    &#125;
</code></pre>
<h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><pre><code>         class Father &#123;
                        // constructor 里面的this 指向的是 创建的实例对象
            constructor(x, y) &#123;
                this.x = x;  //this.x这样这个x函数体内的所有函数都可以访问了
                this.y = y;
            &#125;
            sum() &#123;
                console.log(this.x + this.y);
            &#125;
        &#125;
        class Son extends Father &#123;
            constructor(x, y) &#123;
                super(x, y); //调用了父类中的构造函数
            &#125;
        &#125;
        var son = new Son(1, 2);
        var son1 = new Son(11, 22);
        son.sum();
        son1.sum();
</code></pre>
<p>继承中的属性或者方法查找原则: 就近原则</p>
<ol>
<li> 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的</li>
<li> 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则)</li>
</ol>
<h1 id="重载（to-do）"><a href="#重载（to-do）" class="headerlink" title="重载（to do）"></a>重载（to do）</h1><p>什么时重载？</p>
<p>ES6 带来了 Proxy 和 Reflect，配合使用可以实现重载。</p>
<p>Proxy 用于修改某些操作的默认行为，相当于对原始想进行的操作进行“包装”；</p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy 用于修改某些操作的默认行为，即对编程语言层面进行修改，属于“元编程”，Proxy 意思为“代理”，即在访问对象之前建立一道“拦截”，任何访问该对象的操作之前都会通过这道“拦截”，即执行 Proxy 里面定义的方法。</p>
<pre><code>ES6原生规定的Proxy的基本用法为
let pro = new Proxy(target,handler);
</code></pre>
<p>其中 new Proxy 相当于创建了一个 Proxy 实例，target 为所要拦截的目标对象，handler 也是一个对象，里面定义的是对拦截对象所要进行的拦截方法。</p>
<p>Proxy 实例 1</p>
<pre><code> let target = &#123;
      name:&quot;小明&quot;，
      age: 15
 &#125;
 let handler = &#123;
       get:(target,name,)=&gt;&#123;//读取属性
             return &quot;success&quot;
        &#125;
 &#125;
let pro = new Proxy(target,handler);
console.log(pro.name);
//此时打印出来的结果为 success；
</code></pre>
<p>解释：创建的 target 对象为所要拦截的对象，handler 对象为拦截对象后执行的操作，这里 get 方法为读取操作，即用户想要读取 pro 中的属性时执行的拦截操作。最后创建一个 Proxy 实例，因为我设定的读取拦截操作为返回一个“success”字符串，所以当我想读取 pro 中的属性时，结果打印出来的总是“success”字符串。</p>
<p>（2）Proxy 常用的拦截方法</p>
<p>1、get(target,name,property)方法，用于拦截某个读取属性的操作</p>
<p>第一个参数为目标对象</p>
<p>第二个参数为属性名称</p>
<p>第三个属性为操作所针对的对象（可选参数）。</p>
<pre><code>      let handler = &#123;
               get:function(target,name,property)&#123;
                    if(name in target)&#123;
                           cosnole.log(&quot;success&quot;);
                     &#125;else&#123;
                           console.log(&quot;error&quot;)
                     &#125;
                     return Reflect.get(target,name,property);
                &#125;
       &#125;
       let target =  &#123;
            name:&quot;小明&quot;,
            age:15
      &#125;
      let pro = new Proxy(target,handler);
      pro.name;
     //结果为 success
      pro.grade;
      //结果为error
</code></pre>
<p>2、set(target,name,value,property),用于拦截某个属性的赋值操作，第一个参数为目标对象，第二个参数为属性名，第三个参数为属性值，第四个参数为操作行为所针对的对象（可选参数）。</p>
<p>3、has(target,key),用来拦截对象是否具有某个属性值的操作，第一个参数为目标对象，第二个参数为属性名</p>
<pre><code>       let handler = &#123;
              has:function(target,key)&#123;
                     if(key[0] != &quot;_&quot;)&#123;
                            return  false
                     &#125;
                     return true;
                &#125;
       &#125;
       let target =  &#123;
            _name:&quot;小明&quot;,
            age:15
      &#125;
      let pro = new Proxy(target,handler);
      console.log(&quot;_name&quot; in pro);
      //打印结果为 true
      console.log(&quot;age&quot; in pro);
      //打印结果为false
</code></pre>
<h3 id="Reflect-对象"><a href="#Reflect-对象" class="headerlink" title="Reflect 对象"></a>Reflect 对象</h3><p>Reflect 对象的方法与 Proxy 对象的方法一一对应，这使得 Proxy 对象可以方便的调用对应的 Reflect 方法完成默认行为。</p>
<p>简单说，就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p>
<p>概述</p>
<p>1、Reflect 对象与 Proxy 对象一样，都是 ES6 对操作对象设计的 API<br>2、对于我个人的理解而言，Reflect 设计的目的是为了优化 Object 的一些操作方法以及合理的返回 Object 操作返回的结果，对于一些命令式的 Object 行为，Reflect 对象可以将其变为函数式的行为</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul>
<li>映射 一个对一个</li>
</ul>
<pre><code>let arr = [12, 5, 8]
let result = arr.map(function (item) &#123;
    return item*2
&#125;)
let result2 = arr.map(item=&gt;item*2) // 简写
console.log(result)
console.log(result2)

let score = [18, 86, 88, 24]
let result3 = score.map(item =&gt; item &gt;= 60 ? &#39;及格&#39; : &#39;不及格&#39;)
console.log(result3)

// 结果
[ 24, 10, 16 ]
[ 24, 10, 16 ]
[ &#39;不及格&#39;, &#39;及格&#39;, &#39;及格&#39;, &#39;不及格&#39; ]
</code></pre>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>汇总 一堆出来一个</p>
<ul>
<li>用于比如，算个总数，算个平均</li>
</ul>
<pre><code>var arr = [1, 3, 5, 7]
var result = arr.reduce(function (tmp, item, index) &#123;
    //tmp 上次结果，item当前数，index次数1开始
    console.log(tmp, item, index)
    return tmp + item
&#125;)
console.log(result)

var arr = [1, 3, 5, 7]
var result = arr.reduce(function (tmp, item, index) &#123;
    if (index != arr.length - 1) &#123; // 不是最后一次
        return tmp + item
    &#125; else &#123;
        return (tmp + item)/arr.length
    &#125;
&#125;)
console.log(result)  // 平均值
</code></pre>
<h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><pre><code>        var arr1 = [&#39;red&#39;, &#39;pink&#39;, &#39;blue&#39;];
        var flag1 = arr1.some(function(value) &#123;
            return value == &#39;pink&#39;;
        &#125;);
</code></pre>
<p>filter 也是查找满足条件的元素 返回的是一个数组 而且是把所有满足条件的元素返回回来</p>
<p>some 也是查找满足条件的元素是否存在 返回的是一个布尔值 如果查找到第一个满足条件的元素就终止循环</p>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>过滤器 保留为 true 的</p>
<pre><code>var arr = [12, 4, 8, 9]
var result = arr.filter(item =&gt; (item % 3 === 0) ? true : false)
console.log(result)
var result = arr.filter(item =&gt; item % 3 === 0)
console.log(result)

var arr = [
    &#123; title: &#39;苹果&#39;, price: 10 &#125;,
    &#123; title: &#39;西瓜&#39;, price: 20 &#125;,
]
var result = arr.filter(json =&gt; json.price &gt;= 20)
console.log(result)
</code></pre>
<pre><code>        var arr = [12, 66, 4, 88, 3, 7];
        var newArr = arr.filter(function(value, index) &#123;
            // return value &gt;= 20;
            return value % 2 === 0;
        &#125;);
        console.log(newArr);
</code></pre>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li>多了两个新方法<ul>
<li><code>startsWith</code></li>
<li><code>endsWith</code></li>
</ul>
</li>
</ul>
<pre><code>var url = &#39;http://qq.com&#39;
console.log(url.startsWith(&#39;http&#39;))
console.log(url.endsWith(&#39;com&#39;))
// 都是 true
</code></pre>
<p>判断是不是开头和结尾 结果是 true 和 false</p>
<p>repeat 可以重复</p>
<pre><code>        console.log(&quot;y&quot;.repeat(5))
</code></pre>
<ul>
<li>字符串模版<ul>
<li>使用反引号，<code>$&#123;变量&#125;</code></li>
<li>可以折行</li>
</ul>
</li>
</ul>
<pre><code>let a = 12
let str1 = `asdf$&#123;a&#125;`
console.log(str1)

let title = &#39;标题&#39;
let content = &#39;内容&#39;
let str = `&lt;div&gt;
&lt;h1&gt;$&#123;title&#125;&lt;/h1&gt;
&lt;p&gt;$&#123;content&#125;&lt;/p&gt;
`
console.log(str)
&lt;div&gt;
&lt;h1&gt;标题&lt;/h1&gt;
&lt;p&gt;内容&lt;/p&gt;
</code></pre>
<h1 id="面向对象-基础"><a href="#面向对象-基础" class="headerlink" title="面向对象-基础"></a>面向对象-基础</h1><ul>
<li>原来写法<ul>
<li>类和构造函数一样</li>
<li>属性和方法分开写的</li>
</ul>
</li>
</ul>
<pre><code>// 老版本
function User(name, pass) &#123;
    this.name = name
    this.pass = pass
&#125;
User.prototype.showName = function () &#123;
    console.log(this.name)
&#125;
User.prototype.showPass = function () &#123;
    console.log(this.pass)
&#125;

var u1 = new User(&#39;able&#39;, &#39;1233&#39;)
u1.showName()
u1.showPass()
// 老版本继承
function VipUser(name, pass, level) &#123;
    User.call(this, name, pass)
    this.level = level
&#125;
VipUser.prototype = new User()
VipUser.prototype.constructor = VipUser
VipUser.prototype.showLevel = function () &#123;
    console.log(this.level)
&#125;

var v1 = new VipUser(&#39;blue&#39;, &#39;1234&#39;, 3)
v1.showName()
v1.showLevel()
</code></pre>
<ul>
<li>新版面向对象<ul>
<li>有了 class 关键字、构造器</li>
<li>class 里面直接加方法</li>
<li>继承，super 超类==父类</li>
</ul>
</li>
</ul>
<pre><code>class User &#123;
    constructor(name, pass) &#123;
        this.name = name
        this.pass = pass
    &#125;
    showName() &#123;
        console.log(this.name)
    &#125;
    showPass() &#123;
        console.log(this.pass)
    &#125;
&#125;

var u1 = new User(&#39;able2&#39;, &#39;111&#39;)
u1.showName()
u1.showPass()

// 新版本继承
class VipUser extends User &#123;
    constructor(name, pass, level) &#123;
        super(name, pass)
        this.level = level
    &#125;
    showLevel()&#123;
        console.log(this.level)
    &#125;
&#125;

v1 = new VipUser(&#39;blue&#39;, &#39;123&#39;, 3)
v1.showLevel()
</code></pre>
<h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><ul>
<li>JSON 格式<ul>
<li>JavaScript Object Notation 的缩写，是一种用于数据交换的文本格式</li>
<li>JSON 是 JS 对象 的严格子集</li>
<li>JSON 的标准写法</li>
<li>只能用双引号</li>
<li>所有的 key 都必须用双引号包起来</li>
</ul>
</li>
<li>JSON 对象<ul>
<li>JSON 对象是 JavaScript 的原生对象，用来处理 JSON 格式数据，有两个静态方法</li>
<li>JSON.parse(string) ：接受一个 <strong>JSON 字符串</strong>并将其转换成一个 JavaScript <strong>对象</strong>。</li>
<li>JSON.stringify(obj) ：接受一个 JavaScript <strong>对象</strong>并将其转换为一个 <strong>JSON 字符串</strong>。</li>
</ul>
</li>
</ul>
<pre><code>var json = &#123;a: 12, b: 5&#125;
var str = &#39;hi,&#39; + JSON.stringify(json)
var url = &#39;http://www.xx.com/&#39; + encodeURIComponent(JSON.stringify(json))
console.log(str)
console.log(url)

var str = &#39;&#123;&quot;a&quot;: 12, &quot;b&quot;: 4, &quot;c&quot;: &quot;abc&quot;&#125;&#39;
var json = JSON.parse(str)
console.log(json)
hi,&#123;&quot;a&quot;:12,&quot;b&quot;:5&#125;
http://www.xx.com/%7B%22a%22%3A12%2C%22b%22%3A5%7D
&#123; a: 12, b: 4, c: &#39;abc&#39; &#125;
</code></pre>
<ul>
<li>对象（object）<ul>
<li>是 JavaScript 语言的核心概念，也是最重要的数据类型</li>
<li>对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合</li>
<li>对象的所有键名都是字符串, 所以加不加引号都可以</li>
<li>如果键名是数值，会被自动转为字符串</li>
<li>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型</li>
<li>如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用</li>
<li>in 运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值</li>
<li>for…in 循环用来遍历一个对象的全部属性</li>
</ul>
</li>
<li>对象 简写<ul>
<li>key-value 一样时可以简写</li>
<li>里面函数可以简写, 去掉</li>
</ul>
</li>
</ul>
<pre><code>var a = 12, b = 5
console.log(&#123;a:a, b:b&#125;)
console.log(&#123;a, b&#125;)
console.log(&#123;a, b, c:&quot;c&quot;&#125;)
console.log(&#123; a, b, show()&#123; console.log(&#39;a&#39;) &#125;&#125;)
&#123; a: 12, b: 5 &#125;
&#123; a: 12, b: 5 &#125;
&#123; a: 12, b: 5, c: &#39;c&#39; &#125;
&#123; a: 12, b: 5, show: [Function: show] &#125;
</code></pre>
<h1 id="generator-to-do"><a href="#generator-to-do" class="headerlink" title="generator(to do)"></a>generator(to do)</h1><p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p>
<p>认识生成器函数</p>
<ul>
<li>generator 生成器函数<ul>
<li>普通函数，一路到底</li>
<li>generator 函数，中间可以停，到哪停呢，用 yield 配合，交出执行权</li>
<li>yield 有 放弃、退让、退位的意思</li>
<li>需要调用 next()方法启动执行，需要遇到 yield 停, 踹一脚走一步</li>
<li>generator 函数前面加一个 <code>*</code> 两边可以有空格，或靠近函数或<code>function</code></li>
<li>背后实际生成多个小函数，实现走走停停</li>
</ul>
</li>
</ul>
<pre><code>function show() &#123;
    console.log(&#39;a&#39;)
    console.log(&#39;b&#39;)
&#125;
show() // 普通函数

function *show2() &#123;
    console.log(&#39;1&#39;)
    yield
    console.log(&#39;2&#39;)
&#125;
let genObj = show2()
genObj.next() // 1
genObj.next() // 2
genObj.next() // 最后了，没有结果
</code></pre>
<h2 id="generator-yield-是啥"><a href="#generator-yield-是啥" class="headerlink" title="generator-yield 是啥"></a>generator-yield 是啥</h2><ul>
<li><code>yield</code><ul>
<li>既可传参，又可以返回</li>
<li>第一个<code>next()</code>传参无效，只用来启动</li>
</ul>
</li>
<li>如果函数前漏掉 <code>*</code><ul>
<li>就是普通函数</li>
<li>如果有<code>yield</code>会报错， <code>ReferenceError: yield is not defined</code></li>
<li>yield 只能在 Generator 函数内部使用</li>
</ul>
</li>
</ul>
<pre><code>function * show() &#123;
    console.log(&#39;1&#39;)
    var a = yield
    console.log(&#39;2&#39;)
    console.log(a)
&#125;
// yield 传参
var gen = show()
gen.next() // 1
gen.next() // 2 和 undefined 因为没有传参，yield没有返回值
var gen = show()
gen.next(10) // 1 第一次执行到yield，但没有执行赋值
gen.next(20) // 2 和 20

function* show2() &#123;
    console.log(&#39;1&#39;)
    yield 10
    console.log(&#39;2&#39;)
&#125;
// yield 返回
var gen = show2()
var res1 = gen.next()
console.log(res1) // &#123; value: 10, done: false &#125;
var res2 = gen.next()
console.log(res2)
// &#123; value: undefined, done: true &#125; 最后的value需要return返回
</code></pre>
<h2 id="generator-实例"><a href="#generator-实例" class="headerlink" title="generator-实例"></a>generator-实例</h2><ul>
<li><strong>Promise 适合一次读一组</strong></li>
<li><strong>generator 适合逻辑性的</strong></li>
</ul>
<pre><code>// 带逻辑-generator
runner(function * () &#123;
    let userData = yield $.ajax(&#123;url: &#39;getUserData&#39;&#125;)

    if (userData.type == &#39;VIP&#39;) &#123;
        let items = yield $.ajax(&#123;url: &#39;getVIPItems&#39;&#125;)
    &#125; else &#123;
        let items = yield $.ajax(&#123;url: &#39;getItems&#39;&#125;)
    &#125;
&#125;)
// yield 实例，用同步方式写异步
server.use(function * () &#123;
    let data = yield db.query(`select * from user_table`)
    this.body = data
&#125;)
</code></pre>
<h1 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h1><p>第七种数据类型</p>
<p>生成唯一的标识符来避免冲突</p>
<p>不能被遍历</p>
<p>可以用于当做私有属性</p>
<h1 id="ES7-预览"><a href="#ES7-预览" class="headerlink" title="ES7 预览"></a>ES7 预览</h1><ul>
<li>数组<ul>
<li><code>arr.includes()</code> 数组是否包含某个东西</li>
<li>数组的 arr.keys(), arr,entries()</li>
<li>for … in 遍历数组 下标 key</li>
<li>for … of 遍历数组 值 value, 不能用于 json</li>
</ul>
</li>
</ul>
<pre><code>let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
console.log(arr.includes(1))

for (let i in arr) &#123;
    console.log(i) // 循环的时下标 key
&#125;

for (let i of arr) &#123;
    console.log(i) // 循环的是值 value
&#125;
for (let i of arr.keys()) &#123;
    console.log(&#39;&gt;&#39;+i)
&#125;
for (let [key, value] of arr.entries()) &#123;
    console.log(&#39;&gt;&#39; + key + value)
&#125;

let json = &#123; a: 12, b: 5, c: 7 &#125;
for (let i in json) &#123;
    console.log(i)
&#125;
</code></pre>
<ul>
<li>字符串<ul>
<li>padStart()/padEnd() 指定宽度，不够就补空格或指定字符</li>
</ul>
</li>
</ul>
<pre><code>console.log(&#39;=&#39; + &#39;abcd&#39;.padStart(6, &#39;0&#39;) + &#39;=&#39;)
console.log(&#39;=&#39; + &#39;abcd&#39;.padEnd(6, &#39;0&#39;) + &#39;=&#39;)
=00abcd=
=abcd00=
</code></pre>
<ul>
<li>容忍度<ul>
<li>[1, 2, 3,] 老版数组最后不能有逗号，新的可以有</li>
<li>函数参数最后多的逗号也可以</li>
</ul>
</li>
<li>async await<ul>
<li>和 generator yield 类似</li>
<li>generator 不可以写成箭头函数， async 可以</li>
</ul>
</li>
</ul>
<pre><code>async function show() &#123;
    console.log(1)
    await
    console.log(2)
&#125;
</code></pre>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>
    </div>
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 后知后觉的个人主页
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;知乐
        </div>
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src='/js/main.js'></script>
    </body>
</html>
